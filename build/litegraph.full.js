// global.js
export function getGlobalObject() {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('Unable to determine global object');
}

export function setGlobalVariable(key, value) {
    const globalObject = getGlobalObject();
    globalObject[key] = value;
}

export function getGlobalVariable(key) {
    const globalObject = getGlobalObject();
    return globalObject[key];
}


/**
 * @class LiteGraph
 *
 * @NOTE:
 * Try to avoid adding things to this class.
 * https://dzone.com/articles/singleton-anti-pattern
 */
export class LiteGraphClass {

    VERSION = "a0.11.0";

    LLink = null; //LLink;
    LGraph = null; //LGraph;
    LGraphNode = null; //LGraphNode;
    LGraphGroup = null; //LGraphGroup;
    LGraphCanvas = null; //LGraphCanvas;
    Subgraph = null; //Subgraph;
    GraphInput = null; //GraphInput;
    GraphOutput = null; //GraphOutput;
    DragAndScale = null; //DragAndScale;
    ContextMenuClass = null; //ContextMenuClass;
    ContextMenu = null;
    // ContextMenu = function(){ return new ContextMenuClass(...arguments); };
    CallbackHandler = null; //CallbackHandler;

    CANVAS_GRID_SIZE = 10;
    NODE_TITLE_HEIGHT = 30;
    NODE_TITLE_TEXT_Y = 20;
    NODE_SLOT_HEIGHT = 20;
    NODE_WIDGET_HEIGHT = 20;
    NODE_WIDTH = 140;
    NODE_MIN_WIDTH = 50;
    NODE_MIN_SIZE = [50, 0];
    NODE_COLLAPSED_RADIUS = 10;
    NODE_COLLAPSED_WIDTH = 80;
    NODE_TITLE_COLOR = "#999";
    NODE_SELECTED_TITLE_COLOR = "#FFF";
    NODE_TEXT_SIZE = 14;
    NODE_TEXT_COLOR = "#AAA";
    NODE_SUBTEXT_SIZE = 12;
    NODE_DEFAULT_COLOR = "#333";
    NODE_DEFAULT_BGCOLOR = "#353535";
    NODE_DEFAULT_BOXCOLOR = "#666";
    NODE_DEFAULT_SHAPE = "box";
    NODE_BOX_OUTLINE_COLOR = "#FFF";
    DEFAULT_SHADOW_COLOR = "rgba(0,0,0,0.5)";
    DEFAULT_GROUP_FONT = 24;

    WIDGET_BGCOLOR = "#222";
    WIDGET_OUTLINE_COLOR = "#666";
    WIDGET_TEXT_COLOR = "#DDD";
    WIDGET_SECONDARY_TEXT_COLOR = "#999";

    LINK_COLOR = "#9A9";
    EVENT_LINK_COLOR = "#A86";
    CONNECTING_LINK_COLOR = "#AFA";

    MAX_NUMBER_OF_NODES = 1000; // avoid infinite loops
    DEFAULT_POSITION = [100, 100]; // default node position
    VALID_SHAPES = ["default", "box", "round", "card"]; // ,"circle"

    // shapes are used for nodes but also for slots
    BOX_SHAPE = 1;
    ROUND_SHAPE = 2;
    CIRCLE_SHAPE = 3;
    CARD_SHAPE = 4;
    ARROW_SHAPE = 5;
    GRID_SHAPE = 6; // intended for slot arrays

    // enums
    INPUT = 1;
    OUTPUT = 2;

    EVENT = -1; // for outputs
    ACTION = -1; // for inputs

    NODE_MODES = ["Always", "On Event", "Never", "On Trigger", "On Request"]; // helper
    NODE_MODES_COLORS = ["#666","#422","#333","#224","#626"]; // use with node_box_coloured_by_mode
    ALWAYS = 0;
    ON_EVENT = 1;
    NEVER = 2;
    ON_TRIGGER = 3;
    ON_REQUEST = 4; // used from event-based nodes, where ancestors are recursively executed on needed

    UP = 1;
    DOWN = 2;
    LEFT = 3;
    RIGHT = 4;
    CENTER = 5;

    LINK_RENDER_MODES = ["Straight", "Linear", "Spline"]; // helper
    STRAIGHT_LINK = 0;
    LINEAR_LINK = 1;
    SPLINE_LINK = 2;

    NORMAL_TITLE = 0;
    NO_TITLE = 1;
    TRANSPARENT_TITLE = 2;
    AUTOHIDE_TITLE = 3;
    VERTICAL_LAYOUT = "vertical"; // arrange nodes vertically

    proxy = null; // used to redirect calls
    node_images_path = "";

    catch_exceptions = true;
    throw_errors = true;
    allow_scripts = false; // nodes should be check this value before executing unsafe code :: does not prevent anything in the main library, implement in nodes :: if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
    use_deferred_actions = true; // executes actions during the graph execution flow
    registered_node_types = {}; // nodetypes by string
    node_types_by_file_extension = {}; // used for dropping files in the canvas
    Nodes = {}; // node types by classname
    Globals = {}; // used to store vars between graphs

    searchbox_extras = {}; // used to add extra features to the search box
    auto_sort_node_types = false; // [true!] If set to true, will automatically sort node types / categories in the context menus

    node_box_coloured_when_on = false; // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback
    node_box_coloured_by_mode = false; // [true!] nodebox based on node mode, visual feedback

    dialog_close_on_mouse_leave = true; // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    dialog_close_on_mouse_leave_delay = 500;

    shift_click_do_break_link_from = true; // [false!] prefer false if too easy to break links - implement with ALT or TODO custom keys
    click_do_break_link_to = false; // [false!]prefer false, way too easy to break links

    search_filter_enabled = false; // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
    search_hide_on_mouse_leave = true; // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    search_hide_on_mouse_leave_time = 1200; // time before hiding
    search_show_all_on_open = true; // [true!] opens the results list when opening the search widget

    show_node_tooltip = false; // [true!] show a tooltip with node property "tooltip" over the selected node
    show_node_tooltip_use_descr_property = false; // enabled tooltip from desc when property tooltip not set

    auto_load_slot_types = false; // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]

    // set these values if not using auto_load_slot_types
    registered_slot_in_types = {}; // slot types for nodeclass
    registered_slot_out_types = {}; // slot types for nodeclass
    slot_types_in = []; // slot types IN
    slot_types_out = []; // slot types OUT
    slot_types_default_in = []; // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
    slot_types_default_out = []; // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search

    graphDefaultConfig = {
        align_to_grid: true,
        links_ontop: false,
    };

    alt_drag_do_clone_nodes = false; // [true!] very handy, ALT click to clone and drag the new node
    alt_shift_drag_connect_clone_with_input = true; // [true!] very handy, when cloning, keep input connections with SHIFT

    do_add_triggers_slots = false; // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this

    allow_multi_output_for_events = true; // [false!] being events, it is strongly reccomended to use them sequentially, one by one

    middle_click_slot_add_default_node = false; // [true!] allows to create and connect a ndoe clicking with the third button (wheel)

    release_link_on_empty_shows_menu = false; // [true!] dragging a link to empty space will open a menu, add from list, search or defaults
    two_fingers_opens_menu = false; // [true!] using pointer event isPrimary, when is not simulate right click

    backspace_delete = true; // [false!] delete key is enough, don't mess with text edit and custom

    ctrl_shift_v_paste_connect_unselected_outputs = false; // [true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes

    actionHistory_enabled = false; // cntrlZ, cntrlY
    actionHistoryMaxSave = 300;

    /* EXECUTING ACTIONS AFTER UPDATING VALUES - ANCESTORS */
    refreshAncestorsOnTriggers = false; // [true!]
    refreshAncestorsOnActions = false; // [true!]
    ensureUniqueExecutionAndActionCall = false; // [true!] the new tecnique.. let's make it working best of

    // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.
    // use this if you must have node IDs that are unique across all graphs and subgraphs.
    use_uuids = false;

    // enable filtering elements of the context menu with keypress (+ arrows for navigation, escape to close)
    context_menu_filter_enabled = false; // FIX event handler removal

    // ,"editor_alpha" //= 1; //used for transition

    canRemoveSlots = true;
    canRemoveSlots_onlyOptional = true;
    canRenameSlots = true;
    canRenameSlots_onlyOptional = true;

    ensureNodeSingleExecution = false; // OLD this will prevent nodes to be executed more than once for step (comparing graph.iteration)
    ensureNodeSingleAction = false; // OLD this will prevent nodes to be executed more than once for action call!
    preventAncestorRecalculation = false; // OLD(?) when calculating the ancestors, set a flag to prevent recalculate the subtree

    allowMultiOutputForEvents = false; // being events, it is strongly reccomended to use them sequentually, one by one

    reprocess_slot_while_node_configure = false; // reprocess inputs and output node slots comparing by name, will fix index changes, works on dynamics

    properties_allow_input_binding = false; // [true!] allow create and bind inputs, will update binded property value on node execute 

    log_methods = ['error', 'warn', 'info', 'log', 'debug'];

    cb_handler = false;
    debug = true; // enable/disable logging :: in this.debug_level is stored the actual numeric value
    debug_level = 2; // set via this.logging_set_level

    constructor(){
        // if exporting stripping include for a bundle will trow error because not yet instantiated other classes
        // this.initialize();
    }

    /**
     * initialize LiteGraph, call when other classes are instantiated
     */
    initialize(){
        // event dispatcher, along direct (single) assignment of callbacks [ event entrypoint ]
        this.callbackhandler_setup();

        this.LLink = LLink;
        this.LGraph = LGraph;
        this.LGraphNode = LGraphNode;
        this.LGraphGroup = LGraphGroup;
        this.LGraphCanvas = LGraphCanvas;
        this.Subgraph = Subgraph;
        this.GraphInput = GraphInput;
        this.GraphOutput = GraphOutput;
        this.DragAndScale = DragAndScale;
        this.ContextMenuClass = ContextMenu;
        this.ContextMenu = function(){ return new ContextMenu(...arguments); };
        this.CallbackHandler = CallbackHandler;

        // base inclusion
        this.includeBasicNodes();
    }

    includeBasicNodes(){
        this.registerNodeType("graph/subgraph", Subgraph);
        this.registerNodeType("graph/input", GraphInput);
        this.registerNodeType("graph/output", GraphOutput);
    }

    callbackhandler_setup(){
        if(this.cb_handler) return;
        this.cb_handler = new CallbackHandler(this);
        // register CallbackHandler methods on this // Should move as class standard class methods?
        this.registerCallbackHandler = function(){ return this.cb_handler.registerCallbackHandler(...arguments); };
        this.unregisterCallbackHandler = function(){ return this.cb_handler.unregisterCallbackHandler(...arguments); };
        this.processCallbackHandlers = function(){ return this.cb_handler.processCallbackHandlers(...arguments); };
    }

    registerCallbackHandler(){
        this.callbackhandler_setup();
        this.cb_handler.registerCallbackHandler(...arguments);
    }
    unregisterCallbackHandler(){
        this.callbackhandler_setup();
        this.cb_handler.unregisterCallbackHandler(...arguments);
    }
    processCallbackHandlers(){
        this.callbackhandler_setup();
        this.cb_handler.processCallbackHandlers(...arguments);
    }

    // set logging debug_level
    // from -1 (none), 0 (error), .. to 5 (debug) based on console methods 'error', 'warn', 'info', 'log', 'debug'
    // could be set higher to enable verbose logging
    logging_set_level(v) {
        this.debug_level = Number(v);
    }

    // entrypoint to debug log
    // pass 0 (error) to 4 (debug), (or more for verbose logging)
    logging(lvl/**/) { // arguments

        if(!this.debug && this.debug_level>0) {
            // force only errors
            this.debug_level = 0;
        }
        
        if(lvl > this.debug_level){
            return; // -- break, log only below or equal current --
        }

        function clean_args(args) {
            let aRet = [];
            if(lvl<0 || lvl>4)
                aRet.push("loglvl:"+lvl); // include not standard log level
            for(let iA=1; iA<args.length; iA++) {
                if(typeof(args[iA])!=="undefined") aRet.push(args[iA]);
            }
            return aRet;
        }

        let lvl_txt = "debug";
        if(lvl>=0 && lvl<=4) lvl_txt = ['error', 'warn', 'info', 'log', 'debug'][lvl];

        if(typeof(console[lvl_txt])!=="function") {
            console.warn("[LG-log] invalid console method",lvl_txt,clean_args(arguments));
            throw new RangeError;
        }

        console[lvl_txt]("[LG]",...clean_args(arguments));
    }
    log_error() {
        this.logging(0,...arguments);
    }
    log_warn() {
        this.logging(1,...arguments);
    }
    log_info() {
        this.logging(2,...arguments);
    }
    log_log() {
        this.logging(3,...arguments);
    }
    log_debug() {
        this.logging(4,...arguments);
    }
    log_verbose() {
        this.logging(5,...arguments);
    }

    /**
     * Register a node class so it can be listed when the user wants to create a new one
     * @method registerNodeType
     * @param {String} type name of the node and path
     * @param {Class} base_class class containing the structure of a node
     */
    registerNodeType(type, base_class) {
        if (!base_class.prototype) {
            throw new Error("Cannot register a simple object, it must be a class with a prototype");
        }
        base_class.type = type;

        this.log_debug("registerNodeType","start",type);

        const classname = base_class.name;

        const pos = type.lastIndexOf("/");
        base_class.category = type.substring(0, pos);

        if (!base_class.title) {
            base_class.title = classname;
        }

        const propertyDescriptors = Object.getOwnPropertyDescriptors(LGraphNode.prototype);

        // WIP BAD
        // extend constructor instead of copy properties :: WANTED to have originalconstructor too
        // using manual constructor (?)
        // if(base_class.prototype.hasOwnProperty("constructor")){
        //     var base_constructor = base_class.prototype.constructor;
        //     function extendedConstructor(that){
        //         LGraphNode.prototype.constructor.bind(that);
        //         base_constructor.bind(that);
        //     }
        //     base_class.prototype.constructor = extendedConstructor(this);
        //     base_class.constructor = extendedConstructor(this);
        // }

        // Iterate over each property descriptor
        Object.keys(propertyDescriptors).forEach((propertyName) => {
            // Check if the property already exists on the target prototype
            if (!base_class.prototype.hasOwnProperty(propertyName)) {
                // If the property doesn't exist, copy it from the source to the target
                Object.defineProperty(base_class.prototype, propertyName, propertyDescriptors[propertyName]);
                // TOO MUCH VERBOSE :: this.log_verbose("registerNodeType","defineProperty",type,base_class.prototype, propertyName, propertyDescriptors[propertyName]);
            }
        });

        const prev = this.registered_node_types[type];
        if(prev) {
            this.log_debug("registerNodeType","replacing node type",type,prev);
        }
        if( !Object.prototype.hasOwnProperty.call( base_class.prototype, "shape") ) {
            Object.defineProperty(base_class.prototype, "shape", {
                set: function(v) {
                    switch (v) {
                        case "default":
                            delete this._shape;
                            break;
                        case "box":
                            this._shape = LiteGraph.BOX_SHAPE;
                            break;
                        case "round":
                            this._shape = LiteGraph.ROUND_SHAPE;
                            break;
                        case "circle":
                            this._shape = LiteGraph.CIRCLE_SHAPE;
                            break;
                        case "card":
                            this._shape = LiteGraph.CARD_SHAPE;
                            break;
                        default:
                            this._shape = v;
                    }
                },
                get: function() {
                    return this._shape;
                },
                enumerable: true,
                configurable: true,
            });


            // used to know which nodes to create when dragging files to the canvas
            if (base_class.supported_extensions) {
                for (let i in base_class.supported_extensions) {
                    const ext = base_class.supported_extensions[i];
                    if(ext && ext.constructor === String) {
                        this.node_types_by_file_extension[ext.toLowerCase()] = base_class;
                    }
                }
            }
        }

        this.registered_node_types[type] = base_class;
        if (base_class.constructor.name) {
            this.Nodes[classname] = base_class;
        }

        this.processCallbackHandlers("onNodeTypeRegistered",{
            def_cb: this.onNodeTypeRegistered
        }, type, base_class);

        if (prev) {
            this.processCallbackHandlers("onNodeTypeReplaced",{
                def_cb: this.onNodeTypeReplaced
            }, type, base_class, prev);
        }

        // warnings
        if (base_class.prototype.onPropertyChange) {
            LiteGraph.log_warn("LiteGraph node class " +
                    type +
                    " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
        }

        // used to know which nodes create when dragging files to the canvas
        if (base_class.supported_extensions) {
            for (var i=0; i < base_class.supported_extensions.length; i++) {
                var ext = base_class.supported_extensions[i];
                if(ext && ext.constructor === String)
                    this.node_types_by_file_extension[ext.toLowerCase()] = base_class;
            }
        }

        this.log_debug("registerNodeType","type registered",type);

        if (this.auto_load_slot_types){
            // auto_load_slot_types should be used when not specifing slot type to LiteGraph
            // good for testing: this will create a temporary node for each type
            this.log_debug("registerNodeType","auto_load_slot_types, create empy tmp node",type);
            let tmpnode = new base_class(base_class.title ?? "tmpnode");
            tmpnode.post_constructor(); // could not call, but eventually checking for errors in the chain ?
        }
    }

    /**
     * removes a node type from the system
     * @method unregisterNodeType
     * @param {String|Object} type name of the node or the node constructor itself
     */
    unregisterNodeType(type) {
        const base_class =
            type.constructor === String
                ? this.registered_node_types[type]
                : type;
        if (!base_class) {
            throw new Error("node type not found to unregister: " + type);
        }
        delete this.registered_node_types[base_class.type];
        if (base_class.constructor.name) {
            delete this.Nodes[base_class.constructor.name];
        }
    }

    /**
    * Save a slot type and his node
    * @method registerSlotType
    * @param {String|Object} type name of the node or the node constructor itself
    * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
    */
    registerNodeAndSlotType(type, slot_type, out = false) {
        const base_class =
            type.constructor === String &&
            this.registered_node_types[type] !== "anonymous"
                ? this.registered_node_types[type]
                : type;

        const class_type = base_class.constructor.type;

        let allTypes = [];
        if (typeof slot_type === "string") {
            allTypes = slot_type.split(",");
        } else if (slot_type == this.EVENT || slot_type == this.ACTION) {
            allTypes = ["_event_"];
        } else {
            allTypes = ["*"];
        }

        for (let i = 0; i < allTypes.length; ++i) {
            let slotType = allTypes[i];
            if (slotType === "") {
                slotType = "*";
            }
            const registerTo = out
                ? "registered_slot_out_types"
                : "registered_slot_in_types";
            if (this[registerTo][slotType] === undefined) {
                this[registerTo][slotType] = { nodes: [] };
            }
            if (!this[registerTo][slotType].nodes.includes(class_type)) {
                this[registerTo][slotType].nodes.push(class_type);
            }

            // check if is a new type
            if (!out) {
                if (!this.slot_types_in.includes(slotType.toLowerCase())) {
                    this.slot_types_in.push(slotType.toLowerCase());
                    this.slot_types_in.sort();
                }
            } else {
                if (!this.slot_types_out.includes(slotType.toLowerCase())) {
                    this.slot_types_out.push(slotType.toLowerCase());
                    this.slot_types_out.sort();
                }
            }
        }
    }

    /**
     * Create a new nodetype by passing an object with some properties
     * like onCreate, inputs:Array, outputs:Array, properties, onExecute
     * @method buildNodeClassFromObject
     * @param {String} name node name with namespace (p.e.: 'math/sum')
     * @param {Object} object methods expected onCreate, inputs, outputs, properties, onExecute
     */
    buildNodeClassFromObject(
        name,
        object,
    ) {
        var ctor_code = "";
        if(object.inputs)
            for(let i=0; i < object.inputs.length; ++i) {
                let _name = object.inputs[i][0];
                let _type = object.inputs[i][1];
                if(_type && _type.constructor === String)
                    _type = '"'+_type+'"';
                ctor_code += "this.addInput('"+_name+"',"+_type+");\n";
            }
        if(object.outputs)
            for(let i=0; i < object.outputs.length; ++i) {
                let _name = object.outputs[i][0];
                let _type = object.outputs[i][1];
                if(_type && _type.constructor === String)
                    _type = '"'+_type+'"';
                ctor_code += "this.addOutput('"+_name+"',"+_type+");\n";
            }
        if(object.properties)
            for(let i in object.properties) {
                let prop = object.properties[i];
                if(prop && prop.constructor === String)
                    prop = '"'+prop+'"';
                ctor_code += "this.addProperty('"+i+"',"+prop+");\n";
            }
        ctor_code += "if(this.onCreate)this.onCreate()";
        var classobj = Function(ctor_code);
        for(let i in object)
            if(i!="inputs" && i!="outputs" && i!="properties")
                classobj.prototype[i] = object[i];
        classobj.title = object.title || name.split("/").pop();
        classobj.desc = object.desc || "Generated from object";
        this.registerNodeType(name, classobj);
        return classobj;
    }

    /**
     * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
     * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
     * @method wrapFunctionAsNode
     * @param {String} name node name with namespace (p.e.: 'math/sum')
     * @param {Function} func
     * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
     * @param {String} return_type [optional] string with the return type, otherwise it will be generic
     * @param {Object} properties [optional] properties to be configurable
     */
    wrapFunctionAsNode(name, func, param_types, return_type, properties) {
        const names = LiteGraph.getParameterNames(func);

        const code = names.map((name, i) => {
            const paramType = param_types?.[i] ? `'${param_types[i]}'` : "0";
            return `this.addInput('${name}', ${paramType});`;
        }).join("\n");

        const returnTypeStr = return_type ? `'${return_type}'` : 0;
        const propertiesStr = properties ? `this.properties = ${JSON.stringify(properties)};` : "";

        const classObj = new Function(`
            ${code}
            this.addOutput('out', ${returnTypeStr});
            ${propertiesStr}
        `);

        classObj.title = name.split("/").pop();
        classObj.desc = `Generated from ${func.name}`;

        classObj.prototype.onExecute = function() {
            const params = names.map((name, i) => this.getInputData(i));
            const result = func.apply(this, params);
            this.setOutputData(0, result);
        };
        // TODO: should probably set onConfigure or INIT too the value set ??

        this.registerNodeType(name, classObj);

        return classObj;
    }


    /**
     * Removes all previously registered node's types
     */
    clearRegisteredTypes() {
        this.registered_node_types = {};
        this.node_types_by_file_extension = {};
        this.Nodes = {};
        this.searchbox_extras = {};
    }

    /**
     * Adds this method to all nodetypes, existing and to be created
     * (You can add it to LGraphNode.prototype but then existing node types wont have it)
     * @method addNodeMethod
     * @param {Function} func
     */
    addNodeMethod(name, func) {
        LGraphNode.prototype[name] = func;
        for (var i in this.registered_node_types) {
            var type = this.registered_node_types[i];
            if (type.prototype[name]) {
                type.prototype["_" + name] = type.prototype[name];
            } // keep old in case of replacing
            type.prototype[name] = func;
        }
    }

    /**
     * Create a node of a given type with a name. The node is not attached to any graph yet.
     * @method createNode
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @param {String} name a name to distinguish from other nodes
     * @param {Object} options to set options
     */

    createNode(type, title, options = {}) {
        const base_class = this.registered_node_types[type] ?? null;

        if (!base_class) {
            this.log_debug(`GraphNode type "${type}" not registered.`);
            return null;
        }

        LiteGraph.log_verbose("createNode",type,title,options,base_class);

        title = title ?? base_class.title ?? type;

        let node = null;

        if (LiteGraph.catch_exceptions) {
            try {
                node = new base_class(title);
            } catch (err) {
                this.log_error("createNode",err);
                return null;
            }
        } else {
            node = new base_class(title);
        }

        // extend constructor with the extended always executed (custom class or lgraphnode)
        node.post_constructor();
        
        // basic size, before computing
        node.size_basic = node.size;

        node.type = type;
        node.title ??= title;
        node.properties ??= {};
        node.properties_info ??= [];
        node.flags ??= {};
        node.size ??= node.computeSize();
        node.pos ??= LiteGraph.DEFAULT_POSITION.concat();
        node.mode ??= LiteGraph.ALWAYS;


        // extra options
        Object.assign(node, options);

        LiteGraph.log_verbose("createNode","created",node,node.processCallbackHandlers);

        // callback node event entrypoint
        node.processCallbackHandlers("onNodeCreated",{
            def_cb: node.onNodeCreated
        });
        return node;
    }


    /**
     * Returns a registered node type with a given name
     * @method getNodeType
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @return {Class} the node class
     */
    getNodeType(type) {
        return this.registered_node_types[type];
    }

    /**
     * Returns a list of node types matching one category
     * @method getNodeType
     * @param {String} category category name
     * @return {Array} array with all the node classes
     */

    getNodeTypesInCategory(category, filter) {
        const filteredTypes = Object.values(this.registered_node_types).filter((type) => {
            if (type.filter !== filter) {
                return false;
            }

            if (category === "") {
                return type.category === null;
            } else {
                return type.category === category;
            }
        });

        if (this.auto_sort_node_types) {
            filteredTypes.sort((a, b) => a.title.localeCompare(b.title));
        }

        return filteredTypes;
    }


    /**
     * Returns a list with all the node type categories
     * @method getNodeTypesCategories
     * @param {String} filter only nodes with ctor.filter equal can be shown
     * @return {Array} array with all the names of the categories
     */
    getNodeTypesCategories(filter) {
        const categories = { "": 1 };

        Object.values(this.registered_node_types).forEach((type) => {
            if (type.category && !type.skip_list && type.filter === filter) {
                categories[type.category] = 1;
            }
        });

        const result = Object.keys(categories);

        return this.auto_sort_node_types ? result.sort() : result;
    }


    // debug purposes: reloads all the js scripts that matches a wildcard
    reloadNodes(folder_wildcard) {
        var tmp = document.getElementsByTagName("script");
        // weird, this array changes by its own, so we use a copy
        var script_files = [];
        for (let i=0; i < tmp.length; i++) {
            script_files.push(tmp[i]);
        }

        var docHeadObj = document.getElementsByTagName("head")[0];
        folder_wildcard = document.location.href + folder_wildcard;

        for (let i=0; i < script_files.length; i++) {
            var src = script_files[i].src;
            if (
                !src ||
                src.substr(0, folder_wildcard.length) != folder_wildcard
            ) {
                continue;
            }

            try {
                this.log_debug("Reloading: " + src);
                var dynamicScript = document.createElement("script");
                dynamicScript.type = "text/javascript";
                dynamicScript.src = src;
                docHeadObj.appendChild(dynamicScript);
                docHeadObj.removeChild(script_files[i]);
            } catch (err) {
                if (LiteGraph.throw_errors) {
                    throw err;
                }
                this.log_debug("Error while reloading " + src);
            }
        }
        this.log_debug("Nodes reloaded");
    }

    /**
     * This is a cleaner helper to .configure methods that rely on json import
     * Happens that arrays are sometimes (strangely) exported as object with keyed strings: eg. [v0, v1] to {"0": v0, "1": v1}
     * This method successfully convert those to back to accessible by key numbers {0: v0, 1:v1} - note this is an object not an array as eventually was in origin
     * This eg. happens with groups ._bounding and nodes .position, but could happen anywere, advised implementation of parseStringifyObject to sanitize
     * @param {object} obj the object to parse clean
     * @returns the cleaned object
     */
    parseStringifyObject(obj, target) {
        // method 1: not working
        // return JSON.parse(JSON.stringify(obj));

        // method 2: working
        // for (const key in obj) {
        //     if (Object.prototype.hasOwnProperty.call(obj, key)) {
        //         target[key] = obj[key];
        //     }
        // }
        // return target;

        // just use cloneObject, original solution
        return this.cloneObject(obj, target);
    }

    cloneObject(obj, target) {
        if (obj == null) {
            return null;
        }
        const clonedObj = JSON.parse(JSON.stringify(obj));
        if (!target) {
            return clonedObj;
        }
        for (const key in clonedObj) {
            if (Object.prototype.hasOwnProperty.call(clonedObj, key)) {
                target[key] = clonedObj[key];
            }
        }
        return target;
    }


    /*
    * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670
    */
    uuidv4() {
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(a) => (a^Math.random()*16>>a/4).toString(16));
    }

    /**
     * Returns if the types of two slots are compatible (taking into account wildcards, etc)
     * @method isValidConnection
     * @param {String} type_a
     * @param {String} type_b
     * @return {Boolean} true if they can be connected
     */
    isValidConnection(type_a, type_b) {
        if (type_a === "" || type_a === "*") type_a = 0;
        if (type_b === "" || type_b === "*") type_b = 0;

        if (!type_a || !type_b || type_a === type_b || (type_a === LiteGraph.EVENT && type_b === LiteGraph.ACTION)) {
            return true;
        }

        type_a = String(type_a).toLowerCase();
        type_b = String(type_b).toLowerCase();

        if (!type_a.includes(",") && !type_b.includes(",")) {
            return type_a === type_b;
        }

        const supported_types_a = type_a.split(",");
        const supported_types_b = type_b.split(",");

        for (const supported_type_a of supported_types_a) {
            for (const supported_type_b of supported_types_b) {
                if (this.isValidConnection(supported_type_a, supported_type_b)) {
                    return true;
                }
            }
        }

        return false;
    }


    /**
     * Register a string in the search box so when the user types it it will recommend this node
     * @method registerSearchboxExtra
     * @param {String} node_type the node recommended
     * @param {String} description text to show next to it
     * @param {Object} data it could contain info of how the node should be configured
     * @return {Boolean} true if they can be connected
     */
    registerSearchboxExtra(node_type, description, data) {
        this.searchbox_extras[description.toLowerCase()] = {
            type: node_type,
            desc: description,
            // title: node_type.title, TODO implement searching by title, desc, and extra pars
            data: data,
        };
    }

    /**
     * Wrapper to load files (from url using fetch or from file using FileReader)
     * @method fetchFile
     * @param {String|File|Blob} url the url of the file (or the file itself)
     * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
     * @param {Function} on_complete callback(data)
     * @param {Function} on_error in case of an error
     * @return {FileReader|Promise} returns the object used to
     */
    fetchFile( url, type, on_complete, on_error ) {
        if(!url)
            return null;

        type = type || "text";
        if( url.constructor === String ) {
            if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
                url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
            }
            return fetch(url)
                .then((response) => {
                    if(!response.ok)
                        throw new Error("File not found"); // it will be catch below
                    if(type == "arraybuffer")
                        return response.arrayBuffer();
                    else if(type == "text" || type == "string")
                        return response.text();
                    else if(type == "json")
                        return response.json();
                    else if(type == "blob")
                        return response.blob();
                })
                .then((data) => {
                    if(on_complete)
                        on_complete(data);
                })
                .catch((error) => {
                    this.log_error("error fetching file:",url);
                    if(on_error)
                        on_error(error);
                });
        } else if( url.constructor === File || url.constructor === Blob) {
            var reader = new FileReader();
            reader.onload = (e) => {
                var v = e.target.result;
                if( type == "json" )
                    v = JSON.parse(v);
                if(on_complete)
                    on_complete(v);
            }
            if(type == "arraybuffer")
                return reader.readAsArrayBuffer(url);
            else if(type == "text" || type == "json")
                return reader.readAsText(url);
            else if(type == "blob")
                return reader.readAsBinaryString(url);
        }
        return null;
    }

    // @TODO These weren't even directly bound, so could be used as free functions
    compareObjects(a, b) {
        const aKeys = Object.keys(a);

        if (aKeys.length !== Object.keys(b).length) {
            return false;
        }

        return aKeys.every((key) => a[key] === b[key]);
    }

    distance(a, b) {
        const [xA, yA] = a;
        const [xB, yB] = b;

        return Math.sqrt((xB - xA) ** 2 + (yB - yA) ** 2);
    }

    colorToString(c) {
        return (
            "rgba(" +
            Math.round(c[0] * 255).toFixed() +
            "," +
            Math.round(c[1] * 255).toFixed() +
            "," +
            Math.round(c[2] * 255).toFixed() +
            "," +
            (c.length == 4 ? c[3].toFixed(2) : "1.0") +
            ")"
        );
    }

    textCalculateMaxWidth(text){
        // TODO RESTART FROM HERE
        // const retCalc = this.canvasFillTextMultiline();
        // USING ctx.measureText directly
    }

    /**
     * helper function to write text to a canvas calculating multiline and returning info on final sizes 
     * @param {*} context 
     * @param {*} text 
     * @param {*} x 
     * @param {*} y 
     * @param {*} maxWidth 
     * @param {*} lineHeight 
     * @returns 
     */
    canvasFillTextMultiline(context, text, x, y, maxWidth, lineHeight) {
        var words = (text+"").trim().split(' ');
        var line = '';
        var ret = {lines: [], maxW: 0, height: 0};
        if (words.length>1) {
            for(var n = 0; n < words.length; n++) {
                var testLine = line + words[n] + ' ';
                var metrics = context.measureText(testLine);
                var testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    context.fillText(line, x, y+(lineHeight*ret.lines.length));
                    line = words[n] + ' ';
                    // y += lineHeight;
                    ret.max = testWidth;
                    ret.lines.push(line);
                }else{
                    line = testLine;
                }
            }
        } else {
            line = words[0];
        }
        context.fillText(line, x, y+(lineHeight*ret.lines.length));
        ret.lines.push(line);
        ret.height = lineHeight*ret.lines.length || lineHeight;
        return ret;
    }

    isInsideRectangle(x, y, left, top, width, height) {
        return x > left && x < left + width && y > top && y < top + height;
    }

    isBoundingInsideRectangle(bounding, left, top, width, height) {
        let x = bounding[0];
        let y = bounding[1];
        if(!(x > left && x < left + width && y > top && y < top + height))
            return false;
        x = bounding[0] + bounding[2];
        y = bounding[1] + bounding[3];
        if(!(x > left && x < left + width && y > top && y < top + height))
            return false;
        return true;
    }

    // [minx,miny,maxx,maxy]
    growBounding(bounding, x, y) {
        if (x < bounding[0]) {
            bounding[0] = x;
        } else if (x > bounding[2]) {
            bounding[2] = x;
        }

        if (y < bounding[1]) {
            bounding[1] = y;
        } else if (y > bounding[3]) {
            bounding[3] = y;
        }
    }

    // point inside bounding box
    isInsideBounding(p, bb) {
        return p[0] >= bb[0][0] && p[1] >= bb[0][1] && p[0] <= bb[1][0] && p[1] <= bb[1][1];
    }

    // bounding overlap, format: [ startx, starty, width, height ]
    overlapBounding(a, b, add) {
        add = add || 0;
        const A_end_x = a[0] + a[2] + add;
        const A_end_y = a[1] + a[3] + add;
        const B_end_x = b[0] + b[2] + add;
        const B_end_y = b[1] + b[3] + add;

        return !(a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]);
    }

    // Convert a hex value to its decimal value - the inputted hex must be in the
    //	format of a hex triplet - the kind we use for HTML colours. The function
    //	will return an array with three values.
    hex2num(hex) {
        if (hex.charAt(0) == "#") {
            hex = hex.slice(1);
        } // Remove the '#' char - if there is one.
        hex = hex.toUpperCase();
        var hex_alphabets = "0123456789ABCDEF";
        var value = new Array(3);
        var k = 0;
        var int1, int2;
        for (var i = 0; i < 6; i += 2) {
            int1 = hex_alphabets.indexOf(hex.charAt(i));
            int2 = hex_alphabets.indexOf(hex.charAt(i + 1));
            value[k] = int1 * 16 + int2;
            k++;
        }
        return value;
    }

    // Give a array with three values as the argument and the function will return
    //	the corresponding hex triplet.
    num2hex(triplet) {
        var hex_alphabets = "0123456789ABCDEF";
        var hex = "#";
        var int1, int2;
        for (var i = 0; i < 3; i++) {
            int1 = triplet[i] / 16;
            int2 = triplet[i] % 16;

            hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
        }
        return hex;
    }

    extendClass = (target, origin) => {
        for (let i in origin) {
            // copy class properties
            if (target.hasOwnProperty(i)) {
                continue;
            }
            target[i] = origin[i];
        }

        if (origin.prototype) {
            // copy prototype properties
            for (let i in origin.prototype) {
                // only enumerable
                if (!origin.prototype.hasOwnProperty(i)) {
                    continue;
                }

                if (target.prototype.hasOwnProperty(i)) {
                    // avoid overwriting existing ones
                    continue;
                }

                // copy getters
                if (origin.prototype.__lookupGetter__(i)) {
                    target.prototype.__defineGetter__(
                        i,
                        origin.prototype.__lookupGetter__(i),
                    );
                } else {
                    target.prototype[i] = origin.prototype[i];
                }

                // and setters
                if (origin.prototype.__lookupSetter__(i)) {
                    target.prototype.__defineSetter__(
                        i,
                        origin.prototype.__lookupSetter__(i),
                    );
                }
            }
        }
    }

    // used to create nodes from wrapping functions
    getParameterNames = function(func) {
        return (func + "")
            .replace(/[/][/].*$/gm, "") // strip single-line comments
            .replace(/\s+/g, "") // strip white space
            .replace(/[/][*][^/*]*[*][/]/g, "") // strip multi-line comments  /**/
            .split("){", 1)[0]
            .replace(/^[^(]*[(]/, "") // extract the parameters
            .replace(/=[^,]+/g, "") // strip any ES6 defaults
            .split(",")
            .filter(Boolean); // split & filter [""]
    };

    clamp = (v, a, b) => {
        return a > v ? a : b < v ? b : v;
    };

    // @BUG checking
    /* pointerAddListener = () => {
        console.error?.("Removed and being re-integrated sorta");
    };
    pointerRemoveListener = () => {
        console.error?.("Removed and being re-integrated sorta");
    };
    set pointerevents_method(v) {
        console.error?.("Removed and being re-integrated sorta");
    }
    get pointerevents_method() {
        console.error?.("Removed and being re-integrated sorta");
    } */

    closeAllContextMenus = () => {
        LiteGraph.log_verbose('LiteGraph.closeAllContextMenus is deprecated in favor of ContextMenu.closeAll()');
        ContextMenu.closeAll();
    };

    getTime(){
        if (typeof performance != "undefined") {
            return performance.now(); //.bind(performance);
        } else if (typeof Date != "undefined" && Date.now) {
            Date.now();
        } else if (typeof process != "undefined") {
            const t = process.hrtime();
            return t[0] * 0.001 + t[1] * 1e-6;
        } else {
            return new Date().getTime();
        }
    }

    /**
     * 
     * @param {number} n number to be formatted
     * @param {*} precision decimal positions
     * @returns formatted number to precision witouth trailing zeros
     */ 
    formatNumber(n, precision = 3){
        n = Number(n);
        if(n === NaN){
            return "";
        }else{
            return n.toFixed(precision).replace(/(\.\d*[1-9])0+$|\.0*$/, '$1');
        }
    }
}

// !¿ TODO MOVE THESE HELPERS ?!
// timer that works everywhere
// if (typeof performance != "undefined") {
//     LiteGraphClass.getTime = performance.now.bind(performance);
// } else if (typeof Date != "undefined" && Date.now) {
//     LiteGraphClass.getTime = Date.now.bind(Date);
// } else if (typeof process != "undefined") {
//     LiteGraphClass.getTime = () => {
//         var t = process.hrtime();
//         return t[0] * 0.001 + t[1] * 1e-6;
//     };
// } else {
//     LiteGraphClass.getTime = function getTime() {
//         return new Date().getTime();
//     };
// }

// @BROWSERONLY
if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
    window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        ((callback) => {
            window.setTimeout(callback, 1000 / 60);
        });
}

export const root = getGlobalObject();
if(!getGlobalVariable("LiteGraph")){
    setGlobalVariable("LiteGraph", new LiteGraphClass());
    let LGInst = getGlobalVariable("LiteGraph");
    LGInst.log_info("LiteGraph instantiated",LGInst.getTime());
}
export var LiteGraph = getGlobalVariable("LiteGraph");

/**
 * WIP
 * intended to replace direct (single) assignment of callbacks [ event entrypoint ]
 */
export class CallbackHandler {

    debug = false;

    constructor(ref){
        this.callbacks_handlers = {};
        this.ob_ref = ref;
        if(this.debug&&LiteGraph!==undefined) LiteGraph.log_debug("CallbackHandler Initialize callbacks",ref);
    }

    /**
     * subscribe callbacks for events
     * @method registerCallbackHandler
     * @param {string} name event name to register to
     * @param {function} callback function to call when processing the event name
     * @param {object} opts options for registerCallBackHandler
     * @param {number} opts.priority default handler as 0, lesser value executes after, greater value will be execute before but their value eventually overridden in case if not stopping the chain
     * @param {boolean} opts.is_default original library handlers would have true, while custom registered has choice to be eventually treathed as such
     * @returns {number} the id of the handler for the specified name
     */
    registerCallbackHandler = function(name, callback, opts){
        if(!opts || typeof(opts)!=="object") opts = {};
        const def_opts = {priority: 0, is_default: false, call_once: false};
        opts = Object.assign(def_opts, opts);
        
        if(typeof(callback)!=="function"){
            if(this.debug&&LiteGraph!==undefined) LiteGraph.log_error("registerCallbackHandler","Invalid callback");
            return false;
        }

        if(typeof(this.callbacks_handlers[name]) === "undefined"){
            this.callbacks_handlers[name] = {last_id: 0, handlers:[]};
        }
        const h_id = this.callbacks_handlers[name].last_id++;

        if(this.debug&&LiteGraph!==undefined) LiteGraph.log_debug("registerCallbackHandler","new callback handler",name,h_id);

        this.callbacks_handlers[name].handlers.push({
            id: h_id,
            priority: opts.priority,
            callback: callback,
            data: opts, // enqueue passed options, can store info in here
        });

        // sort descending
        this.callbacks_handlers[name].handlers.sort((a, b) => b.priority - a.priority);

        // if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("registerCallbackHandler","sorted",this.callbacks_handlers[name]);

        return h_id; // return the cbhandle id
    };
    /**
     * 
     * @param {string} name event name to unregister from
     * @param {number} h_id the handler pointer, need to be saved when registering the callback
     * @returns {boolean} true if found
     */
    unregisterCallbackHandler(name, h_id){
        // if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("unregisterCallbackHandler","Checking in handlers",this.callbacks_handlers,name,h_id);
        if(typeof(this.callbacks_handlers[name]) !== "undefined"){
            const nHandlers = this.callbacks_handlers[name].handlers.length;
            this.callbacks_handlers[name].handlers = this.callbacks_handlers[name].handlers.filter(function( obj ) {
                // if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("unregisterCallbackHandler","Checking handle",obj.id,h_id);
                if(obj.id === h_id){
                    LiteGraph.log_info("unregisterCallbackHandler",name,h_id);
                }
                return obj.id !== h_id;
            });
            if(this.callbacks_handlers[name].handlers.length < nHandlers){
                return true;
            }
        }
        LiteGraph.log_warn("unregisterCallbackHandler","no handlers for",name,h_id);
        return false;
    }

    /**
     * Executes the callbacks and cache their result
     * execution if from higher priority down
     * handler data is passed as first argument, than all the additional pars passed to this
     * @param {string} name the event name for which execute the callbacks registered to
     * @param {object} opts specify the option here
     * @param {object} opts.def_cb can specify a callback here to be treated as default callback, executed after the >= 0, eventually prevented
     * @returns {null|boolean|object} get back default result, and along the chain
     */
    processCallbackHandlers(name,opts/*, .. arguments */){
        if(!opts || typeof(opts)!=="object") opts = {};
        const def_opts = {
            // WIP :: think try and implement options
            // process: "all", return: "first_result", skip_null_return: true, append_last_return: false
            // min_piority: false, max_priority: false
            def_cb: false // the [default] callback : in LG this is the previous(current) function called when an event is executed, can be undefined or null
        };
        opts = Object.assign(def_opts, opts);
        var cbHandle = this;

        if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("**processCallbackHandlers**",...arguments);

        // ensure callback name is present on this
        if(typeof(this.callbacks_handlers[name]) == "undefined"){
            this.callbacks_handlers[name] = {last_id: 0, handlers:[]};
        }
        
        var aArgs = ([].slice.call(arguments)).slice(2);
        // if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("Cleaned arguments (slice 2)",aArgs,"original",arguments);

        // previous implementation of converting arguments
        // using shorter ([].slice.call(arguments)).slice(2)
        // can clean when checked works fine
        // function clean_args(args) {
        //     let aRet = [];
        //     for(let iA=2; iA<args.length; iA++) {
        //         // if(typeof(args[iA])!=="undefined")
        //         aRet.push(args[iA]);
        //     }
        //     return aRet;
        // }
        // var aArgs = clean_args(arguments);

        var stepRet = null;         // temp step specific result 
        var cbRet = null;           // progressive final result
        var aResChain = [];         // progressive results chain
        var oCbInfo = {};           // info passed to the callback
        var cbResPriority = 0;      // incremental result priority
        var defCbChecked = false;   // flag activated when executed the [default] callback
        var preventDefCb = false;   // if to prevent the [default] callback execution (set eventually by some callback result)
        var breakCycle = false;     // if to stop callback execution (set eventually by some callback result)

        var executeDefaultCb = function(){
            if(!preventDefCb && typeof(opts.def_cb)=="function"){
                // execute default callback
                if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("Calling DEFAULT w Args",...aArgs);
                // stepRet = opts.def_cb(...aArgs); // OLD, not working because of bas THIS 
                // call method on ref object (LiteGraph, LGraphNode, LGraphCanvas, ...) in othe method `this` will than correctly set
                stepRet = opts.def_cb.call(cbHandle.ob_ref, ...aArgs); // could pass more data
                if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","default callback executed",stepRet);
                checkStepRet();
            }else{
                if(typeof(opts.def_cb)=="function"){
                    if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","preventing default passed",opts.def_cb);
                }else{
                    // not passed
                }
            }
            defCbChecked = true;
        }
        // results should be structured a object (to try to return a final value or change chain execution behavior)
        /**
         * @prop {*} return_value assign the return ( could be overriden )
         * @prop {number} result_priority assign proper values to allow handlers with higher priority to have not their return_value overridden 
         * @prop {boolean} prevent_default stop default execution ( force only when really needed )
         * @prop {boolean} stop_replication stop the execution chain
         */
        var buildRetObj = function(){
            // TODO: implement object return construction :: THAN replace all result checking in the libs to easier object ensured checks
        }
        /**
         * called for each callback to push and merge results
         * void
         */
        var checkStepRet = function(){
            aResChain.push(stepRet); // cache result
            // check result for structured object
            if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","stepRet check",stepRet);
            if(typeof(stepRet)=="object"){
                if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","result is object",stepRet);
                if(typeof(stepRet.prevent_default)!=="undefined" && stepRet.prevent_default){
                    preventDefCb = true;
                }
                if(typeof(stepRet.return_value)!=="undefined"){
                    if( !cbResPriority
                        || (typeof(stepRet.result_priority)!=="undefined" && cbResPriority <= stepRet.result_priority)
                        || (typeof(stepRet.result_priority)==="undefined" && (!cbResPriority || cbResPriority <= 0))
                    ){
                        if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","set result from object",stepRet,oCbInfo);
                        cbRet = stepRet;
                    }
                }else{
                    if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","set result, not object",stepRet,oCbInfo);
                    cbRet = stepRet;
                }
                if(typeof(stepRet.stop_replication)!=="undefined" && stepRet.stop_replication){
                    if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","stop_replication",oCbInfo);
                    breakCycle = true;
                    return; // will break;
                }
            }else{
                if(cbHandle.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","checkStepRet","result NOT object",stepRet);
                // ? save current result if not null or undefined (?)
                if(stepRet !== null && stepRet !== undefined){
                    cbRet = stepRet; // TODO maybe to remove, leave for current stability
                }
            }
        }
        for(let cbhX of this.callbacks_handlers[name].handlers){

            // eventually prevent cb marked as default
            if(preventDefCb && cbhX.is_default){
                if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("processCallbackHandlers","preventing default registered",cbhX);
                continue;
            }
            
            // execute default if already processed the ones >= 0
            if(cbhX.priority<0 && !defCbChecked){
                if(this.debug&&LiteGraph!==undefined) LiteGraph.log_verbose("processCallbackHandlers","process default passed","nextCb:",cbhX);
                executeDefaultCb();
                if(breakCycle) break;
            }

            oCbInfo = {
                name: name // name of the handler
                ,id: cbhX.id // id of the handler for the name
                ,current_return_value: cbRet // current temporary value (if >= second call and previous return a value) 
                ,data: cbhX.data // pass the priority and the additional data passed
                ,results_chain: aResChain
                // opts: def_opts
            };

            // execute callback
            // OLD, not working because of bas THIS : stepRet = cbhX.callback(oCbInfo,...aArgs);
            // call method on ref object (LiteGraph, LGraphNode, LGraphCanvas, ...) in the method `this` will than correctly set
            stepRet = cbhX.callback.call(this.ob_ref, oCbInfo, ...aArgs);

            if(this.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","callback executed",stepRet,oCbInfo);
            
            // push result
            checkStepRet();
            if(this.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","result checked","cbRet", cbRet,"aResChain", aResChain,"cbResPriority", cbResPriority,"defCbChecked", defCbChecked,"preventDefCb", preventDefCb,"breakCycle", breakCycle);
            if(breakCycle) break;

            if(cbhX.data.call_once){
                this.unregisterCallbackHandler(name, cbhX.id);
                if(this.debug&&LiteGraph!==undefined) LiteGraph.log_debug("processCallbackHandlers","unregistered call_once",oCbInfo);
            }

        } // end cycle
    
        // recheck for default cb passed after cycling
        if(!defCbChecked){
            executeDefaultCb();
        }

        // if(cbRet===null){
        //     // return default true if no callbacks specified a return value
        //     // [ some original LG callback execution checks for boolean return ]
        //     cbRet = true;
        // }
        return cbRet;

        // could return obj instead and there check for values, etc ..
        // TODO would be probably better to always return an object to than check for result and make easier code in implementation
    }
}

export class ContextMenu {

    /**
    * @constructor
    * @param {Array<Object>} values (allows object { title: "Nice text", callback: function ... })
    * @param {Object} options [optional] Some options:\
    * - title: title to show on top of the menu
    * - callback: function to call when an option is clicked, it receives the item information
    * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback
    * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position
    * - isCustomEvent: added to allow not default events
    *
    *   Rendering notes: This is only relevant to rendered graphs, and is rendered using HTML+CSS+JS.
    */
    constructor(values, options = {}) {
        this.options = options;
        options.scroll_speed ??= 0.1;
        options.filter_enabled ??= true;
        this.menu_elements = [];

        this.#linkToParent();
        this.#validateEventClass();
        this.#createRoot();
        this.#bindEvents();
        this.setTitle(this.options.title);
        this.addItems(values);
        this.#insertMenu();
        this.#calculateBestPosition();
        if(LiteGraph.context_menu_filter_enabled && options.filter_enabled){
            this.createFilter(values, options);
        }
    }

    #createRoot() {
        const root = this.root = document.createElement("div");
        if (this.options.className) {
            root.className = this.options.className;
        }
        root.classList.add("litegraph","litecontextmenu","litemenubar-panel");
        root.style.minWidth = "80px";
        root.style.minHeight = "10px";
        return root;
    }

    #bindEvents() {
        const root = this.root;

        root.style.pointerEvents = "none";
        setTimeout(() => {
            root.style.pointerEvents = "auto";
        }, 100); // delay so the mouse up event is not caught by this element

        // this prevents the default context browser menu to open in case this menu was created when pressing right button
        root.addEventListener("pointerup", (e) => {
            // LiteGraph.log?.("pointerevents: ContextMenu up root prevent");
            e.preventDefault();
            return true;
        });
        root.addEventListener("contextmenu", (e) => {
            if (e.button != 2) {
                // right button
                return false;
            }
            e.preventDefault();
            return false;
        });
        root.addEventListener("pointerdown", (e) => {
            // LiteGraph.log?.("pointerevents: ContextMenu down");
            if (e.button == 2) {
                this.close();
                e.preventDefault();
                return true;
            }
        });
        root.addEventListener("wheel", (e) => {
            var pos = parseInt(root.style.top);
            root.style.top =
                (pos + e.deltaY * this.options.scroll_speed).toFixed() + "px";
            e.preventDefault();
            return true;
        });
        root.addEventListener("pointerenter", (_event) => {
            // LiteGraph.log?.("pointerevents: ContextMenu enter");
            if (root.closing_timer) {
                clearTimeout(root.closing_timer);
            }
        });
    }

    #linkToParent() {
        const parentMenu = this.options.parentMenu;
        if (!parentMenu)
            return;
        if (parentMenu.constructor !== this.constructor) {
            LiteGraph.log_error("contextmenu", "linkToParent", "parentMenu must be of class ContextMenu, ignoring it");
            this.options.parentMenu = null;
            return;
        }
        this.parentMenu = parentMenu;
        this.parentMenu.lock = true;
        this.parentMenu.current_submenu = this;
    }

    #validateEventClass() {
        if(!this.options.event)
            return;

        if(this.options.isCustomEvent){
            LiteGraph.log_verbose("contextmenu", "linkToParent", "Custom event for ContextMenu.", this.options.event);
            return;
        }

        // why should we ignore other events ?
        // use strings because comparing classes between windows doesnt work
        const eventClass = this.options.event.constructor.name;
        if ( eventClass !== "MouseEvent" &&
            eventClass !== "CustomEvent" &&
            eventClass !== "PointerEvent"
        ) {
            LiteGraph.log_warn(`Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Was originally ignoring it. (${eventClass})`);
            // this.options.event = null;
        }
    }

    createFilter(values, options){
        if(!values || !values.length || values.length == 1) return;

        const filter = document.createElement("input");
        filter.classList.add("context-menu-filter");
        filter.placeholder = "Filter list";
        this.root.prepend(filter);

        const items = Array.from(this.root.querySelectorAll(".litemenu-entry"));
        let displayedItems = [...items];
        let itemCount = displayedItems.length;

        console.info(options);

        // We must request an animation frame for the current node of the active canvas to update.
        requestAnimationFrame(() => {
            const currentNode = options.extra; //LGraphCanvas.active_canvas.current_node;
            const clickedComboValue = currentNode?.widgets
                ?.filter(w => w.type === "combo" && w.options.values.length === values.length)
                .find(w => w.options.values.every((v, i) => v === values[i]))
                ?.value;

            let selectedIndex = clickedComboValue ? values.findIndex(v => v === clickedComboValue) : 0;
            if (selectedIndex < 0) {
                selectedIndex = 0;
            } 
            let selectedItem = displayedItems[selectedIndex];
            updateSelected();

            // Apply highlighting to the selected item
            function updateSelected() {
                selectedItem?.style.setProperty("background-color", "");
                selectedItem?.style.setProperty("color", "");
                selectedItem = displayedItems[selectedIndex];
                selectedItem?.style.setProperty("background-color", "#ccc", "important");
                selectedItem?.style.setProperty("color", "#000", "important");
            }

            const positionList = () => {
                const rect = this.root.getBoundingClientRect();

                // If the top is off-screen then shift the element with scaling applied
                if (rect.top < 0) {
                    const scale = 1 - this.root.getBoundingClientRect().height / this.root.clientHeight;
                    const shift = (this.root.clientHeight * scale) / 2;
                    this.root.style.top = -shift + "px";
                }
            }

            // Arrow up/down to select items
            filter.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowUp":
                        event.preventDefault();
                        if (selectedIndex === 0) {
                            selectedIndex = itemCount - 1;
                        } else {
                            selectedIndex--;
                        }
                        updateSelected();
                        break;
                    case "ArrowRight":
                        /* event.preventDefault();
                        selectedIndex = itemCount - 1;
                        updateSelected(); */
                        selectedItem?.do_click(event); //click();
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        if (selectedIndex === itemCount - 1) {
                            selectedIndex = 0;
                        } else {
                            selectedIndex++;
                        }
                        updateSelected();
                        break;
                    case "ArrowLeft":
                        const parentMenu = this.parentMenu;
                        this.close(event, true);
                        if(parentMenu){
                            const parentFilter = Array.from(parentMenu.root.querySelectorAll(".context-menu-filter"));
                            if(parentFilter && parentFilter.length){
                                parentFilter[0].style.display = "block";
                                parentFilter[0].focus();
                            }
                        }
                        /* event.preventDefault();
                        selectedIndex = 0;
                        updateSelected(); */
                        break;
                    case "Enter":
                        selectedItem?.do_click(event); //click();
                        break;
                    case "Escape":
                        this.close();
                        break;
                }
            });

            filter.addEventListener("input", () => {
                // Hide all items that don't match our filter
                const term = filter.value.toLocaleLowerCase();
                // When filtering, recompute which items are visible for arrow up/down and maintain selection.
                displayedItems = items.filter(item => {
                    const isVisible = !term || item.textContent.toLocaleLowerCase().includes(term);
                    item.style.display = isVisible ? "block" : "none";
                    return isVisible;
                });

                selectedIndex = 0;
                if (displayedItems.includes(selectedItem)) {
                    selectedIndex = displayedItems.findIndex(d => d === selectedItem);
                }
                itemCount = displayedItems.length;

                updateSelected();

                // If we have an event then we can try and position the list under the source
                if (options.event) {
                    let top = options.event.clientY - 10;

                    const bodyRect = document.body.getBoundingClientRect();
                    const rootRect = this.root.getBoundingClientRect();
                    if (bodyRect.height && top > bodyRect.height - rootRect.height - 10) {
                        top = Math.max(0, bodyRect.height - rootRect.height - 10);
                    }

                    this.root.style.top = top + "px";
                    positionList();
                }
            });

            requestAnimationFrame(() => {
                // Focus the filter box when opening
                filter.focus();

                positionList();
            });
        })
    }
    
    /**
     * Creates a title element if it doesn't have one.
     * Sets the title of the menu.
     * @param {string} title - The title to be set.
     */
    setTitle(title) {
        if (!title)
            return;
        this.titleElement ??= document.createElement("div");
        const element = this.titleElement;
        element.className = "litemenu-title";
        element.innerHTML = title;
        if(!this.root.parentElement)
            this.root.appendChild(element);
    }

    /**
     * Adds a set of values to the menu.
     * @param {Array<string|object>} values - An array of values to be added.
     */
    addItems(values) {

        for (let i = 0; i < values.length; i++) {
            let name = values[i];

            if (typeof name !== 'string') {
                name = name && name.content !== undefined ? String(name.content) : String(name);
            }

            let value = values[i];
            
            // this.menu_elements.push(this.addItem(name, value, this.options));
            this.addItem(name, value, this.options);
        }
    }

    #insertMenu() {
        const doc = this.options.event?.target.ownerDocument ?? document;
        const parent = doc.fullscreenElement ?? doc.body;
        const root = this.root;
        const that = this;
        parent.appendChild(this.root);
    }

    #calculateBestPosition() {
        const options = this.options;
        const root = this.root;

        let left = options.left || 0;
        let top = options.top || 0;
        this.top_original = top;

        if (options.event) {
            left = options.event.clientX - 10;
            top = options.event.clientY - 10;

            if (options.title) {
                top -= 20;
            }
            this.top_original = top;

            if (options.parentMenu) {
                const rect = options.parentMenu.root.getBoundingClientRect();
                left = rect.left + rect.width;
            }

            const body_rect = document.body.getBoundingClientRect();
            const root_rect = root.getBoundingClientRect();
            if(body_rect.height === 0)
                LiteGraph.log_error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");

            if (body_rect.width && left > body_rect.width - root_rect.width - 10) {
                left = body_rect.width - root_rect.width - 10;
            }
            if (body_rect.height && top > body_rect.height - root_rect.height - 10) {
                top = body_rect.height - root_rect.height - 10;
            }
        }else{
            LiteGraph.log_debug("contextmenu", "calculateBestPosition", "has no event");
        }

        root.style.left = `${left}px`;
        root.style.top = `${top}px`;

        if (options.scale) {
            root.style.transform = `scale(${options.scale})`;
        }
    }

    /**
     * Adds an item to the menu.
     * @param {string} name - The name of the item.
     * @param {object | null} value - The value associated with the item.
     * @param {object} [options={}] - Additional options for the item.
     * @returns {HTMLElement} - The created HTML element representing the added item.
     */
    addItem(name, value, options = {}) {

        // value.callbacks_on_element_created ??= false; 

        LiteGraph.log_verbose("contextmenu", "addItem", ...arguments);

        const element = document.createElement("div");
        element.className = "litemenu-entry submenu";

        let disabled = false;
        var thisItem = element;

        if (value === null) {
            element.classList.add("separator");
        } else {
            element.innerHTML = value?.title ?? name;
            element.value = value;

            if (value) {
                if (value.disabled) {
                    disabled = true;
                    element.classList.add("disabled");
                }
                if (value.submenu || value.has_submenu) {
                    element.classList.add("has_submenu");
                }
            }

            if (typeof value == "function") {
                element.dataset["value"] = name;
                element.onclick_callback = value;
            } else {
                element.dataset["value"] = value;
            }

            if (value.className) {
                element.className += " " + value.className;
            }
            // execute element additional construction function
            if(typeof(value.callbacks_on_element_created)!=="undefined"){
                if(typeof(value.callbacks_on_element_created)=="function"){
                    value.callbacks_on_element_created = [value.callbacks_on_element_created];
                }
                var thisMenu = this;
                value.callbacks_on_element_created.forEach((fun)=>{
                    if(typeof(fun)=="function"){
                        LiteGraph.log_debug("contextmenu", "addItem", "callbacks_on_element_created", element, fun);
                        fun(element, thisMenu);
                    }
                })
            }
        }

        this.root.appendChild(element);

        if (!disabled) {
            element.addEventListener("click", handleMenuItemClick);
            element.do_click = function(event, ignore_parent_menu){
                // LiteGraph.log_verbose("contextmenu", "addItem", "do_click", "handleMenuItemClick", "this", this, "thisItem", thisItem, "event", event, "ignore_parent_menu", ignore_parent_menu);
                if(!event){
                    LiteGraph.log_warn("contextmenu", "addItem", "do_click", "has no event", ...arguments);
                }else if(!event.clientX){
                    LiteGraph.log_warn("contextmenu", "addItem", "do_click", "event has no clientX info", event);
                }else{
                    LiteGraph.log_verbose("contextmenu", "addItem", "do_click", "has clientX", event);
                }
                handleMenuItemClick.call(thisItem, event, ignore_parent_menu);
            };
        }
        if (!disabled && options.autoopen) {
            element.addEventListener("pointerenter",(event) => {
                const value = this.value;
                if (!value || !value.has_submenu) {
                    return;
                }
                // if it is a submenu, autoopen like the item was clicked
                handleMenuItemClick.call(this, event);
            });
        }

        var that = this;

        function handleMenuItemClick(event) {
            const value = this.value;
            let closeParent = true;

            LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "process", value,event,options,closeParent,this.current_submenu,this);

            // Close any current submenu
            that.current_submenu?.close(event);

            // Hide filter
            const thisFilter = Array.from(that.root.querySelectorAll(".context-menu-filter"));
            if(thisFilter && thisFilter.length){
                thisFilter[0].style.display = "none";
            }

            // Execute global callback
            if (options.callback) {
                LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "global callback",this,value,options,event,that,options.node);
                
                const globalCallbackResult = options.callback.call(this, value, options, event, that, options.node);
                if (globalCallbackResult === true) {
                    LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "global callback processed, dont close parent?", globalCallbackResult);
                    closeParent = false;
                }else{
                    LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "global callback processed, will close parent", globalCallbackResult);
                }
            }

            // Handle special cases
            if (value) {
                if (value.callback && !options.ignore_item_callbacks && value.disabled !== true) {

                    LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "using value callback and !ignore_item_callbacks",this,value,options,event,that,options.node);
                    const itemCallbackResult = value.callback.call(this, value, options, event, that, options.extra);
                    if (itemCallbackResult === true) {
                        closeParent = false;
                    }
                }
                if (value.submenu) {
                    LiteGraph.log_debug("contextmenu", "handleMenuItemClick", "SUBMENU",this,value,value.submenu.options,event,that,options);

                    if (!value.submenu.options) {
                        // throw new Error("contextmenu", "handleMenuItemClick", "submenu needs options");
                        LiteGraph.log_warn("contextmenu", "handleMenuItemClick", "SUBMENU", "submenu needs options");
                        return;
                    }
                    // Recursively create submenu
                    new that.constructor(value.submenu.options, {
                        callback: value.submenu.callback,
                        event: event,
                        parentMenu: that,
                        ignore_item_callbacks: value.submenu.ignore_item_callbacks,
                        title: value.submenu.title,
                        extra: value.submenu.extra,
                        autoopen: options.autoopen,
                    });
                    closeParent = false;
                }
            }

            // Close parent menu if necessary and not locked
            if (closeParent && !that.lock) {
                that.close();
            }
        }
        
        // push to menu_elements here
        this.menu_elements.push(element);

        return element;
    }

    /**
     * Closes this menu.
     * @param {Event} [e] - The event that triggered the close action.
     * @param {boolean} [ignore_parent_menu=false] - Whether to ignore the parent menu when closing.
     */
    close(e, ignore_parent_menu) {
        if (this.parentMenu && !ignore_parent_menu) {
            this.parentMenu.lock = false;
            this.parentMenu.current_submenu = null;
            if (e === undefined) {
                this.parentMenu.close();
            } else if (
                e &&
                !ContextMenu.isCursorOverElement(e, this.parentMenu.root)
            ) {
                ContextMenu.trigger(this.parentMenu.root, "pointerleave", e);
            }
        }
        this.current_submenu?.close(e, true);

        if (this.root.closing_timer) {
            clearTimeout(this.root.closing_timer);
        }

        if (this.root.parentNode) {
            this.root.parentNode.removeChild(this.root);
        }
    }

    /**
     * Closes all open ContextMenus in the specified window.
     * @param {Window} [ref_window=window] - The window object to search for open menus.
     */
    static closeAll = (ref_window = window) => {
        const elements = ref_window?.document?.querySelectorAll(".litecontextmenu");
        if (!elements || !elements.length)
            return;

        elements.forEach((element) => {
            if (element.close) {
                element.close();
            } else {
                element.parentNode?.removeChild(element);
            }
        });
    };

    /**
     * Triggers an event on the specified element with the given event name and parameters.
     * @param {HTMLElement} element - The element on which to trigger the event.
     * @param {string} event_name - The name of the event to trigger.
     * @param {Object} params - Additional parameters to include in the event.
     * @param {HTMLElement} origin - The origin of the event <currently not supported as CustomEvent can't have a target!>
     * @returns {CustomEvent} - The created CustomEvent instance.
     * @BUG: Probable bug related to params, origin not being configured/populated correctly
     */
    static trigger(element, event_name, params, origin) {
        const evt = new CustomEvent(event_name, {
            bubbles: true,
            cancelable: true,
            detail: params,
        });
        Object.defineProperty(evt, 'target', { value: origin });
        if (element.dispatchEvent) {
            element.dispatchEvent(evt);
        } else if (element.__events) {
            element.__events.dispatchEvent(evt);
        }
        return evt;
    }

    // returns the top most menu
    getTopMenu() {
        return this.options.parentMenu?.getTopMenu() ?? this;
    }

    getFirstEvent() {
        return this.options.parentMenu?.getFirstEvent() ?? this.options.event;
    }

    static isCursorOverElement(event, element) {
        return LiteGraph.isInsideRectangle(event.clientX, event.clientY, element.left, element.top, element.width, element.height);
    }
}


// used by some widgets to render a curve editor
export class CurveEditor {
    constructor(points) {
        this.points = points;
        this.selected = -1;
        this.nearest = -1;
        this.size = null; // stores last size used
        this.must_update = true;
        this.margin = 5;
    }

    static sampleCurve(f, points) {
        if(!points)
            return;
        for(var i = 0; i < points.length - 1; ++i) {
            var p = points[i];
            var pn = points[i+1];
            if(pn[0] < f)
                continue;
            var r = (pn[0] - p[0]);
            if( Math.abs(r) < 0.00001 )
                return p[1];
            var local_f = (f - p[0]) / r;
            return p[1] * (1.0 - local_f) + pn[1] * local_f;
        }
        return 0;
    }

    draw(ctx, size, graphcanvas, background_color, line_color, inactive) {
        var points = this.points;
        if(!points)
            return;
        this.size = size;
        var w = size[0] - this.margin * 2;
        var h = size[1] - this.margin * 2;

        line_color = line_color || "#666";

        ctx.save();
        ctx.translate(this.margin,this.margin);

        if(background_color) {
            ctx.fillStyle = "#111";
            ctx.fillRect(0,0,w,h);
            ctx.fillStyle = "#222";
            ctx.fillRect(w*0.5,0,1,h);
            ctx.strokeStyle = "#333";
            ctx.strokeRect(0,0,w,h);
        }
        ctx.strokeStyle = line_color;
        if(inactive)
            ctx.globalAlpha = 0.5;
        ctx.beginPath();
        for(let i = 0; i < points.length; ++i) {
            let p = points[i];
            ctx.lineTo( p[0] * w, (1.0 - p[1]) * h );
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
        if(!inactive)
            for(let i = 0; i < points.length; ++i) {
                let p = points[i];
                ctx.fillStyle = this.selected == i ? "#FFF" : (this.nearest == i ? "#DDD" : "#AAA");
                ctx.beginPath();
                ctx.arc( p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2 );
                ctx.fill();
            }
        ctx.restore();
    }

    // localpos is mouse in curve editor space
    onMouseDown(localpos, graphcanvas) {
        var points = this.points;
        if(!points)
            return;
        if( localpos[1] < 0 )
            return;

        // this.captureInput(true);
        var w = this.size[0] - this.margin * 2;
        var h = this.size[1] - this.margin * 2;
        var x = localpos[0] - this.margin;
        var y = localpos[1] - this.margin;
        var pos = [x,y];
        var max_dist = 30 / graphcanvas.ds.scale;
        // search closer one
        this.selected = this.getCloserPoint(pos, max_dist);
        // create one
        if(this.selected == -1) {
            var point = [x / w, 1 - y / h];
            points.push(point);
            points.sort((a, b) => a[0] - b[0]);
            this.selected = points.indexOf(point);
            this.must_update = true;
        }
        if(this.selected != -1)
            return true;
    }

    onMouseMove(localpos, graphcanvas) {
        var points = this.points;
        if(!points)
            return;
        var s = this.selected;
        if(s < 0)
            return;
        var x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2 );
        var y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2 );
        var curvepos = [(localpos[0] - this.margin),(localpos[1] - this.margin)];
        var max_dist = 30 / graphcanvas.ds.scale;
        this._nearest = this.getCloserPoint(curvepos, max_dist);
        var point = points[s];
        if(point) {
            var is_edge_point = s == 0 || s == points.length - 1;
            if( !is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10) ) {
                points.splice(s,1);
                this.selected = -1;
                return;
            }
            if( !is_edge_point ) // not edges
                point[0] = LiteGraph.clamp(x, 0, 1);
            else
                point[0] = s == 0 ? 0 : 1;
            point[1] = 1.0 - LiteGraph.clamp(y, 0, 1);
            points.sort((a, b) => a[0] - b[0]);
            this.selected = points.indexOf(point);
            this.must_update = true;
        }
    }

    onMouseUp() { // not event handler, callback
        this.selected = -1;
        return false;
    }

    getCloserPoint(pos, max_dist) {
        var points = this.points;
        if(!points)
            return -1;
        max_dist = max_dist || 30;
        var w = (this.size[0] - this.margin * 2);
        var h = (this.size[1] - this.margin * 2);
        var num = points.length;
        var p2 = [0,0];
        var min_dist = 1000000;
        var closest = -1;
        for(var i = 0; i < num; ++i) {
            var p = points[i];
            p2[0] = p[0] * w;
            p2[1] = (1.0 - p[1]) * h;
            if(p2[0] < pos[0])
                last_valid = i;
            var dist = vec2.distance(pos,p2);
            if(dist > min_dist || dist > max_dist)
                continue;
            closest = i;
            min_dist = dist;
        }
        return closest;
    }
}


/**
 * Class responsible for handling scale and offset transformations for an HTML element,
 * enabling zooming and dragging functionalities.
 */
export class DragAndScale {
    /**
     * Creates an instance of DragAndScale.
     * @param {HTMLElement} element - The HTML element to apply scale and offset transformations.
     * @param {boolean} skip_events - Flag indicating whether to skip binding mouse and wheel events.
     *
     * Rendering:
     * toCanvasContext() is HTMLCanvas, and onredraw is probably also.  The rest is all HTML+CSS+JS
     */

    constructor(element, skip_events) {

        this.offset = new Float32Array([0, 0]);
        this.scale = 1;
        this.max_scale = 10;
        this.min_scale = 0.1;
        this.onredraw = null;
        this.enabled = true;
        this.last_mouse = [0, 0];
        this.element = null;
        this.visible_area = new Float32Array(4);

        if (element) {
            this.element = element;
            if (!skip_events) {
                this.bindEvents(element);
            }
        }
    }

    /**
     * Binds mouse and wheel events to the specified HTML element.
     *
     * @param {HTMLElement} element - The HTML element to bind the events to.
     */
    bindEvents(element) {
        this.last_mouse = new Float32Array(2);
        element.addEventListener("pointerdown", this.onMouseDown);
        element.addEventListener("wheel", this.onWheel);
    }

    onMouseDown = (event) => {
        if (!this.enabled) {
            return;
        }

        const canvas = this.element;
        const rect = canvas.getBoundingClientRect();
        var x = event.clientX - rect.left;
        var y = event.clientY - rect.top;
        event.canvasx = x;
        event.canvasy = y;
        event.dragging = this.dragging;

        var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        if (is_inside) {
            this.dragging = true;
            this.abortController = new AbortController();
            document.addEventListener("pointermove",this.onMouseMove, { signal: this.abortController.signal });
            document.addEventListener("pointerup",this.onMouseUp, { signal: this.abortController.signal });
        }

        this.last_mouse[0] = x;
        this.last_mouse[1] = y;

    }

    onMouseMove = (event) => {
        if (!this.enabled) {
            return;
        }

        const canvas = this.element;
        const rect = canvas.getBoundingClientRect();
        var x = event.clientX - rect.left;
        var y = event.clientY - rect.top;
        event.canvasx = x;
        event.canvasy = y;
        event.dragging = this.dragging;

        var deltax = x - this.last_mouse[0];
        var deltay = y - this.last_mouse[1];
        if (this.dragging) {
            this.mouseDrag(deltax, deltay);
        }

        this.last_mouse[0] = x;
        this.last_mouse[1] = y;

    }

    onMouseUp = (_event) => {
        this.dragging = false;
        this.abortController?.abort();
    }

    onWheel = (event) => {
        event.wheel = -event.deltaY;

        // from stack overflow
        event.delta = event.wheelDelta
            ? event.wheelDelta / 40
            : event.deltaY
                ? -event.deltaY / 3
                : 0;
        this.changeDeltaScale(1.0 + event.delta * 0.05);
    }

    /**
     * Computes the visible area of the DragAndScale element based on the viewport.
     *
     * If the element is not set, the visible area will be reset to zero.
     *
     * @param {Array<number>} [viewport] - The viewport configuration to calculate the visible area.
     */
    computeVisibleArea(viewport) {
        if (!this.element) {
            this.visible_area.set([0, 0, 0, 0]);
            return;
        }
        let width = this.element.width;
        let height = this.element.height;
        let startx = -this.offset[0];
        let starty = -this.offset[1];
        if (viewport) {
            startx += viewport[0] / this.scale;
            starty += viewport[1] / this.scale;
            const [vpWidth, vpHeight] = viewport.slice(2);
            width = vpWidth;
            height = vpHeight;
        }

        const endx = startx + width / this.scale;
        const endy = starty + height / this.scale;
        const coords = [startx, starty, endx - startx, endy - starty];
        this.visible_area.set(coords);
        return coords;
    }

    /**
     * Applies the scale and offset transformations to the given 2D canvas rendering context.
     *
     * @param {CanvasRenderingContext2D} ctx - The 2D canvas rendering context to apply transformations to.
     */
    toCanvasContext(ctx) {
        ctx.scale(this.scale, this.scale);
        ctx.translate(this.offset[0], this.offset[1]);
    }

    /**
     * Converts a position from DragAndScale offset coordinates to canvas coordinates.
     *
     * @param {Array<number>} pos - The position in DragAndScale offset coordinates to convert.
     * @returns {Array<number>} The converted position in canvas coordinates.
     */
    convertOffsetToCanvas(pos) {
        return [
            (pos[0] + this.offset[0]) * this.scale,
            (pos[1] + this.offset[1]) * this.scale,
        ];
    }

    /**
     * Converts a position from canvas coordinates to DragAndScale offset coordinates.
     *
     * @param {Array<number>} pos - The position in canvas coordinates to convert.
     * @param {Array<number>} [out=[0, 0]] - The output array to store the converted position in DragAndScale offset coordinates.
     * @returns {Array<number>} The converted position in DragAndScale offset coordinates.
     */
    convertCanvasToOffset(pos, out = [0, 0]) {
        out[0] = pos[0] / this.scale - this.offset[0];
        out[1] = pos[1] / this.scale - this.offset[1];
        return out;
    }

    mouseDrag(x, y) {
        this.offset[0] += x / this.scale;
        this.offset[1] += y / this.scale;

        this.onredraw?.(this);
    }

    /**
     * Changes the scale of the DragAndScale element to the specified value around the zooming center.
     *
     * @param {number} value - The new scale value to set, clamped between min_scale and max_scale.
     * @param {Array<number>} zooming_center - The center point for zooming, defaulting to the middle of the element.
     */
    changeScale(value, zooming_center) {

        LiteGraph.log_debug("dragandscale","changeScale",value,zooming_center);

        value = LiteGraph.clamp(value, this.min_scale, this.max_scale);

        if (value == this.scale || !this.element) {
            return;
        }
        const rect = this.element.getBoundingClientRect();
        if (!rect) {
            return;
        }

        zooming_center = zooming_center || [
            rect.width * 0.5,
            rect.height * 0.5,
        ];

        var center = this.convertCanvasToOffset(zooming_center);
        LiteGraph.log_debug("dragandscale","changeScale","center",center);
        this.scale = value;
        if (Math.abs(this.scale - 1) < 0.01) {
            this.scale = 1;
        }

        var new_center = this.convertCanvasToOffset(zooming_center);
        LiteGraph.log_debug("dragandscale","changeScale","new center",new_center);
        var delta_offset = [
            new_center[0] - center[0],
            new_center[1] - center[1],
        ];

        LiteGraph.log_debug("dragandscale","changeScale",value,zooming_center);

        this.offset[0] += delta_offset[0];
        this.offset[1] += delta_offset[1];

        this.onredraw?.(this);
    }

    /**
     * Changes the scale of the DragAndScale element by a delta value relative to the current scale.
     *
     * @param {number} value - The delta value by which to scale the element.
     * @param {Array<number>} zooming_center - The center point for zooming the element.
     */
    changeDeltaScale(value, zooming_center) {
        this.changeScale(this.scale * value, zooming_center);
    }

    reset() {
        this.scale = 1;
        this.offset[0] = 0;
        this.offset[1] = 0;
    }
}


/**
 * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.
 * supported callbacks:
    + onNodeAdded: when a new node is added to the graph
    + onNodeRemoved: when a node inside this graph is removed
    + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)
 */
export class LGraph {

    // default supported types
    static supported_types = ["number", "string", "boolean"];

    static STATUS_STOPPED = 1;
    static STATUS_RUNNING = 2;

    /**
     * @constructor
     * @param {Object} o data from previous serialization [optional]} o
     */
    constructor(o) {
        LiteGraph.log_debug("Graph created",o);
        this.list_of_graphcanvas = null;

        this.callbackhandler_setup();

        this.clear();

        if (o) {
            this.configure(o);
        }
        
        LiteGraph.processCallbackHandlers("on_lgraph_construct",{
            def_cb: LiteGraph.on_lgraph_construct
        }, this);
    }

    callbackhandler_setup(){
        this.cb_handler = new CallbackHandler(this);
    }

    registerCallbackHandler(){
        return this.cb_handler.registerCallbackHandler(...arguments);
    };
    unregisterCallbackHandler(){
        return this.cb_handler.unregisterCallbackHandler(...arguments);
    };
    processCallbackHandlers(){
        return this.cb_handler.processCallbackHandlers(...arguments);
    };

    /**
     * Gets the supported types of the LGraph class, falling back to the default supported types if not defined for the instance.
     * @returns {Array} An array of supported types for the LGraph class.
     */
    getSupportedTypes() {
        return this.supported_types ?? LGraph.supported_types;
    }

    /**
     * Removes all nodes from this graph
     * @method clear
     */
    clear() {
        this.stop();
        this.status = LGraph.STATUS_STOPPED;

        this.last_node_id = 0;
        this.last_link_id = 0;

        this._version = -1; // used to detect changes

        // safe clear
        this._nodes?.forEach((node) => {
            node.processCallbackHandlers("onRemoved",{
                def_cb: node.onRemoved
            });
        });

        // nodes
        this._nodes = [];
        this._nodes_by_id = {};
        this._nodes_in_order = []; // nodes sorted in execution order
        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order

        // other scene stuff
        this._groups = [];

        // links
        this.links = {}; // container with all the links

        // iterations
        this.iteration = 0;

        // custom data
        this.config = {};
        this.configApplyDefaults();

        this.vars = {};
        this.extra = {}; // to store custom data

        // timing
        this.globaltime = 0;
        this.runningtime = 0;
        this.fixedtime = 0;
        this.fixedtime_lapse = 0.01;
        this.elapsed_time = 0.01;
        this.last_update_time = 0;
        this.starttime = 0;

        this.catch_errors = true;

        // savings
        this.history = {
            actionHistory: [],
            actionHistoryVersions: [],
            actionHistoryPtr: 0,
        };

        this.nodes_executing = [];
        this.nodes_actioning = [];
        this.node_ancestorsCalculated = [];
        this.nodes_executedAction = [];

        // subgraph_data
        this.inputs = {};
        this.outputs = {};

        // notify canvas to redraw
        this.change();

        this.sendActionToCanvas("clear");
    }

    /**
    * Apply config values to LGraph config object
    * @method configApply
     * @param {object} opts options to merge
    */
    configApply(opts) {
        /*
        align_to_grid
        links_ontop
        */
        this.config = Object.assign(this.config,opts);
    }

    /**
    * Apply config values to LGraph config object
    * @method configApply
     * @param {object} opts options to merge
    */
    configApplyDefaults() {
        var opts = LiteGraph.graphDefaultConfig;
        this.configApply(opts);
    }

    /**
     * Attach Canvas to this graph
     * @method attachCanvas
     * @param {GraphCanvas} graph_canvas
     */
    attachCanvas(graphcanvas) {
        if ( ! (graphcanvas instanceof LGraphCanvas) ) {
            throw new Error("attachCanvas expects a LiteGraph.LGraphCanvas instance");
        }
        if (graphcanvas.graph && graphcanvas.graph != this) {
            LiteGraph.log_debug("lgraph","attachCanvas","detaching previous");
            graphcanvas.graph.detachCanvas(graphcanvas);
        }

        graphcanvas.graph = this;
        this.list_of_graphcanvas ??= [];
        var pos = this.list_of_graphcanvas.indexOf(graphcanvas);
        if (pos == -1) {
            LiteGraph.log_debug("lgraph","attachCanvas","attaching canvas");
            this.list_of_graphcanvas.push(graphcanvas);
        }else{
            LiteGraph.log_debug("lgraph","attachCanvas","canvas was already attached");
        }
    }

    /**
     * Detach Canvas from this graph
     * @method detachCanvas
     * @param {GraphCanvas} graph_canvas
     */
    detachCanvas(graphcanvas) {
        if (!this.list_of_graphcanvas) {
            return;
        }
        var pos = this.list_of_graphcanvas.indexOf(graphcanvas);
        if (pos == -1) {
            return;
        }
        // graphcanvas.graph = null; // ?!
        LiteGraph.log_debug("lgraph","detachCanvas",pos,this.list_of_graphcanvas,this);
        this.list_of_graphcanvas.splice(pos, 1);
    }

    /**
     * Starts running this graph every interval milliseconds.
     * @method start
     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
     */
    start(interval = 0) {
        if (this.status === LGraph.STATUS_RUNNING) {
            return;
        }

        this.status = LGraph.STATUS_RUNNING;
        this.processCallbackHandlers("onPlayEvent",{
            def_cb: this.onPlayEvent
        });
        this.sendEventToAllNodes("onStart");

        this.starttime = LiteGraph.getTime();
        this.last_update_time = this.starttime;

        const onAnimationFrame = () => {
            if (this.execution_timer_id !== -1) {
                return;
            }
            window.requestAnimationFrame(onAnimationFrame);
            this.processCallbackHandlers("onBeforeStep",{
                def_cb: this.onBeforeStep
            });
            this.runStep(1, !this.catch_errors);
            this.processCallbackHandlers("onAfterStep",{
                def_cb: this.onAfterStep
            });
        };

        if (interval === 0 && typeof window === "object" && window.requestAnimationFrame) {
            this.execution_timer_id = -1;
            onAnimationFrame();
        } else {
            this.execution_timer_id = setInterval(() => {
                this.processCallbackHandlers("onBeforeStep",{
                    def_cb: this.onBeforeStep
                });
                this.runStep(1, !this.catch_errors);
                this.processCallbackHandlers("onAfterStep",{
                    def_cb: this.onAfterStep
                });
            }, interval);
        }
    }

    /**
     * Stops the execution loop of the graph
     * @method stop execution
     */
    stop() {
        if (this.status == LGraph.STATUS_STOPPED) {
            return;
        }
        this.status = LGraph.STATUS_STOPPED;
        this.processCallbackHandlers("onStopEvent",{
            def_cb: this.onStopEvent
        });
        if (this.execution_timer_id != null) {
            if (this.execution_timer_id != -1) {
                clearInterval(this.execution_timer_id);
            }
            this.execution_timer_id = null;
        }
        this.sendEventToAllNodes("onStop");
        
        // TODO CHECK THIS : TRYING to refresh canvas, for multiview one still need a manual refresh (mouseover) 
        // var thisGraph = this;
        // let fRefreshOnStop = function(){
        //     thisGraph.change();
        //     // thisGraph.setDirtyCanvas(true,true);
        //     thisGraph.sendActionToCanvas("draw");
        //     LiteGraph.log_warn("finally drawing on stop");
        // };
        // if(window.requestAnimationFrame){
        //     window.requestAnimationFrame(fRefreshOnStop);
        // }
        // setTimeout(fRefreshOnStop,972);
        
    }

    /**
     * Run N steps (cycles) of the graph
     * @method runStep
     * @param {number} num number of steps to run, default is 1
     * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors
     * @param {number} limit max number of nodes to execute (used to execute from start to a node)
     */
    runStep(num = 1, do_not_catch_errors, limit) {
        var start = LiteGraph.getTime();
        this.globaltime = 0.001 * (start - this.starttime);

        var nodes = this._nodes_executable ?? this._nodes;
        if (!nodes) {
            return;
        }

        limit ||= nodes.length;

        if (do_not_catch_errors) {
            for (let i = 0; i < num; i++) {
                nodes.forEach((node) => {
                    if (LiteGraph.use_deferred_actions && node._waiting_actions?.length) {
                        node.executePendingActions();
                    }

                    if (node.mode === LiteGraph.ALWAYS) {
                        node.doExecute?.();
                    }
                });

                this.fixedtime += this.fixedtime_lapse;
                this.processCallbackHandlers("onExecuteStep",{
                    def_cb: this.onExecuteStep
                });
            }
            this.processCallbackHandlers("onAfterExecute",{
                def_cb: this.onAfterExecute
            });
        } else { // catch errors
            try {
                for (let i = 0; i < num; i++) {
                    nodes.forEach((node) => {
                        if (LiteGraph.use_deferred_actions && node._waiting_actions?.length) {
                            node.executePendingActions();
                        }

                        if (node.mode === LiteGraph.ALWAYS) {
                            node.doExecute?.();
                        }
                    });

                    this.fixedtime += this.fixedtime_lapse;
                    this.processCallbackHandlers("onExecuteStep",{
                        def_cb: this.onExecuteStep
                    });
                }

                this.processCallbackHandlers("onAfterExecute",{
                    def_cb: this.onAfterExecute
                });
                this.errors_in_execution = false;
            } catch (err) {

                this.errors_in_execution = true;
                if (LiteGraph.throw_errors) {
                    throw err;
                }
                LiteGraph.log_warn("lgraph","Error during execution",err);
                this.stop();
            }
        }

        var now = LiteGraph.getTime();
        var elapsed = now - start;
        if (elapsed == 0) {
            elapsed = 1;
        }
        this.execution_time = 0.001 * elapsed;
        this.globaltime += 0.001 * elapsed;
        this.iteration += 1;
        this.elapsed_time = (now - this.last_update_time) * 0.001;
        this.last_update_time = now;
        this.nodes_executing = [];
        this.nodes_actioning = [];
        this.node_ancestorsCalculated = [];
        this.nodes_executedAction = [];
    }

    /**
     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
     * nodes with only inputs.
     * @method updateExecutionOrder
     */
    updateExecutionOrder() {
        this._nodes_in_order = this.computeExecutionOrder(false);
        this._nodes_executable = [];
        for (var i = 0; i < this._nodes_in_order.length; ++i) {
            if (this._nodes_in_order[i].onExecute) {
                this._nodes_executable.push(this._nodes_in_order[i]);
            }
        }
    }

    /**
     * Computes the execution order of nodes in the flow graph based on their connections and levels.
     * @param {boolean} only_onExecute - Indicates whether to consider only nodes with an onExecute method.
     * @param {boolean} set_level - If true, assigns levels to the nodes based on their connections.
     * @returns {Array} An array of nodes in the calculated execution order.
     *
     * @TODO:This whole concept is a mistake.  Should call graph back from output nodes
     */
    computeExecutionOrder(only_onExecute, set_level) {
        var L = [];
        var S = [];
        var M = {};
        var visited_links = {}; // to avoid repeating links
        var remaining_links = {}; // to a

        // search for the nodes without inputs (starting nodes)
        for (let i = 0, l = this._nodes.length; i < l; ++i) {
            let node = this._nodes[i];
            if (only_onExecute && !node.onExecute) {
                continue;
            }

            M[node.id] = node; // add to pending nodes

            var num = 0; // num of input connections
            if (node.inputs) {
                for (var j = 0, l2 = node.inputs.length; j < l2; j++) {
                    if (node.inputs[j] && node.inputs[j].link != null) {
                        num += 1;
                    }
                }
            }

            if (num == 0) {
                // is a starting node
                S.push(node);
                if (set_level) {
                    node._level = 1;
                }
            } else { // num of input links
                if (set_level) {
                    node._level = 0;
                }
                remaining_links[node.id] = num;
            }
        }

        while (S.length != 0) {

            // get an starting node
            var node = S.shift();
            L.push(node); // add to ordered list
            delete M[node.id]; // remove from the pending nodes

            if (!node.outputs) {
                continue;
            }

            // for every output
            for (let i = 0; i < node.outputs.length; i++) {
                let output = node.outputs[i];
                // not connected
                if (
                    output == null ||
                    output.links == null ||
                    output.links.length == 0
                ) {
                    continue;
                }

                // for every connection
                for (let j = 0; j < output.links.length; j++) {
                    let link_id = output.links[j];
                    let link = this.links[link_id];
                    if (!link) {
                        continue;
                    }

                    // already visited link (ignore it)
                    if (visited_links[link.id]) {
                        continue;
                    }

                    let target_node = this.getNodeById(link.target_id);
                    if (target_node == null) {
                        visited_links[link.id] = true;
                        continue;
                    }

                    if (
                        set_level &&
                        (!target_node._level ||
                            target_node._level <= node._level)
                    ) {
                        target_node._level = node._level + 1;
                    }

                    visited_links[link.id] = true; // mark as visited
                    remaining_links[target_node.id] -= 1; // reduce the number of links remaining
                    if (remaining_links[target_node.id] == 0) {
                        S.push(target_node);
                    } // if no more links, then add to starters array
                }
            }
        }

        // the remaining ones (loops)
        for (let i in M) {
            L.push(M[i]);
        }

        if (L.length != this._nodes.length && LiteGraph.debug) {
            LiteGraph.log_warn("lgraph", "computeExecutionOrder", "something went wrong, nodes missing");
        }

        var l = L.length;

        // save order number in the node
        for (let i = 0; i < l; ++i) {
            L[i].order = i;
        }

        // sort now by priority
        L = L.sort((A, B) => {
            let Ap = A.constructor.priority || A.priority || 0;
            let Bp = B.constructor.priority || B.priority || 0;
            if (Ap == Bp) {
                // if same priority, sort by order
                return A.order - B.order;
            }
            return Ap - Bp; // sort by priority
        });

        // save order number in the node, again...
        for (let i = 0; i < l; ++i) {
            L[i].order = i;
        }

        return L;
    }

    /**
     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
     * It doesn't include the node itself
     * @method getAncestors
     * @return {Array} an array with all the LiteGraph.LGraphNodes that affect this node, in order of execution
     */
    getAncestors(node, optsIn = {}) {
        var optsDef = {
            modesSkip: [],
            modesOnly: [],
            typesSkip: [],
            typesOnly: [],
        };
        var opts = Object.assign(optsDef,optsIn);

        var ancestors = [];
        var ancestorsIds = [];
        var pending = [node];
        var visited = {};

        while (pending.length) {
            var current = pending.shift();
            if (!current) {
                continue;
            }
            if (visited[current.id]) {
                continue;
            }
            // mark as visited
            visited[current.id] = true;

            // add to ancestors
            if (current.id != node.id) {

                // mode check
                if (opts.modesSkip && opts.modesSkip.length) {
                    if (opts.modesSkip.indexOf(current.mode) != -1) {
                        // DBG EXCESS (keep) LiteGraph.log_verbose("mode skip "+current.id+":"+current.order+" :: "+current.mode);
                        continue;
                    }
                }
                if (opts.modesOnly && opts.modesOnly.length) {
                    if (opts.modesOnly.indexOf(current.mode) == -1) {
                        // DBG EXCESS (keep) LiteGraph.log_verbose("mode only "+current.id+":"+current.order+" :: "+current.mode);
                        continue;
                    }
                }

                if (ancestorsIds.indexOf(current.id) == -1) {
                    ancestors.push(current);
                    ancestorsIds.push(current.id);
                    // DBG EXCESS (keep) LiteGraph.log_verbose("push current "+current.id+":"+current.order);
                }

            }

            // get its inputs
            if (!current.inputs) {
                continue;
            }

            for (var i = 0; i < current.inputs.length; ++i) {
                var input = current.getInputNode(i);
                if (!input)
                    continue;
                var inputType = current.inputs[i].type;

                // type check
                if (opts.typesSkip && opts.typesSkip.length) {
                    if (opts.typesSkip.indexOf(inputType) != -1) {
                        // DBG EXCESS (keep) LiteGraph.log_verbose("type skip "+input.id+":"+input.order+" :: "+inputType);
                        continue;
                    }
                }
                if (opts.typesOnly && opts.typesOnly.length) {
                    if (opts.typesOnly.indexOf(input.mode) == -1) {
                        // DBG EXCESS (keep) LiteGraph.log_verbose("type only "+input.id+":"+input.order+" :: "+inputType);
                        continue;
                    }
                }

                // DBG EXCESS (keep) LiteGraph.log_verbose("input "+i+" "+input.id+":"+input.order);
                // push em in
                if (ancestorsIds.indexOf(input.id) == -1) {
                    if(!visited[input.id]) {
                        pending.push(input);
                        // DBG EXCESS (keep) LiteGraph.log_verbose("push input "+input.id+":"+input.order);
                    }
                }
            }
        }

        ancestors.sort((a, b) => a.order - b.order);
        return ancestors;
    }

    /**
     * Positions every node in a more readable manner
     * @method arrange
     */
    arrange(margin = 100, layout) {
        const nodes = this.computeExecutionOrder(false, true);
        const columns = [];
        for (let i = 0; i < nodes.length; ++i) {
            const node = nodes[i];
            const col = node._level || 1;
            columns[col] ??= [];
            columns[col].push(node);
        }

        let x = margin;

        for (let i = 0; i < columns.length; ++i) {
            const column = columns[i];
            if (!column) {
                continue;
            }
            let max_size = 100;
            let y = margin + LiteGraph.NODE_TITLE_HEIGHT;
            for (let j = 0; j < column.length; ++j) {
                const node = column[j];
                node.pos[0] = (layout == LiteGraph.VERTICAL_LAYOUT) ? y : x;
                node.pos[1] = (layout == LiteGraph.VERTICAL_LAYOUT) ? x : y;
                const max_size_index = (layout == LiteGraph.VERTICAL_LAYOUT) ? 1 : 0;
                if (node.size[max_size_index] > max_size) {
                    max_size = node.size[max_size_index];
                }
                const node_size_index = (layout == LiteGraph.VERTICAL_LAYOUT) ? 0 : 1;
                y += node.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT;
            }
            x += max_size + margin;
        }

        this.setDirtyCanvas(true, true);
    }

    /**
     * Returns the amount of time the graph has been running in milliseconds
     * @method getTime
     * @return {number} number of milliseconds the graph has been running
     */
    getTime() {
        return this.globaltime;
    }

    /**
     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
     * @method getFixedTime
     * @return {number} number of milliseconds the graph has been running
     */
    getFixedTime() {
        return this.fixedtime;
    }

    /**
     * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
     * if the nodes are using graphical actions
     * @method getElapsedTime
     * @return {number} number of milliseconds it took the last cycle
     */
    getElapsedTime() {
        return this.elapsed_time;
    }

    /**
     * Sends an event to all the nodes, useful to trigger stuff
     * TODO :: nice stuff !! check and improve
     * @method sendEventToAllNodes
     * @param {String} eventname the name of the event (function to be called)
     * @param {Array} params parameters in array format
     */
    sendEventToAllNodes(eventname, params, mode = LiteGraph.ALWAYS) {
        var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
        if (!nodes) {
            return;
        }

        for (let j = 0, l = nodes.length; j < l; ++j) {
            const node = nodes[j];

            if (
                node.constructor === LiteGraph.Subgraph &&
                eventname !== "onExecute"
            ) {
                if (node.mode == mode) {
                    node.sendEventToAllNodes(eventname, params, mode);
                }
                continue;
            }

            if (typeof(node[eventname])!=="function" || node.mode !== mode) {
                continue;
            }
            if (params === undefined) {
                node[eventname]();
            } else if (Array.isArray(params)) {
                node[eventname].apply(node, params);
            } else {
                node[eventname](params);
            }
        }
    }

    /**
     * Sends an action with parameters to the connected GraphCanvas instances for processing.
     * @param {string} action - The action to be performed on the GraphCanvas instances.
     * @param {Array} params - An array of parameters to be passed to the action method.
     */
    sendActionToCanvas(action, params) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        for (const c of this.list_of_graphcanvas) {
            if (typeof(c[action])=="function" && c[action] && params) {
                c[action](...params);
            }
        }
    }

    /**
     * Adds a new node instance to this graph
     * @method add
     * @param {LiteGraph.LGraphNode} node the instance of the node
     */
    add(node, skip_compute_order, optsIn = {}) {

        var optsDef = {
            doProcessChange: true,
            doCalcSize: true,
        };
        var opts = Object.assign(optsDef,optsIn);

        if (!node) {
            return;
        }

        // groups
        if (node.constructor === LiteGraph.LGraphGroup) {
            this._groups.push(node);
            this.setDirtyCanvas(true);
            this.change();
            node.graph = this;
            this.onGraphChanged({action: "groupAdd", doSave: opts.doProcessChange});
            return;
        }

        // nodes
        if (node.id != -1 && this._nodes_by_id[node.id] != null) {
            LiteGraph.log_debug("lgraph", "add", "there is already a node with this ID, changing it", node);
            if (LiteGraph.use_uuids) {
                node.id = LiteGraph.uuidv4();
            } else {
                node.id = ++this.last_node_id;
            }
        }

        if (LiteGraph.MAX_NUMBER_OF_NODES > 0 && this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
            LiteGraph.log_error("lgraph", "add", "max number of nodes in a graph reached", LiteGraph.MAX_NUMBER_OF_NODES);
            return;
            // throw new Error("LiteGraph: max number of nodes in a graph reached");
        }

        // give him an id
        if (LiteGraph.use_uuids) {
            if (node.id == null || node.id == -1)
                node.id = LiteGraph.uuidv4();
        } else {
            if (node.id == null || node.id == -1) {
                node.id = ++this.last_node_id;
            } else if (this.last_node_id < node.id) {
                this.last_node_id = node.id;
            }
        }

        node.graph = this;
        this.onGraphChanged({action: "nodeAdd", doSave: opts.doProcessChange});

        this._nodes.push(node);
        this._nodes_by_id[node.id] = node;

        node.processCallbackHandlers("onAdded",{
            def_cb: node.onAdded
        }, this);

        if (this.config.align_to_grid) {
            node.alignToGrid();
        }

        if (!skip_compute_order) {
            this.updateExecutionOrder();
        }

        this.processCallbackHandlers("onNodeAdded",{
            def_cb: this.onNodeAdded
        }, node);

        if (opts.doCalcSize) {
            node.setSize( node.computeSize() );
        }
        this.setDirtyCanvas(true);
        this.change();

        return node; // to chain actions
    }

    /**
     * Removes a node from the graph
     * @method remove
     * @param {LiteGraph.LGraphNode} node the instance of the node
     */
    remove(node) {
        if (node.constructor === LiteGraph.LGraphGroup) {
            var index = this._groups.indexOf(node);
            if (index != -1) {
                this._groups.splice(index, 1);
            }
            node.graph = null;
            this.onGraphChanged({action: "groupRemove"});
            this.setDirtyCanvas(true, true);
            this.change();
            return;
        }

        if (this._nodes_by_id[node.id] == null) {
            return;
        } // not found

        if (node.ignore_remove) {
            return;
        } // cannot be removed

        // this.beforeChange(); // sure? - almost sure is wrong

        // disconnect inputs
        if (node.inputs) {
            for (let i = 0; i < node.inputs.length; i++) {
                let slot = node.inputs[i];
                if (slot.link != null) {
                    node.disconnectInput(i, {doProcessChange: false});
                }
            }
        }

        // disconnect outputs
        if (node.outputs) {
            for (let i = 0; i < node.outputs.length; i++) {
                let slot = node.outputs[i];
                if (slot.links != null && slot.links.length) {
                    node.disconnectOutput(i, false, {doProcessChange: false});
                }
            }
        }

        // node.id = -1; //why?

        // callback
        node.processCallbackHandlers("onRemoved",{
            def_cb: node.onRemoved
        }, this);

        node.graph = null;

        // remove from canvas render
        if (this.list_of_graphcanvas) {
            for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {
                let canvas = this.list_of_graphcanvas[i];
                if (canvas.selected_nodes[node.id]) {
                    delete canvas.selected_nodes[node.id];
                }
                if (canvas.node_dragged == node) {
                    canvas.node_dragged = null;
                }
            }
        }

        // remove from containers
        var pos = this._nodes.indexOf(node);
        if (pos != -1) {
            this._nodes.splice(pos, 1);
        }
        delete this._nodes_by_id[node.id];

        this.processCallbackHandlers("onNodeRemoved",{
            def_cb: this.onNodeRemoved
        }, node);

        this.onGraphChanged({action: "nodeRemove"});

        // close panels
        this.sendActionToCanvas("checkPanels");

        this.setDirtyCanvas(true, true);
        // this.afterChange(); // sure? - almost sure is wrong
        this.change();

        this.updateExecutionOrder();
    }

    /**
     * Returns a node by its id.
     * @method getNodeById
     * @param {Number} id
     */
    getNodeById(id) {
        if (id == null) {
            return null;
        }
        return this._nodes_by_id[id];
    }

    /**
     * Returns a list of nodes that matches a class
     * @method findNodesByClass
     * @param {Class} classObject the class itself (not an string)
     * @return {Array} a list with all the nodes of this type
     */
    findNodesByClass(classObject, result = []) {
        result = this._nodes.filter((node) => node.constructor === classObject);
        return result;
    }

    /**
     * Returns a list of nodes that matches a type
     * @method findNodesByType
     * @param {String} type the name of the node type
     * @return {Array} a list with all the nodes of this type
     */
    findNodesByType(type, result = []) {
        const lowerCaseType = type.toLowerCase();
        result = this._nodes.filter((node) => node.type.toLowerCase() === lowerCaseType);
        return result;
    }

    /**
     * Returns the first node that matches a name in its title
     * @method findNodeByTitle
     * @param {String} name the name of the node to search
     * @return {Node} the node or null
     */
    findNodeByTitle(title) {
        return this._nodes.find((node) => node.title === title) ?? null;
    }

    /**
     * Returns a list of nodes that matches a name
     * @method findNodesByTitle
     * @param {String} name the name of the node to search
     * @return {Array} a list with all the nodes with this name
     */
    findNodesByTitle(title) {
        return this._nodes.filter((node) => node.title === title);
    }

    /**
     * Returns the top-most node in this position of the canvas
     * @method getNodeOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
     * @return {LiteGraph.LGraphNode} the node at this position or null
     */
    getNodeOnPos(x, y, nodes_list = this._nodes, margin = 0) {
        return nodes_list.reverse().find((node) => node.isPointInside(x, y, margin)) ?? null;
    }

    /**
     * Returns the y closest group enclosing a position
     * @method getGroupOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @return {LiteGraph.LGraphGroup} the group or null
     */
    getGroupOnPos(x, y) {
        // let firstGroupMatching = this._groups.find((group) => group.isPointInside(x, y, 2, true)) ?? null;
        let aMatchingGroups = this._groups.filter((group, index) => {
            return group.isPointInside(x, y, 2, true); // ?? null;
        });
        if(!aMatchingGroups.length) return null;
        LiteGraph.log_verbose("lgraph","getGroupOnPos","matching groups by x,y",x,y,aMatchingGroups);
        let aSortedByYDistance = aMatchingGroups.sort((a,b) => Math.abs(a._pos[1]-y) > Math.abs(b._pos[1]-y));
        LiteGraph.log_verbose("lgraph","getGroupOnPos","sorted groups y distance",aSortedByYDistance);
        return aSortedByYDistance[0];
    }

    /**
     * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
     * this replaces the ones using the old version with the new version
     * @method checkNodeTypes
     */
    checkNodeTypes() {
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var ctor = LiteGraph.registered_node_types[node.type];
            if (node.constructor == ctor) {
                continue;
            }
            LiteGraph.log_debug("lgraph", "checkNodeTypes", "node being replaced by newer version", node.type);
            var newnode = LiteGraph.createNode(node.type);
            this._nodes[i] = newnode;
            newnode.configure(node.serialize());
            newnode.graph = this;
            this._nodes_by_id[newnode.id] = newnode;
            if (node.inputs) {
                newnode.inputs = node.inputs.concat();
            }
            if (node.outputs) {
                newnode.outputs = node.outputs.concat();
            }
        }
        this.updateExecutionOrder();
    }

    /**
     * Executes an action on the GraphInput nodes based on the provided action name and parameters.
     * @param {string} action - The name of the action to be executed on the GraphInput nodes.
     * @param {any} param - The parameter to pass to the action method.
     * @param {object} options - Additional options for the action.
    */
   onAction(action, param, options) {
       this._input_nodes = this.findNodesByClass(
           LiteGraph.GraphInput,
           this._input_nodes,
        );
        LiteGraph.log_debug("lgraph", "onAction", "will trigger actionDo on input nodes", this._input_nodes, "with name(?!)", ...arguments);
        for (var i = 0; i < this._input_nodes.length; ++i) {
            var node = this._input_nodes[i];
            if (node.properties.name != action) {
                continue;
            }
            // wrap node.onAction(action, param);
            LiteGraph.log_debug("lgraph", "onAction", node, "node actionDo", ...arguments);
            node.actionDo(action, param, options);
            break;
        }
    }

    // TODO check this, investigate, _last_trigger_time ? who calls trigger ? who calls triggerInput ? who calls onTrigger ?
    trigger(action, param) {
        LiteGraph.log_debug("lgraph","trigger",action, param);
        // this.onTrigger?.(action, param);
        this.processCallbackHandlers("onTrigger",{
            def_cb: this.onTrigger
        }, action, param);
    }

    /**
     * Tell this graph it has a global graph input of this type
     * @method addGlobalInput
     * @param {String} name
     * @param {String} type
     * @param {*} value [optional]
     */
    addInput(name, type, value) {
        var input = this.inputs[name];
        if (input) {
            // already exist
            return;
        }

        this.beforeChange();
        this.inputs[name] = { name: name, type: type, value: value };
        this.onGraphChanged({action: "addInput"});
        this.afterChange();
        this.processCallbackHandlers("onInputAdded",{
            def_cb: this.onInputAdded
        }, name, type);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Assign a data to the global graph input
     * @method setGlobalInputData
     * @param {String} name
     * @param {*} data
     */
    setInputData(name, data) {
        var input = this.inputs[name];
        if (!input) {
            return;
        }
        input.value = data;
    }

    /**
     * Returns the current value of a global graph input
     * @method getInputData
     * @param {String} name
     * @return {*} the data
     */
    getInputData(name) {
        var input = this.inputs[name];
        if (!input) {
            return null;
        }
        return input.value;
    }

    /**
     * Changes the name of a global graph input
     * @method renameInput
     * @param {String} old_name
     * @param {String} new_name
     */
    renameInput(old_name, name) {
        if (name == old_name) {
            return;
        }

        if (!this.inputs[old_name]) {
            return false;
        }

        if (this.inputs[name]) {
            LiteGraph.log_error("lgraph", "renameInut", "there is already one input with that name");
            return false;
        }

        this.inputs[name] = this.inputs[old_name];
        delete this.inputs[old_name];
        this.onGraphChanged({action: "renameInput"});

        this.processCallbackHandlers("onInputRenamed",{
            def_cb: this.onInputRenamed
        }, old_name, name);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Changes the type of a global graph input
     * @method changeInputType
     * @param {String} name
     * @param {String} type
     */
    changeInputType(name, type) {
        if (!this.inputs[name]) {
            return false;
        }

        if (
            this.inputs[name].type &&
            String(this.inputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.inputs[name].type = type;
        this.onGraphChanged({action: "changeInputType"});
        this.processCallbackHandlers("onInputTypeChanged",{
            def_cb: this.onInputTypeChanged
        }, name, type);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Removes a global graph input
     * @method removeInput
     * @param {String} name
     * @param {String} type
     */
    removeInput(name) {
        if (!this.inputs[name]) {
            return false;
        }

        delete this.inputs[name];
        this.onGraphChanged({action: "graphRemoveInput"});

        this.processCallbackHandlers("onInputRemoved",{
            def_cb: this.onInputRemoved
        }, name);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
        return true;
    }

    /**
     * Creates a global graph output
     * @method addOutput
     * @param {String} name
     * @param {String} type
     * @param {*} value
     */
    addOutput(name, type, value) {
        this.outputs[name] = { name: name, type: type, value: value };
        this.onGraphChanged({action: "addOutput"});

        this.processCallbackHandlers("onOutputAdded",{
            def_cb: this.onOutputAdded
        }, name, type);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Assign a data to the global output
     * @method setOutputData
     * @param {String} name
     * @param {String} value
     */
    setOutputData(name, value) {
        var output = this.outputs[name];
        if (!output) {
            return;
        }
        output.value = value;
    }

    /**
     * Returns the current value of a global graph output
     * @method getOutputData
     * @param {String} name
     * @return {*} the data
     */
    getOutputData(name) {
        var output = this.outputs[name];
        if (!output) {
            return null;
        }
        return output.value;
    }

    /**
     * Renames a global graph output
     * @method renameOutput
     * @param {String} old_name
     * @param {String} new_name
     */
    renameOutput(old_name, name) {
        if (!this.outputs[old_name]) {
            return false;
        }

        if (this.outputs[name]) {
            LiteGraph.log_error("lgraph", "renameOutput", "there is already one output with that name");
            return false;
        }

        this.outputs[name] = this.outputs[old_name];
        delete this.outputs[old_name];
        this._version++;

        this.processCallbackHandlers("onOutputRenamed",{
            def_cb: this.onOutputRenamed
        }, old_name, name);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Changes the type of a global graph output
     * @method changeOutputType
     * @param {String} name
     * @param {String} type
     */
    changeOutputType(name, type) {
        if (!this.outputs[name]) {
            return false;
        }

        if (
            this.outputs[name].type &&
            String(this.outputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.outputs[name].type = type;
        this.onGraphChanged({action: "changeOutputType"});
        this.processCallbackHandlers("onOutputTypeChanged",{
            def_cb: this.onOutputTypeChanged
        }, name, type);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
    }

    /**
     * Removes a global graph output
     * @method removeOutput
     * @param {String} name
     */
    removeOutput(name) {
        if (!this.outputs[name]) {
            return false;
        }
        delete this.outputs[name];
        this.onGraphChanged({action: "removeOutput"});

        this.processCallbackHandlers("onOutputRemoved",{
            def_cb: this.onOutputRemoved
        }, name);
        this.processCallbackHandlers("onInputsOutputsChange",{
            def_cb: this.onInputsOutputsChange
        });
        return true;
    }

    /**
     * Triggers the 'onTrigger' method on nodes with a specific title by passing a value to them.
     * // TODO check this, investigate, _last_trigger_time ? who calls triggerInput ? who calls onTrigger ?
     * @param {string} name - The title of the nodes to trigger.
     * @param {any} value - The value to pass to the 'onTrigger' method of the nodes.
     */
    triggerInput(name, value) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].onTrigger(value);
        }
    }

    /**
     * Sets a callback function on nodes with a specific title by invoking their 'setTrigger' method.
     * // TODO check this, investigate, who calls setCallback, setTrigger, onTrigger ?
     * @param {string} name - The title of the nodes to set the callback function on.
     * @param {Function} func - The callback function to be set on the nodes.
     */
    setCallback(name, func) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].setTrigger(func);
        }
    }

    /**
     * Executes actions before a change with the provided information detail.
     * Calls the 'onBeforeChange' function on the class instance and sends the action to connected GraphCanvas instances.
     * @param {object} info - The information detail about the change.
     */
    beforeChange(info) {
        this.processCallbackHandlers("onBeforeChange",{
            def_cb: this.onBeforeChange
        }, this, info);
        this.sendActionToCanvas("onBeforeChange", this);
    }

    /**
     * Executes actions after a change with the provided information detail.
     * Calls the 'onAfterChange' function on the class instance and sends the action to connected GraphCanvas instances.
     * @param {object} info - The information detail about the change.
     */
    afterChange(info) {
        this.processCallbackHandlers("onAfterChange",{
            def_cb: this.onAfterChange
        }, this, info);
        this.sendActionToCanvas("onAfterChange", this);
    }

    /**
     * Handles changes in node connections and triggers related actions.
     * Updates the execution order, calls the 'onConnectionChange' function on the class instance and connected GraphCanvas instances, and increments the version.
     * @param {object} node - The node where the connection change occurred.
     * @param {object} link_info - Information about the changed connection.
     */
    connectionChange(node) {
        this.updateExecutionOrder();
        this.processCallbackHandlers("onConnectionChange",{
            def_cb: this.onConnectionChange
        }, node);
        this.onGraphChanged({action: "connectionChange", doSave: false});
        this.sendActionToCanvas("onConnectionChange");
    }

    /**
     * returns if the graph is in live mode
     * @method isLive
     */
    isLive() {
        if (!this.list_of_graphcanvas) {
            return false;
        }

        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
            var c = this.list_of_graphcanvas[i];
            if (c.live_mode) {
                return true;
            }
        }
        return false;
    }

    /**
     * clears the triggered slot animation in all links (stop visual animation)
     * @method clearTriggeredSlots
     */
    clearTriggeredSlots() {
        for (var i in this.links) {
            var link_info = this.links[i];
            if (!link_info) {
                continue;
            }
            link_info._last_time &&= 0;
        }
    }

    /**
     * Indicates a visual change in the graph (not the structure) and triggers related actions.
     * Logs a message if in debug mode, sends a 'setDirty' action with parameters to connected GraphCanvas instances, and calls the 'on_change' function on the class instance.
     * @method change
     */
    change() {
        LiteGraph.log_verbose("lgraph", "change", "Graph visually changed");
        this.sendActionToCanvas("setDirty", [true, true]);
        this.processCallbackHandlers("on_change",{ // name refactor ? is this being used ?
            def_cb: this.on_change
        }, this);
    }

    setDirtyCanvas(fg, bg) {
        this.sendActionToCanvas("setDirty", [fg, bg]);
    }

    /**
     * Destroys a link
     * @method removeLink
     * @param {Number} link_id
     */
    removeLink(link_id) {
        var link = this.links[link_id];
        if (!link) {
            return;
        }
        var node = this.getNodeById(link.target_id);
        if(node) {
            this.beforeChange();
            node.disconnectInput(link.target_slot); /* , optsIn */
            this.afterChange();
        }
    }

    /**
     * Creates a Object containing all the info about this graph, it can be serialized
     * @method serialize
     * @return {Object} value of the node
     */
    serialize() {
        const nodesInfo = this._nodes.map((node) => node.serialize());
        // TODO ensure and remove
        // var nodesInfo = [];
        // for (var i = 0, l = this._nodes.length; i < l; ++i) {
        //     nodesInfo.push(this._nodes[i].serialize());
        // }

        // pack link info into a non-verbose format
        var links = [];
        for (var i in this.links) {
            // links is an OBJECT
            var link = this.links[i];
            if (!link.serialize) {
                // weird bug I havent solved yet
                LiteGraph.log_warn("lgraph", "serialize", "weird LLink bug, link info is not a LLink but a regular object");
                var link2 = new LLink();
                for (var j in link) {
                    link2[j] = link[j];
                }
                this.links[i] = link2;
                link = link2;
            }

            links.push(link.serialize());
        }

        const groupsInfo = this._groups.map((group) => group.serialize());
        // TODO ensure and remove
        // var groupsInfo = [];
        // for (var i = 0; i < this._groups.length; ++i) {
        //     groupsInfo.push(this._groups[i].serialize());
        // }

        var data = {
            last_node_id: this.last_node_id,
            last_link_id: this.last_link_id,
            nodes: nodesInfo,
            links: links,
            groups: groupsInfo,
            config: this.config,
            extra: this.extra,
            version: LiteGraph.VERSION,
        };
        this.processCallbackHandlers("onSerialize",{
            def_cb: this.onSerialize
        }, data);
        
        LiteGraph.log_verbose("lgraph","serialize",data);

        return data;
    }

    /**
     * Configure a graph from a JSON string
     * @method configure
     * @param {String} str configure a graph from a JSON string
     * @param {Boolean} returns if there was any error parsing
     */
    configure(data, keep_old) {
        if (!data) {
            return;
        }

        if (!keep_old) {
            this.clear();
        }

        var nodes = data.nodes;

        // decode links info (they are very verbose)
        if (data.links && data.links.constructor === Array) {
            var links = [];
            for (var i = 0; i < data.links.length; ++i) {
                var link_data = data.links[i];
                if(!link_data) { // @BUG: "weird bug" originally
                    LiteGraph.log_warn("lgraph", "configure", "serialized graph link data contains errors, skipping.",link_data,i,data.links);
                    continue;
                }
                var link = new LLink();
                link.configure(link_data);
                links[link.id] = link;
            }
            data.links = links;
        }

        // copy all stored fields
        for (let i in data) {
            if (["nodes", "groups"].includes(i)) continue; // exclude "nodes" and "groups" properties from direct copy
            this[i] = data[i]; // TODO should probably use LiteGraph.cloneObject
        }

        var error = false;

        // create nodes
        this._nodes = [];
        if (nodes) {
            for (let i = 0, l = nodes.length; i < l; ++i) {
                var n_info = nodes[i]; // stored info
                var node = LiteGraph.createNode(n_info.type, n_info.title);
                if (!node) {
                    LiteGraph.log_warn("lgraph", "configure", "Node not found or has errors", n_info.type, n_info);

                    // in case of error we create a replacement node to avoid losing info
                    node = new LiteGraph.LGraphNode();
                    node.last_serialization = n_info;
                    node.has_errors = true;
                    error = true;
                    // continue;
                }

                node.id = n_info.id; // id it or it will create a new id
                this.add(node, true, {doProcessChange: false}); // add before configure, otherwise configure cannot create links
            }

            // configure nodes afterwards so they can reach each other
            nodes.forEach((n_info) => {
                const node = this.getNodeById(n_info.id);
                node?.configure(n_info);
            });
        }

        // groups
        this._groups.length = 0;
        if (data.groups) {
            data.groups.forEach((groupData) => {
                const group = new LiteGraph.LGraphGroup();
                group.configure(groupData);
                this.add(group, true, {doProcessChange: false});
            });
        }

        this.updateExecutionOrder();

        this.extra = data.extra ?? {};

        this.processCallbackHandlers("onConfigure",{
            def_cb: this.onConfigure
        }, data);

        // TODO implement: when loading (configuring) a whole graph, skip calling graphChanged on every single configure
        if (!data._version) {
            this.onGraphChanged({action: "graphConfigure", doSave: false}); // this._version++;
        } else {
            LiteGraph.log_debug("lgraph", "configure", "skip onGraphChanged when configure passing version too!"); // atlasan DEBUG REMOVE
        }
        this.setDirtyCanvas(true, true);
        return error;
    }

    /**
     * Loads graph data from a given URL or file and configures the graph accordingly.
     * @param {string | File | Blob} url - The URL or file to load the graph data from.
     * @param {Function} callback - An optional callback function to be executed after loading and configuring the graph.
     */
    load(url, callback) {
        var that = this;

        // from file
        if(url.constructor === File || url.constructor === Blob) {
            var reader = new FileReader();
            reader.addEventListener('load', (event) => {
                var data = JSON.parse(event.target.result);
                that.configure(data);
                callback?.();
            });
            reader.readAsText(url);
            return;
        }

        // is a string, then an URL
        var req = new XMLHttpRequest();
        req.open("GET", url, true);
        req.send(null);
        req.onload = (_event) => {
            if (req.status !== 200) {
                LiteGraph.log_error("Error loading graph:", req.status, req.response);
                return;
            }
            var data = JSON.parse( req.response );
            that.configure(data);
            callback?.();
        };
        req.onerror = (err) => {
            LiteGraph.log_error("Error loading graph:", err);
        };
    }

    /**
    * Meant to serve the history-saving mechanism
    * @method onGraphSaved
    * @param {object} optsIn options
    */
    onGraphSaved(optsIn = {}) {
        var optsDef = {};
        var opts = Object.assign(optsDef,optsIn);

        LiteGraph.log_debug("onGraphSaved",opts);

        this.savedVersion = this._version;
    }

    /**
    * Meant to serve the history-saving mechanism
    * @method onGraphSaved
    * @param {object} optsIn options
    */
    onGraphLoaded(optsIn = {}) {
        var optsDef = {};
        var opts = Object.assign(optsDef,optsIn);

        LiteGraph.log_debug("onGraphLoaded",opts);

        this.savedVersion = this._version;
    }

    /**
    * Ment to be track down every change annotating the action, the history and prevent-exit mechanism, call to change _version
    * @method onGraphChanged
    * @param {object} optsIn options
    */
    onGraphChanged(optsIn = {}) {
        var optsDef = {
            action: "",
            doSave: true, // log action in graph.history
            doSaveGraph: true, // save
        };
        var opts = Object.assign(optsDef,optsIn);

        this._version++;

        if(opts.action) {
            LiteGraph.log_debug("Graph change",opts.action);
        } else {
            LiteGraph.log_debug("Graph change, no action",opts);
        }

        // TAG: EXTENSION, COULD extract and MOVE history to feature ?
        if(opts.doSave && LiteGraph.actionHistory_enabled) {

            LiteGraph.log_debug("LG_history","onGraphChanged SAVE :: "+opts.action); // debug history

            var oHistory = { actionName: opts.action };
            if(opts.doSaveGraph) {
                // this seems a heavy method, but the alternative is way more complex: every action has to have its contrary
                oHistory = Object.assign(oHistory, { graphSave: this.serialize() });
            }

            var obH = this.history;

            // check if pointer has gone back: remove newest
            while(obH.actionHistoryPtr < obH.actionHistoryVersions.length-1) {
                LiteGraph.log_debug("LG_history","popping: gone back? "+(obH.actionHistoryPtr+" < "+(obH.actionHistoryVersions.length-1))); // debug history
                obH.actionHistoryVersions.pop();
            }
            // check if maximum saves
            if(obH.actionHistoryVersions.length>=LiteGraph.actionHistoryMaxSave) {
                var olderSave = obH.actionHistoryVersions.shift();
                LiteGraph.log_debug("LG_history","maximum saves reached: "+obH.actionHistoryVersions.length+", remove older: "+olderSave); // debug history
                obH.actionHistory[olderSave] = false; // unset
            }

            // update pointer
            obH.actionHistoryPtr = obH.actionHistoryVersions.length;
            obH.actionHistoryVersions.push(obH.actionHistoryPtr);

            // save to pointer
            obH.actionHistory[obH.actionHistoryPtr] = oHistory;

            this.onGraphSaved({ iVersion: obH.actionHistoryPtr });

            LiteGraph.log_debug("LG_history","saved: "+obH.actionHistoryPtr,oHistory.actionName); // debug history
        }
    }

    /**
    * Go back in action history
    * @method actionHistoryBack
    * @param {object} optsIn options
    */
    actionHistoryBack(optsIn = {}) {
        var optsDef = { steps: 1 };
        var opts = Object.assign(optsDef,optsIn);

        var obH = this.history;

        if (obH.actionHistoryPtr != undefined && obH.actionHistoryPtr >= 0) {
            obH.actionHistoryPtr -= opts.steps;
            LiteGraph.log_debug("LG_history","step back: "+obH.actionHistoryPtr); // debug history
            if (!this.actionHistoryLoad({iVersion: obH.actionHistoryPtr})) {
                LiteGraph.log_warn("LG_history","Load failed, restore pointer? "+obH.actionHistoryPtr); // debug history
                // history not found?
                obH.actionHistoryPtr += opts.steps;
                return false;
            }else{
                LiteGraph.log_debug("LG_history","loaded back: "+obH.actionHistoryPtr); // debug history
                LiteGraph.log_debug(this.history);
                return true;
            }
        }else{
            LiteGraph.log_debug("LG_history","is already at older state");
            return false;
        }
    }

    /**
    * Go forward in action history
    * @method actionHistoryForward
    * @param {object} optsIn options
    */
    actionHistoryForward(optsIn = {}) {
        var optsDef = { steps: 1 };
        var opts = Object.assign(optsDef,optsIn);

        var obH = this.history;

        if (obH.actionHistoryPtr<obH.actionHistoryVersions.length) {
            obH.actionHistoryPtr += opts.steps;
            LiteGraph.log_debug("LG_history","step forward: "+obH.actionHistoryPtr); // debug history
            if (!this.actionHistoryLoad({iVersion: obH.actionHistoryPtr})) {
                LiteGraph.log_warn("LG_history","Load failed, restore pointer? "+obH.actionHistoryPtr); // debug history
                // history not found?
                obH.actionHistoryPtr -= opts.steps;
                return false;
            }else{
                LiteGraph.log_debug("LG_history","loaded forward: "+obH.actionHistoryPtr); // debug history
                return true;
            }
        }else{
            LiteGraph.log_debug("LG_history","is already at newer state");
            return false;
        }
    }

    /**
    * Load from action history
    * @method actionHistoryLoad
    * @param {object} optsIn options
    */
    actionHistoryLoad(optsIn = {}) {
        var optsDef = {
            iVersion: false,
            backStep: false,
        };
        var opts = Object.assign(optsDef,optsIn);

        var obH = this.history;

        if(obH.actionHistory[opts.iVersion] && obH.actionHistory[opts.iVersion].graphSave) {
            var tmpHistory = JSON.stringify(this.history);
            this.configure( obH.actionHistory[opts.iVersion].graphSave );
            this.history = JSON.parse(tmpHistory);
            LiteGraph.log_debug("history loaded: "+opts.iVersion,obH.actionHistory[opts.iVersion].actionName); // debug history
            this.onGraphLoaded({ iVersion: opts.iVersion });
            return true;
        }else{
            return false;
        }
    }
    
    /**
     * connect TWO nodes looking for matching types
     * @method autoConnectNodes
     **/
    autoConnectNodes(node_from, node_to, optsIn = {}) {
        var optsDef = {
            keep_alredy_connected: true,
        };
        var opts = Object.assign(optsDef,optsIn);

        if(!node_from || !node_to || !node_from.outputs || !node_from.outputs.length || !node_to.inputs || !node_to.inputs.length){
            return false;
        }
        // cycle outputs
        // for(let iO in node_from.outputs){ // WARNING THIS GETS INDEXES AS STRING : ARE THOSE SAVED AS STRING AND IF SO WHY?
        for(let iO=0; iO<node_from.outputs.length; iO++){ // TODO: Check if outputs are keyed by string and when
            let output = node_from.outputs[iO];
            if(!opts.keep_alredy_connected){
                if(output.links !== null && output.links.length > 0){
                    continue;
                }
            }
            node_from.connectByType(iO, node_to, output.type,{
                preferFreeSlot: true
            });
        }
    }

    updateNodeLinks(node, is_input, slots_from, slots_to){
        LiteGraph.log_debug("lgraph","updateNodeLinks","looking for links", node.id, is_input, slots_from, slots_to)
        
        // cycle links
        for (var i in this.links) {
            var link_info = this.links[i];
            if (link_info===null || !link_info) {
                continue;
            }
            if(is_input){
                if(link_info.target_id == node.id){
                    // found link with target the node
                    if(link_info.target_slot == slots_from){
                        // found link with target the slot
                        LiteGraph.log_debug("lgraph","updateNodeLinks","updating link input", this.links[i], node, is_input, slots_from, slots_to)
                        this.links[i].target_slot = slots_to;
                    }
                }
            }else{
                if(link_info.origin_id == node.id){
                    // found link with origin the node
                    if(link_info.origin_slot == slots_from){
                        // found link with origin the slot
                        LiteGraph.log_debug("lgraph","updateNodeLinks","updating link output", this.links[i], node, is_input, slots_from, slots_to)
                        this.links[i].origin_slot = slots_to;
                    }
                }
            }
        }

    }
}


/**
 * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.
 * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked
 *
 * @class LGraphCanvas
 * @constructor
 * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)
 * @param {LGraph} graph [optional]
 * @param {Object} options [optional] { skip_rendering, autoresize, viewport }
 */
export class LGraphCanvas {
    constructor(canvas, graph, options) {
        options ??= {
            skip_render: false,
            autoresize: false,
            clip_all_nodes: false,
            free_resize: true,

            groups_alpha: 0.21,
            groups_border_alpha: 0.45,
            groups_triangle_handler_size: 15,
            groups_title_font: "Arial",
            groups_title_alignment: "left",
            groups_title_font_size: 24, // group font size is actually a lgraphgroup property, and the default is in LiteGraph
            groups_title_wrap: true,
            groups_add_around_selected: true,
            groups_add_default_spacing: 15,

            hide_widget_label_when_small: 150, //false,

        };
        this.options = options;
        
        // register CallbackHandler methods on this
        this.callbackhandler_setup();

        // if(graph === undefined)
        //	throw new Error("No graph assigned");
        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;

        if (canvas && canvas.constructor === String) {
            canvas = document.querySelector(canvas);
        }

        this.ds = new DragAndScale();
        this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down too much

        this.title_text_font = `${LiteGraph.NODE_TEXT_SIZE}px Arial`;
        this.inner_text_font = `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px Arial`;
        this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
        this.default_link_color = LiteGraph.LINK_COLOR;
        this.default_connection_color = {
            input_off: "#778",
            input_on: "#7F7", // "#BBD"
            output_off: "#778",
            output_on: "#7F7", // "#BBD"
        };
        this.default_connection_color_byType = {}; /* number: "#7F7", string: "#77F", boolean: "#F77",*/
        this.default_connection_color_byTypeOff = {}; /* number: "#474", string: "#447", boolean: "#744",*/
        this.drag_mode = false; // never used ?
        this.dragging_rectangle = null;

        this.filter = null; // allows to filter to only accept some type of nodes in a graph

        this.highquality_render = true;
        this.use_gradients = false; // set to true to render titlebar with gradients
        this.editor_alpha = 1; // used for transition
        this.pause_rendering = false;
        this.clear_background = true;
        this.clear_background_color = "#222";

        this.read_only = false; // if set to true users cannot modify the graph
        //  this.render_only_selected = true; // @TODO Atlasan figures this isn't used
        this.live_mode = false;
        this.show_info = true;
        this.allow_dragcanvas = true;
        this.allow_dragnodes = true;
        this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc
        this.multi_select = false; // allow selecting multi nodes without pressing extra keys
        this.allow_searchbox = true;
        //  this.allow_reconnect_links = true; // @TODO: replaced by Atlasan.  Clean up.  allows to change a connection with having to redo it again
        this.move_destination_link_without_shift = false;
        this.align_to_grid = false; // snap to grid

        this.drag_mode = false;
        this.dragging_rectangle = null;

        this.filter = null; // allows to filter to only accept some type of nodes in a graph

        this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse does anything
        this.always_render_background = false;
        this.render_shadows = true;
        this.render_canvas_border = true;
        this.render_connections_shadows = false; // too much cpu
        this.render_connections_border = true;
        this.render_curved_connections = true;
        this.render_connection_arrows = false;
        this.render_collapsed_slots = true;
        this.render_execution_order = false;
        this.render_title_colored = true;
        this.render_link_tooltip = true;

        this.links_render_mode = LiteGraph.SPLINE_LINK;

        // TODO refactor: options object do need refactoring .. all the options are actually outside of it
        this.autoresize = options.autoresize;
        this.skip_render = options.skip_render;
        this.clip_all_nodes = options.clip_all_nodes;
        this.free_resize = options.free_resize;

        this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle
        this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle
        this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD

        // to personalize the search box
        this.onSearchBox = null;
        this.onSearchBoxSelection = null;

        // callbacks
        this.onMouse = null;
        this.onDrawBackground = null; // to render background objects (behind nodes and connections) in the canvas affected by transform
        this.onDrawForeground = null; // to render foreground objects (above nodes and connections) in the canvas affected by transform
        this.onDrawOverlay = null; // to render foreground objects not affected by transform (for GUIs)
        this.onDrawLinkTooltip = null; // called when rendering a tooltip
        this.onNodeMoved = null; // called after moving a node
        this.onSelectionChange = null; // called if the selection changes
        this.onConnectingChange = null; // called before any link changes
        this.onBeforeChange = null; // called before modifying the graph
        this.onAfterChange = null; // called after modifying the graph

        this.connections_width = 3;
        this.round_radius = 8;

        this.current_node = null;
        this.node_widget = null; // used for widgets: active (clicked) widget
        this.over_widget = null;
        this.over_node = null;
        this.over_link_center = null;
        this.last_mouse_position = [0, 0];
        this.visible_area = this.ds.visible_area;
        this.visible_links = [];

        this.viewport = options.viewport || null; // to constraint render area to a portion of the canvas
        this.low_quality_rendering_threshold = 5; // amount of slow fps to switch to low quality rendering

        // link canvas and graph
        graph?.attachCanvas(this);
        this.setCanvas(canvas,options.skip_events);
        this.clear();

        if (!this.skip_render && !options.skip_render) {
            this.startRendering();
        }

        // event dispatcher, along direct (single) assignment of callbacks [ event entrypoint ]
        this.callbackhandler_setup();

        LiteGraph.processCallbackHandlers("on_lgraphcanvas_construct",{
            def_cb: LiteGraph.on_lgraphcanvas_construct
        }, this);
    }

    callbackhandler_setup(){
        this.cb_handler = new CallbackHandler(this);
        // register CallbackHandler methods on this // Should move as class standard class methods?
        // this.registerCallbackHandler = function(){ return this.cb_handler.registerCallbackHandler(...arguments); };
        // this.unregisterCallbackHandler = function(){ return this.cb_handler.unregisterCallbackHandler(...arguments); };
        // this.processCallbackHandlers = function(){ return this.cb_handler.processCallbackHandlers(...arguments); };
    }

    registerCallbackHandler(){
        // if(!this.cb_handler) this.callbackhandler_setup();
        return this.cb_handler.registerCallbackHandler(...arguments);
    };
    unregisterCallbackHandler(){
        // if(!this.cb_handler) this.callbackhandler_setup();
        return this.cb_handler.unregisterCallbackHandler(...arguments);
    };
    processCallbackHandlers(){
        // if(!this.cb_handler) this.callbackhandler_setup();
        return this.cb_handler.processCallbackHandlers(...arguments);
    };

    /**
     * clears all the data inside
     *
     * @method clear
     */
    clear() {
        this.frame = 0;
        this.last_draw_time = 0;
        this.render_time = 0;
        this.fps = 0;
        this.low_quality_rendering_counter = 0;

        // this.scale = 1;
        // this.offset = [0,0];

        this.dragging_rectangle = null;

        this.selected_nodes = {};
        this.selected_group = null;

        this.visible_nodes = [];
        this.node_dragged = null;
        this.node_over = null;
        this.node_capturing_input = null;
        this.connecting_node = null;
        this.connecting = false; // ment to progressively replace connecting_node
        this.highlighted_links = {};

        this.dragging_canvas = false;

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        this.dirty_area = null;

        this.node_in_panel = null;
        this.node_widget = null;

        this.last_mouse = [0, 0];
        this.last_mouseclick = 0;
        this.pointer_is_down = false;
        this.pointer_is_double = false;
        this.visible_area.set([0, 0, 0, 0]);

        // TAG callback graphrenderer event entrypoint
        this.processCallbackHandlers("onClear",{
            def_cb: this.onClear
        });
    }

    /**
     * assigns a graph, you can reassign graphs to the same canvas
     *
     * @method setGraph
     * @param {LGraph} graph
     */
    setGraph(graph, skip_clear) {
        if (this.graph == graph) {
            return;
        }

        if (!skip_clear) {
            this.clear();
        }

        if (!graph) {
            this.graph?.detachCanvas(this);
            return;
        }

        graph.attachCanvas(this);
        LiteGraph.log_debug("lgraphcanvas","setGraph",graph,this);

        // remove the graph stack in case a subgraph was open
        this._graph_stack &&= null;
        this.setDirty(true, true);
    }

    /**
     * returns the top level graph (in case there are subgraphs open on the canvas)
     *
     * @method getTopGraph
     * @return {LGraph} graph
     */
    getTopGraph() {
        if(this._graph_stack.length)
            return this._graph_stack[0];
        return this.graph;
    }

    /**
     * opens a graph contained inside a node in the current graph
     *
     * @method openSubgraph
     * @param {LGraph} graph
     */
    openSubgraph(graph) {
        if (!graph) {
            throw new Error("graph cannot be null");
        }

        if (this.graph == graph) {
            throw new Error("graph cannot be the same");
        }

        this.clear();
        
        if (this.graph) {
            this._graph_stack ||= [];
            this._graph_stack.push(this.graph);
        }

        var prev_graph = this.graph;
        var cbRet = this.processCallbackHandlers("onOpenSubgraph",{
            def_cb: this.onOpenSubgraph
        }, graph, prev_graph);

        graph.attachCanvas(this);
        this.checkPanels();
        
        this.setDirty(true, true);
    }

    /**
     * closes a subgraph contained inside a node
     *
     * @method closeSubgraph
     * @param {LGraph} assigns a graph
     */
    closeSubgraph() {
        if (!this._graph_stack || this._graph_stack.length == 0) {
            return;
        }
        var subgraph_node = this.graph._subgraph_node;
        var prev_graph = this.graph;
        var graph = this._graph_stack.pop();
        this.selected_nodes = {};
        this.highlighted_links = {};

        var cbRet = this.processCallbackHandlers("onCloseSubgraph",{
            def_cb: this.onCloseSubgraph
        }, graph, prev_graph, subgraph_node );

        graph.attachCanvas(this);
        this.setDirty(true, true);
        if (subgraph_node) {
            this.centerOnNode(subgraph_node);
            this.selectNodes([subgraph_node]);
        }
        // when close sub graph back to offset [0, 0] scale 1
        this.ds.offset = [0, 0]
        this.ds.scale = 1
    }

    /**
     * returns the visually active graph (in case there are more in the stack)
     * @method getCurrentGraph
     * @return {LGraph} the active graph
     */
    getCurrentGraph() {
        return this.graph;
    }

    /**
     * assigns a canvas
     *
     * @method setCanvas
     * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)
     */
    setCanvas(canvas, skip_events) {

        if (canvas) {
            if (canvas.constructor === String) {
                canvas = document.getElementById(canvas);
                if (!canvas) {
                    throw new Error("Error creating LiteGraph canvas: Canvas not found");
                }
            }
        }

        if (canvas === this.canvas) {
            return;
        }

        if (!canvas && this.canvas) {
            // maybe detach events from old_canvas
            if (!skip_events) {
                this.unbindEvents();
            }
        }

        this.canvas = canvas;
        this.ds.element = canvas;

        if (!canvas) {
            return;
        }

        // this.canvas.tabindex = "1000";
        canvas.className += " lgraphcanvas";
        canvas.data = this;
        canvas.tabindex = "1"; // to allow key events

        // bg canvas: used for non changing stuff
        this.bgcanvas = document.createElement("canvas");
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;

        if (canvas.getContext == null) {
            if (canvas.localName != "canvas") {
                throw new Error("Element supplied for LGraphCanvas must be a <canvas> element, you passed a "+canvas.localName);
            }
            throw new Error("This browser doesn't support Canvas");
        }

        var ctx = this.ctx = canvas.getContext("2d");
        if (ctx == null) {
            if (!canvas.webgl_enabled) {
                LiteGraph.log_info("This canvas seems to be WebGL, enabling WebGL renderer");
            }
            this.enableWebGL();
        }

        if (!skip_events) {
            this.bindEvents();
        }
    }

    // used in some events to capture them
    _doNothing(e) {
        LiteGraph.log_verbose("pointerevents: _doNothing "+e.type);
        e.preventDefault();
        return false;
    }

    _doReturnTrue(e) {
        e.preventDefault();
        return true;
    }

    /**
     * binds mouse, keyboard, touch and drag events to the canvas
     * @method bindEvents
     **/
    bindEvents() {
        if (this._events_binded) {
            LiteGraph.log_warn("LGraphCanvas: events already binded");
            return;
        }
        this._events_binded = true;
        var canvas = this.canvas;
        var ref_window = this.getCanvasWindow();
        var document = ref_window.document; // multiwindows

        // Pointer
        this._mousedown_callback = this.processMouseDown.bind(this);
        this._mousemove_callback = this.processMouseMove.bind(this);
        this._mouseup_callback = this.processMouseUp.bind(this);
        canvas.addEventListener("pointerdown", this._mousedown_callback); //, true);
        canvas.addEventListener("pointermove", this._mousemove_callback);
        canvas.addEventListener("pointerup", this._mouseup_callback); //, true);
        canvas.addEventListener("contextmenu", this._doNothing);

        // Wheel
        canvas.addEventListener("wheel", this.processMouseWheel);

        // Keyboard
        canvas.addEventListener("keydown", this.processKey);
        document.addEventListener("keyup", this.processKey); // in document, otherwise it doesn't fire keyup

        // Drop
        canvas.addEventListener("dragover", this._doNothing, false);
        canvas.addEventListener("dragend", this._doNothing, false);
        canvas.addEventListener("drop", this.processDrop);
        canvas.addEventListener("dragenter", this._doReturnTrue, false);
    }

    /**
     * unbinds mouse events from the canvas
     * @method unbindEvents
     **/
    unbindEvents() {
        if (!this._events_binded) {
            LiteGraph.log_warn("LGraphCanvas: no events binded");
            return;
        }
        this._events_binded = false;
        var canvas = this.canvas;
        var ref_window = this.getCanvasWindow();
        var document = ref_window.document;

        // Pointer
        canvas.removeEventListener("pointerdown", this._mousedown_callback); //, true);
        canvas.removeEventListener("pointermove", this._mousemove_callback);
        canvas.removeEventListener("pointerup", this._mouseup_callback); //, true);
        canvas.removeEventListener("contextmenu", this._doNothing);

        // Wheel
        canvas.removeEventListener("wheel", this.processMouseWheel);

        // Keyboard
        canvas.removeEventListener("keydown", this.processKey);
        document.removeEventListener("keyup", this.processKey);

        // Drop
        canvas.removeEventListener("dragover", this._doNothing, false);
        canvas.removeEventListener("dragend", this._doNothing, false);
        canvas.removeEventListener("drop", this.processDrop);
        canvas.removeEventListener("dragenter", this._doReturnTrue, false);

        this._mousedown_callback = null;

    }

    static getFileExtension(url) {
        // const urlObj = new URL(url);
        // const path = urlObj.pathname;
        // const lastDotIndex = path.lastIndexOf(".");
        // if (lastDotIndex === -1) return "";
        // return path.slice(lastDotIndex + 1).toLowerCase();
        url = url ? url+"" : "";
        return url.slice((url.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    }

    /**
     * this function allows to render the canvas using WebGL instead of Canvas2D
     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
     * @method enableWebGL
     **/
    enableWebGL() {
        if (typeof GL === "undefined") {
            throw new Error("litegl.js must be included to use a WebGL canvas");
        }
        if (typeof enableWebGLCanvas === "undefined") {
            throw new Error("webglCanvas.js must be included to use this feature");
        }

        this.gl = this.ctx = enableWebGLCanvas(this.canvas);
        this.ctx.webgl = true;
        this.bgcanvas = this.canvas;
        this.bgctx = this.gl;
        this.canvas.webgl_enabled = true;

        /*
    GL.create({ canvas: this.bgcanvas });
    this.bgctx = enableWebGLCanvas( this.bgcanvas );
    window.gl = this.gl;
    */
    }

    /**
     * marks as dirty the canvas, this way it will be rendered again
     *
     * @class LGraphCanvas
     * @method setDirty
     * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
     * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
     */
    setDirty(fgcanvas, bgcanvas) {
        if (fgcanvas) {
            this.dirty_canvas = true;
        }
        if (bgcanvas) {
            this.dirty_bgcanvas = true;
        }
    }

    /**
     * Used to attach the canvas in a popup
     *
     * @method getCanvasWindow
     * @return {window} returns the window where the canvas is attached (the DOM root node)
     */
    getCanvasWindow() {
        if (!this.canvas) {
            return window;
        }
        var doc = this.canvas.ownerDocument;
        return doc.defaultView ?? doc.parentWindow;
    }

    /**
     * starts rendering the content of the canvas when needed
     *
     * @method startRendering
     */
    startRendering() {
        if (this.is_rendering) {
            return;
        } // already rendering

        this.is_rendering = true;
        renderFrame.call(this);

        function renderFrame() {
            if (!this.pause_rendering) {
                this.draw();
            }

            var window = this.getCanvasWindow();
            if (this.is_rendering) {
                window.requestAnimationFrame(renderFrame.bind(this));
            }
        }
    }

    /**
     * stops rendering the content of the canvas (to save resources)
     *
     * @method stopRendering
     */
    stopRendering() {
        this.is_rendering = false;
        /*
    if(this.rendering_timer_id)
    {
        clearInterval(this.rendering_timer_id);
        this.rendering_timer_id = null;
    }
    */
    }

    /* LiteGraphCanvas input */

    // used to block future mouse events (because of im gui)
    blockClick() {
        this.block_click = true;
        this.last_mouseclick = 0;
    }

    processUserInputDown(e) {

        if(this.pointer_is_down && e.isPrimary !== undefined && !e.isPrimary) {
            this.userInput_isNotPrimary = true;
            // DBG("pointerevents: userInput_isNotPrimary start");
        } else {
            this.userInput_isNotPrimary = false;
        }

        this.userInput_type = e.pointerType?e.pointerType:false;
        this.userInput_id = e.pointerId?e.pointerId:false;

        if (e.pointerType) {
            switch (e.pointerType) {
                case "mouse":
                    break;
                case "pen":
                    break;
                case "touch":
                    break;
                default:
                    LiteGraph.log_debug("pointerType unknown " + ev.pointerType);
            }
        }

        if (e.button !== undefined) {
            this.userInput_button = e.button;
            LiteGraph.log_verbose("input button ",e.button);
            switch(e.button) {
                case -1: // no changes since last event
                case 0: // Left Mouse, Touch Contact, Pen contact
                case 1: // Middle Mouse
                case 2: // Right Mouse, Pen barrel button
                case 3: // X1 (back) Mouse
                case 4: // X2 (forward) Mouse
                case 5: // Pen eraser button
                default: // ?? move without touches
            }
        }
        if (e.buttons !== undefined) {
            this.userInput_button_s = e.buttons;
            LiteGraph.log_verbose("input button_S ",e.buttons);
        }

        this.userInput_touches = (e.changedTouches!==undefined && e.changedTouches.length!==undefined) ? e.changedTouches : false;
        if (this.userInput_touches && this.userInput_touches.length) {
            LiteGraph.log_debug("check multiTouches",e.changedTouches);
        }

        return this.processMouseDown(e);
    }

    processMouseDown(e) {

        if( this.set_canvas_dirty_on_mouse_event )
            this.dirty_canvas = true;

        if (!this.graph) {
            return;
        }

        this.adjustMouseEvent(e);

        var ref_window = this.getCanvasWindow();
        LGraphCanvas.active_canvas = this;

        // processing mouseDown for all canvas ?

        var x = e.clientX;
        var y = e.clientY;
        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "pointerId:"+e.pointerId+" which:"+e.which+" isPrimary:"+e.isPrimary+" :: x y "+x+" "+y,"previousClick",this.last_mouseclick,"diffTimeClick",(this.last_mouseclick?LiteGraph.getTime()-this.last_mouseclick:"notlast"));
        LiteGraph.log_verbose("coordinates",x,y,this.viewport, "canvas coordinates", e.canvasX, e.canvasY);

        this.ds.viewport = this.viewport;
        var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        // move mouse move event to the window in case it drags outside of the canvas
        if(!this.options.skip_events) {
            this.canvas.removeEventListener("pointermove", this._mousemove_callback);
            ref_window.document.addEventListener("pointermove", this._mousemove_callback,true); // catch for the entire window
            ref_window.document.addEventListener("pointerup", this._mouseup_callback,true);
        }

        if(!is_inside) {
            return;
        }

        var node = this.graph.getNodeOnPos( e.canvasX, e.canvasY, this.visible_nodes, 5 );
        var skip_action = false;
        var now = LiteGraph.getTime();
        var is_primary = (e.isPrimary === undefined || e.isPrimary);
        var is_double_click = (now - this.last_mouseclick < 300) && is_primary;
        this.mouse[0] = e.clientX;
        this.mouse[1] = e.clientY;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;
        this.last_click_position = [this.mouse[0],this.mouse[1]];

        if (this.pointer_is_down && is_primary ) {
            this.pointer_is_double = true;
            LiteGraph.log_verbose("pointerevents: pointer_is_double start");
        }else{
            this.pointer_is_double = false;
        }
        this.pointer_is_down = true;
        this.canvas.focus();
        
        LiteGraph.ContextMenuClass.closeAll(ref_window);
        
        // if (this.onMouse?.(e))
        //     return;

        // TAG callback graphrenderer event entrypoint
        var cbRet = this.processCallbackHandlers("onClear",{
            def_cb: this.onMouse
        }, e );
        if((typeof(cbRet)!="undefined" && cbRet!==null) && (cbRet === false || (typeof(cbRet)=="object" && cbRet.return_value === false))){
            LiteGraph.log_info("lgraphcanvas", "processMouseDown", "callback prevents continue");
            return;
        }

        // left button mouse / single finger
        if (e.which == 1 && !this.userInput_isNotPrimary) {

            if (e.ctrlKey) {
                LiteGraph.log_debug("lgraphcanvas", "processMouseDown","starting box selection");
                this.dragging_rectangle = new Float32Array(4);
                this.dragging_rectangle[0] = e.canvasX;
                this.dragging_rectangle[1] = e.canvasY;
                this.dragging_rectangle[2] = 1;
                this.dragging_rectangle[3] = 1;
                skip_action = true;
            }

            // clone node ALT dragging
            if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && node && this.allow_interaction && !skip_action && !this.read_only) {
                LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "cloning node");
                let original_node = node;
                let cloned = node.clone();
                if (cloned) {
                    cloned.pos[0] += 5;
                    cloned.pos[1] += 5;
                    this.graph.add(cloned,false,{doCalcSize: false});
                    node = cloned;

                    if( LiteGraph.alt_shift_drag_connect_clone_with_input && e.shiftKey ) {
                        // process links
                        LiteGraph.log_verbose("lgraphcanvas", "processMouseDown", "altCloned",original_node,node);
                        if (original_node.inputs && original_node.inputs.length) {
                            // DBG("cycle original inputs",original_node.inputs);
                            for (var j = 0; j < original_node.inputs.length; ++j) {
                                var input = original_node.inputs[j];
                                if (!input || input.link == null) {
                                    // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "processMouseDown", "alt drag cloning", "not input link",input);
                                    continue;
                                }
                                var ob_link = this.graph.links[input.link];
                                if (!ob_link) {
                                    LiteGraph.log_warn("lgraphcanvas", "processMouseDown", "not graph link info for input",input,original_node);
                                    continue;
                                }
                                if (ob_link.type === LiteGraph.EVENT) {
                                    // TODO put a sequencer in the middle or implement multi input
                                    LiteGraph.log_info("lgraphcanvas", "processMouseDown", "alt drag cloning", "skip moving events",input);
                                    continue;
                                }
                                var source_node;
                                if (ob_link.origin_id) {
                                    source_node = this.graph.getNodeById(ob_link.origin_id);
                                }
                                var target_node = node;
                                if( source_node && target_node ) {
                                    LiteGraph.log_verbose("lgraphcanvas", "processMouseDown", "alt drag cloning", "connect newly created",source_node,target_node,ob_link);
                                    // DBG LiteGraph.log_info("connect cloned node",ob_link.origin_slot, target_node, ob_link.target_slot);
                                    source_node.connect(ob_link.origin_slot, target_node, ob_link.target_slot);
                                }
                            }
                        }
                    }

                    skip_action = true;
                    if (!block_drag_node) {
                        if (this.allow_dragnodes) {
                            this.graph.beforeChange();
                            this.node_dragged = node;
                        }
                        if (!this.selected_nodes[node.id]) {
                            this.processNodeSelected(node, e);
                        }
                    }
                }
            }

            var clicking_canvas_bg = false;

            // when clicked on top of a node
            // and it is not interactive
            // or action skipped or read_only
            if (node && (this.allow_interaction || node.flags.allow_interaction) && !skip_action && !this.read_only) {
                LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicking on node");
                if (!this.live_mode && !node.flags.pinned) {
                    this.bringToFront(node);
                } // if it wasn't selected?

                // not dragging mouse to connect two slots
                // interaction allowed, not collpased, not live_mode
                if ( this.allow_interaction && !this.connecting_node && !node.flags.collapsed && !this.live_mode ) {
                    // Search for corner for resize
                    if ( !skip_action &&
                        node.resizable !== false &&
                        LiteGraph.isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 9,
                            node.pos[1] + node.size[1] - 9,
                            18,
                            18,
                        )
                    ) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "start resizing node");
                        this.graph.beforeChange();
                        this.resizing_node = node;
                        this.canvas.style.cursor = "se-resize";
                        skip_action = true;
                    } else {
                        // search for outputs
                        if (node.outputs) {
                            for ( let i = 0, l = node.outputs.length; i < l; ++i ) {
                                let output = node.outputs[i];
                                let link_pos = node.getConnectionPos(false, i);
                                if (
                                    LiteGraph.isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20,
                                    )
                                ) {
                                    this.connecting_node = node;
                                    this.connecting_output = output;
                                    this.connecting_output.slot_index = i;
                                    this.connecting_pos = node.getConnectionPos( false, i );
                                    this.connecting_slot = i;
                                    LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked on output slot", node, output);
                                    
                                    if (LiteGraph.shift_click_do_break_link_from) {
                                        // break with shift
                                        if (e.shiftKey) {
                                            node.disconnectOutput(i);
                                        }
                                    }else{
                                        // move with shift
                                        if (e.shiftKey) { // || this.move_source_link_without_shift
                                            LiteGraph.log_debug("lgraphcanvas","processMouseDown","will move link source slot"
                                                    ,this.connecting_node
                                                    ,this.connecting_slot
                                                    ,this.connecting_output
                                                    ,this.connecting_pos);

                                            // this.connecting_node
                                            // this.connecting_output

                                            var aOLinks = [];
                                            var aONodes = [];
                                            var aOSlots = [];
                                            var aConnectingInputs = [];
                                            if (output.links !== null && output.links.length) {
                                                for(let il in output.links){
                                                    let oNodeX = false;
                                                    let oLnkX = this.graph.links[output.links[il]];
                                                    if(oLnkX && this.graph._nodes_by_id[oLnkX.target_id]){
                                                        oNodeX = this.graph._nodes_by_id[oLnkX.target_id];
                                                        if(oNodeX){
                                                            aOLinks.push(oLnkX);
                                                            aONodes.push(oNodeX);
                                                            aOSlots.push(oLnkX.target_slot);
                                                            aConnectingInputs.push({node: oNodeX, slot: oLnkX.target_slot, link: oLnkX});
                                                        }
                                                    }
                                                }
                                            }

                                            // WIP implemented multi links ....
                                            // TODO use a trick for now: visually dragging one and check ther rest later on

                                            if(aOLinks.length){
                                                // should disconnect output
                                                node.disconnectOutput(i);
                                                this.connecting_output = false;

                                                this.connecting = {inputs: aConnectingInputs};
                                                LiteGraph.log_debug("lgraphcanvas","processMouseDown","moving links source slot",this.connecting);

                                                let link_info = aOLinks[0];
                                                this.connecting_node = this.graph._nodes_by_id[link_info.target_id];
                                                this.connecting_slot = link_info.target_slot;
                                                this.connecting_input = this.connecting_node.inputs[this.connecting_slot];
                                                // this.connecting_input.slot_index = this.connecting_slot;
                                                this.connecting_pos = this.connecting_node.getConnectionPos( true, this.connecting_slot );
                                                this.dirty_bgcanvas = true;
                                                skip_action = true;
                                            }
                                        }
                                    }

                                    if (is_double_click) {
                                        // TAG callback node event entrypoint
                                        node.processCallbackHandlers("onOutputDblClick",{
                                            def_cb: node.onOutputDblClick
                                        }, i, e );
                                    } else {
                                        // TAG callback node event entrypoint
                                        node.processCallbackHandlers("onOutputClick",{
                                            def_cb: node.onOutputClick
                                        }, i, e );
                                    }

                                    skip_action = true;
                                    break;
                                }
                            }
                        }

                        // search for inputs
                        if (node.inputs) {
                            for ( let i = 0, l = node.inputs.length; i < l; ++i ) {
                                let input = node.inputs[i];
                                let link_pos = node.getConnectionPos(true, i);
                                if (
                                    LiteGraph.isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20,
                                    )
                                ) {
                                    LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked on input slot", node, input);
                                    if (is_double_click) {
                                        // TAG callback node event entrypoint
                                        node.processCallbackHandlers("onInputDblClick",{
                                            def_cb: node.onInputDblClick
                                        }, i, e );
                                    } else {
                                        // TAG callback node event entrypoint
                                        node.processCallbackHandlers("onInputClick",{
                                            def_cb: node.onInputDblClick
                                        }, i, e );
                                    }

                                    if (input.link !== null) {
                                        var link_info = this.graph.links[
                                            input.link
                                        ]; // before disconnecting
                                        if (LiteGraph.click_do_break_link_to) {
                                            node.disconnectInput(i);
                                            this.dirty_bgcanvas = true;
                                            skip_action = true;
                                        }else{
                                            // do same action as has not node ?
                                        }

                                        if (
                                            // this.allow_reconnect_links ||
                                            // this.move_destination_link_without_shift ||
                                            e.shiftKey
                                        ) {
                                            if (!LiteGraph.click_do_break_link_to) {
                                                node.disconnectInput(i);
                                            }
                                            this.connecting_node = this.graph._nodes_by_id[link_info.origin_id];
                                            this.connecting_slot = link_info.origin_slot;
                                            this.connecting_output = this.connecting_node.outputs[this.connecting_slot];
                                            this.connecting_pos = this.connecting_node.getConnectionPos( false, this.connecting_slot );
                                            LiteGraph.log_debug("lgraphcanvas","processMouseDown","moving link destination slot",this.connecting_node,this.connecting_slot,this.connecting_output,this.connecting_pos);
                                            this.dirty_bgcanvas = true;
                                            skip_action = true;
                                        }


                                    }else{
                                        // has not node
                                    }

                                    if (!skip_action) {
                                        // connect from in to out, from to to from
                                        this.connecting_node = node;
                                        this.connecting_input = input;
                                        this.connecting_input.slot_index = i;
                                        this.connecting_pos = node.getConnectionPos( true, i );
                                        this.connecting_slot = i;

                                        this.dirty_bgcanvas = true;
                                        skip_action = true;
                                    }
                                }
                            }
                        }
                    } // not resizing
                }

                // it wasn't clicked on the links boxes, nor on slots
                if (!skip_action) {
                    LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "check clicked on node", node);
                    var block_drag_node = false;
                    var pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];

                    // widgets
                    var widget = this.processNodeWidgets( node, this.graph_mouse, e );
                    if (widget) {
                        block_drag_node = true;
                        this.node_widget = [node, widget];
                    }

                    let cbRet = null;

                    // double clicking
                    if (this.allow_interaction && is_double_click && this.selected_nodes[node.id]) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "double clicked on node", node);
                        // TAG callback node event entrypoint
                        cbRet = node.processCallbackHandlers("onDblClick",{
                            def_cb: node.onDblClick
                        }, e, pos, this );
                        if ( cbRet!==null && (cbRet === true || (typeof(cbRet)=="object" && cbRet.return_value)) ) {
                            LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "dragging blocked by onDblClick", cbRet);
                        }else{
                            this.processNodeDblClicked(node);
                        }
                        block_drag_node = true;
                    }

                    // TAG callback node event entrypoint
                    cbRet = node.processCallbackHandlers("onMouseDown",{
                        def_cb: node.onMouseDown
                    }, e, pos, this );
                    
                    // if do not capture mouse
                    if ( cbRet!==null && (cbRet === true || (typeof(cbRet)=="object" && cbRet.return_value)) ) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "dragging blocked by onMouseDownCbRet", cbRet);
                        block_drag_node = true;
                    } else {
                        // open subgraph button
                        if(node.subgraph && !node.skip_subgraph_button) {
                            LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked on subgraph");
                            if ( !node.flags.collapsed && pos[0] > node.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0 ) {
                                setTimeout(() => {
                                    this.openSubgraph(node.subgraph);
                                }, 10);
                            }
                        }

                        if (this.live_mode) {
                            clicking_canvas_bg = true;
                            block_drag_node = true;
                        }
                    }

                    if (!block_drag_node) {
                        if (this.allow_dragnodes) {
                            LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "started dragging",node);
                            this.graph.beforeChange();
                            this.node_dragged = node;
                        }
                        this.processNodeSelected(node, e);
                    } else {
                        /**
                         * Don't call the function if the block is already selected.
                         * Otherwise, it could cause the block to be unselected while its panel is open.
                         */
                        if (!node.is_selected){
                            LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "node selected",node);
                            this.processNodeSelected(node, e);
                        }
                    }

                    this.dirty_canvas = true;
                }
            } else { // clicked outside of nodes
                LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked outside nodes");
                if (!skip_action) {

                    // search for mouseDown on LINKS
                    if(!this.read_only) {
                        for (let i = 0; i < this.visible_links.length; ++i) {
                            var link = this.visible_links[i];
                            var center = link._pos;
                            if (
                                !center ||
                                e.canvasX < center[0] - 4 ||
                                e.canvasX > center[0] + 4 ||
                                e.canvasY < center[1] - 4 ||
                                e.canvasY > center[1] + 4
                            ) {
                                continue;
                            }
                            LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked on link",link);
                            // link clicked
                            this.showLinkMenu(link, e);
                            this.over_link_center = null; // clear tooltip
                            break;
                        }
                    }

                    // search for mouseDown on GROUPS
                    this.selected_group = this.graph.getGroupOnPos( e.canvasX, e.canvasY );
                    this.selected_group_resizing = false;
                    if (this.selected_group && !this.read_only ) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "clicked on group",link);
                        if (e.ctrlKey) {
                            this.dragging_rectangle = null;
                        }

                        var dist = LiteGraph.distance( [e.canvasX, e.canvasY], [ this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1] ] );
                        if (dist * this.ds.scale < this.options.groups_triangle_handler_size) {
                            this.selected_group_resizing = true;
                        } else {
                            this.selected_group.recomputeInsideNodes();
                        }
                    }

                    if (is_double_click && !this.read_only && this.allow_searchbox) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "showing search box");
                        this.showSearchBox(e);
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    LiteGraph.log_debug("DEBUG canvas click is_double_click,this.allow_searchbox",is_double_click,this.allow_searchbox);
                    clicking_canvas_bg = true;
                }
            }

            if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
                LiteGraph.log_debug("lgraphcanvas", "processMouseDown", "dragging_canvas start");
                this.dragging_canvas = true;
            }

        } else if (e.which == 2) {
            // middle button

            if (LiteGraph.middle_click_slot_add_default_node) {
                if (node && this.allow_interaction && !skip_action && !this.read_only) {
                    // not dragging mouse to connect two slots
                    if (
                        !this.connecting_node &&
                        !node.flags.collapsed &&
                        !this.live_mode
                    ) {
                        var mClikSlot = false;
                        var mClikSlot_index = false;
                        var mClikSlot_isOut = false;
                        // search for outputs
                        if (node.outputs) {
                            for ( let i = 0, l = node.outputs.length; i < l; ++i ) {
                                var output = node.outputs[i];
                                let link_pos = node.getConnectionPos(false, i);
                                if (LiteGraph.isInsideRectangle(e.canvasX,e.canvasY,link_pos[0] - 15,link_pos[1] - 10,30,20)) {
                                    mClikSlot = output;
                                    mClikSlot_index = i;
                                    mClikSlot_isOut = true;
                                    break;
                                }
                            }
                        }

                        // search for inputs
                        if (node.inputs) {
                            for ( let i = 0, l = node.inputs.length; i < l; ++i ) {
                                let input_clk = node.inputs[i];
                                let link_pos = node.getConnectionPos(true, i);
                                if (LiteGraph.isInsideRectangle(e.canvasX,e.canvasY,link_pos[0] - 15,link_pos[1] - 10,30,20)) {
                                    mClikSlot = input_clk;
                                    mClikSlot_index = i;
                                    mClikSlot_isOut = false;
                                    break;
                                }
                            }
                        }
                        LiteGraph.log_verbose("middleClickSlots? "+mClikSlot+" & "+(mClikSlot_index!==false));
                        if (mClikSlot && mClikSlot_index!==false) {

                            var alphaPosY = 0.5-((mClikSlot_index+1)/((mClikSlot_isOut?node.outputs.length:node.inputs.length)));
                            var node_bounding = node.getBounding();
                            // estimate a position: this is a bad semi-bad-working mess .. REFACTOR with a correct autoplacement that knows about the others slots and nodes
                            var posRef = [
                                (!mClikSlot_isOut?node_bounding[0]:node_bounding[0]+node_bounding[2]),// + node_bounding[0]/this.canvas.width*150
                                e.canvasY-80,// + node_bounding[0]/this.canvas.width*66 // vertical "derive"
                            ];
                            this.createDefaultNodeForSlot({
                                nodeFrom: !mClikSlot_isOut?null:node,
                                slotFrom: !mClikSlot_isOut?null:mClikSlot_index,
                                nodeTo: !mClikSlot_isOut?node:null,
                                slotTo: !mClikSlot_isOut?mClikSlot_index:null,
                                position: posRef, // ,e: e
                                nodeType: "AUTO", // nodeNewType
                                posAdd: [!mClikSlot_isOut?-30:30, -alphaPosY*130], // -alphaPosY*30]
                                posSizeFix: [!mClikSlot_isOut?-1:0, 0], // -alphaPosY*2*/
                            });

                        }
                    }
                }
            } else if (!skip_action && this.allow_dragcanvas) {
                LiteGraph.log_verbose("pointerevents: dragging_canvas start from middle button");
                this.dragging_canvas = true;
            }


        } else if (e.which == 3 || (LiteGraph.two_fingers_opens_menu && this.userInput_isNotPrimary)) {

            // right button
            if (this.allow_interaction && !skip_action && !this.read_only) {

                // is it hover a node ?
                if (node) {
                    if(Object.keys(this.selected_nodes).length
                        && (this.selected_nodes[node.id] || e.shiftKey || e.ctrlKey || e.metaKey)
                    ) {
                        // is multiselected or using shift to include the now node
                        if (!this.selected_nodes[node.id]) this.selectNodes([node],true); // add this if not present
                    }else{
                        // update selection
                        this.selectNodes([node]);
                    }
                }

                // show menu on this node
                this.processContextMenu(node, e);
            }

        }

        // TODO
        // if(this.node_selected != prev_selected)
        //	this.onNodeSelectionChange(this.node_selected);

        this.last_mouse[0] = e.clientX;
        this.last_mouse[1] = e.clientY;
        this.last_mouseclick = LiteGraph.getTime();
        this.last_mouse_dragging = true;

        /*
        if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
            this.draw();
        */

        this.graph.change();

        // this is to ensure to defocus(blur) if a text input element is on focus
        if (
            !ref_window.document.activeElement ||
            (   ref_window.document.activeElement.nodeName.toLowerCase() != "input"
                && ref_window.document.activeElement.nodeName.toLowerCase() != "textarea"
            )
        ) {
            e.preventDefault();
        }
        e.stopPropagation();
        // TAG callback graphrenderer event entrypoint
        this.processCallbackHandlers("onMouseDown",{
            def_cb: this.onMouseDown
        }, e );
        return false;
    }

    /**
     * Called when a mouse move event has to be processed
     * @method processMouseMove
     **/
    processMouseMove(e) {
        if (this.autoresize) {
            this.resize(); // ? really ? every mouse move ? TODO move this
        }

        if( this.set_canvas_dirty_on_mouse_event ){
            this.dirty_canvas = true;
        }

        if (!this.graph) {
            LiteGraph.log_warn("lgraphcanvas", "processMouseMove", "no canvas ref");
            return;
        }

        LGraphCanvas.active_canvas = this;
        this.adjustMouseEvent(e);
        var mouse = [e.clientX, e.clientY];
        this.mouse[0] = mouse[0];
        this.mouse[1] = mouse[1];
        var delta = [
            mouse[0] - this.last_mouse[0],
            mouse[1] - this.last_mouse[1],
        ];
        this.last_mouse = mouse;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;

        // DBG EXCESS LiteGraph.log_verbose("pointerevents: processMouseMove "+e.pointerId+" "+e.isPrimary);

        // TODO CHECK ensure block_click should prevent all following 
        if(this.block_click) {
            LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "block_click");
            e.preventDefault();
            return false;
        }

        this.over_widget = false; // will set again later on here

        e.dragging = this.last_mouse_dragging;

        // pass event to active widget (previously)clicked
        if (this.node_widget) {
            this.processNodeWidgets(
                this.node_widget[0],
                this.graph_mouse,
                e,
                this.node_widget[1],
            );
            this.dirty_canvas = true;
        }

        // get node over
        var node = this.graph.getNodeOnPos(e.canvasX,e.canvasY,this.visible_nodes);
        this.over_node = node;
        
        if (this.dragging_rectangle) {
            LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "making rectangle");
            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
            this.dirty_canvas = true;
        } else if (this.selected_group && !this.read_only) {
            // moving/resizing a group
            if (this.selected_group_resizing) {
                LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "resizing group");
                this.selected_group.size = [
                    e.canvasX - this.selected_group.pos[0],
                    e.canvasY - this.selected_group.pos[1],
                ];
            } else {
                LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "dragging group");
                var deltax = delta[0] / this.ds.scale;
                var deltay = delta[1] / this.ds.scale;
                this.selected_group.move(deltax, deltay, e.ctrlKey);
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
                if(deltax || deltay){
                    this.processCallbackHandlers("onGroupMoving",{
                        def_cb: this.onGroupMoving
                    }, this.selected_group, deltax, deltay );
                }
            }
            this.dirty_bgcanvas = true;
        } else if (this.dragging_canvas) {
            LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "dragging_canvas");
            this.ds.offset[0] += delta[0] / this.ds.scale;
            this.ds.offset[1] += delta[1] / this.ds.scale;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
        } else if ((this.allow_interaction || (node && node.flags.allow_interaction)) && !this.read_only) {
            if (this.connecting_node) {
                this.dirty_canvas = true;
            }

            // remove mouseover flag
            for (let i = 0, l = this.graph._nodes.length; i < l; ++i) {
                if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i] ) {
                    // mouse leave
                    this.graph._nodes[i].mouseOver = false;
                    if (this.node_over) {
                        // TAG callback node event entrypoint
                        this.node_over.processCallbackHandlers("onMouseLeave",{
                            def_cb: this.node_over.onMouseLeave
                        }, e );
                    }
                    this.node_over = null;
                    this.dirty_canvas = true;
                }
            }

            // mouse over a node
            if (node) {

                if(node.redraw_on_mouse)
                    this.dirty_canvas = true;

                // this.canvas.style.cursor = "move";
                if (!node.mouseOver) {
                    // mouse enter
                    node.mouseOver = true;
                    this.node_over = node;
                    this.dirty_canvas = true;
                    // TAG callback node event entrypoint
                    node.processCallbackHandlers("onMouseEnter",{
                        def_cb: node.onMouseEnter
                    }, e );
                }

                // in case the node wants to do something
                // TAG callback node event entrypoint
                node.processCallbackHandlers("onMouseMove",{
                    def_cb: node.onMouseMove
                }, e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this );

                // TODO replace processNodeWidgets for dedicated method to just checking overing: implement int processNodeWidgets too
                var widgetOver = this.processNodeWidgets( node, this.graph_mouse ); // not passing event! just check, e );
                if (widgetOver){
                    this.over_widget = widgetOver;
                }

                // if dragging a link
                if (this.connecting_node) {
                    let pos;
                    if (this.connecting_output) {

                        pos = this._highlight_input || [0, 0]; // to store the output of isOverNodeInput

                        // on top of input
                        if (!this.isOverNodeBox(node, e.canvasX, e.canvasY)) {
                            // check if I have a slot below de mouse
                            let slot = this.isOverNodeInput( node, e.canvasX, e.canvasY, pos );
                            if (slot != -1 && node.inputs[slot]) {
                                let slot_type = node.inputs[slot].type;
                                if ( LiteGraph.isValidConnection( this.connecting_output.type, slot_type ) ) {
                                    this._highlight_input = pos;
                                    this._highlight_input_slot = node.inputs[slot]; // @TODO CHECK THIS
                                }
                            } else {
                                this._highlight_input = null;
                                this._highlight_input_slot = null; // @TODO CHECK THIS
                            }
                        }

                    }else if(this.connecting_input) {

                        pos = this._highlight_output || [0, 0]; // to store the output of isOverNodeOutput

                        // on top of output
                        if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {
                            // check if I have a slot below de mouse
                            let slot = this.isOverNodeOutput( node, e.canvasX, e.canvasY, pos );
                            if (slot != -1 && node.outputs[slot]) {
                                let slot_type = node.outputs[slot].type;
                                if ( LiteGraph.isValidConnection( this.connecting_input.type, slot_type ) ) {
                                    this._highlight_output = pos;
                                }
                            } else {
                                this._highlight_output = null;
                            }
                        }
                    }
                }

                // Search for corner
                if (this.canvas) {
                    if (
                        LiteGraph.isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 5,
                            node.pos[1] + node.size[1] - 5,
                            5,
                            5,
                        )
                    ) {
                        this.canvas.style.cursor = "se-resize";
                    } else {
                        this.canvas.style.cursor = "crosshair";
                    }
                }
            } else { // not over a node

                // search for link connector
                var over_link = null;
                for (let i = 0; i < this.visible_links.length; ++i) {
                    var link = this.visible_links[i];
                    var center = link._pos;
                    if (
                        !center ||
                        e.canvasX < center[0] - 4 ||
                        e.canvasX > center[0] + 4 ||
                        e.canvasY < center[1] - 4 ||
                        e.canvasY > center[1] + 4
                    ) {
                        continue;
                    }
                    over_link = link;
                    break;
                }
                if( over_link != this.over_link_center ) {
                    this.over_link_center = over_link;
                    this.dirty_canvas = true;
                }

                if (this.canvas) {
                    this.canvas.style.cursor = "";
                }
            } // end

            // send event to node if capturing input (used with widgets that allow drag outside of the area of the node)
            if ( this.node_capturing_input && this.node_capturing_input != node ) {
                // TAG callback node event entrypoint
                this.node_capturing_input.processCallbackHandlers("onMouseMove",{
                    def_cb: this.node_capturing_input.onMouseMove
                }, e,[e.canvasX - this.node_capturing_input.pos[0],e.canvasY - this.node_capturing_input.pos[1]], this );
            }

            // node being dragged
            if (this.node_dragged && !this.live_mode) {
                LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "draggin!",this.selected_nodes);
                for (let i in this.selected_nodes) {
                    let n = this.selected_nodes[i];
                    let off = [delta[0] / this.ds.scale, delta[1] / this.ds.scale];
                    n.pos[0] += off[0];
                    n.pos[1] += off[1];
                    if (!n.is_selected) this.processNodeSelected(n, e);
                    // Don't call the function if the block is already selected. Otherwise, it could cause the block to be unselected while dragging.
                    n.processCallbackHandlers("onDrag",{
                        def_cb: n.onDrag
                    }, off );
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }

            if (this.resizing_node && !this.live_mode) {
                // convert mouse to node space
                var desired_size = [ e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1] ];
                var min_size = this.free_resize?LiteGraph.NODE_MIN_SIZE:this.resizing_node.computeSize(); //this.resizing_node.size_basic; // .computeSize();
                desired_size[0] = Math.max( min_size[0], desired_size[0] );
                desired_size[1] = Math.max( min_size[1], desired_size[1] );
                this.resizing_node.setSize( desired_size );

                this.canvas.style.cursor = "se-resize";
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }
        }else{
            if(this.read_only){
                LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "canvas is read only", this);
            }else{
                // interaction not allowed
                LiteGraph.log_verbose("lgraphcanvas", "processMouseMove", "interaction not allowed (nor canvas and node)", this.allow_interaction, node.flags);
            } 
        }

        e.preventDefault();
        return false;
    }

    /**
     * Called when a mouse up event has to be processed
     * @method processMouseUp
     **/
    processMouseUp(e) {

        var is_primary = ( e.isPrimary === undefined || e.isPrimary );

        // early exit for extra pointer
        if(!is_primary) {
            /* e.stopPropagation();
            e.preventDefault();*/
            LiteGraph.log_verbose("pointerevents: processMouseUp pointerN_stop "+e.pointerId+" "+e.isPrimary);
            return false;
        }

        LiteGraph.log_verbose("pointerevents: processMouseUp "+e.pointerId+" "+e.isPrimary+" :: "+e.clientX+" "+e.clientY);

        if( this.set_canvas_dirty_on_mouse_event )
            this.dirty_canvas = true;

        if (!this.graph)
            return;

        var window = this.getCanvasWindow();
        var document = window.document;
        LGraphCanvas.active_canvas = this;

        // restore the mousemove event back to the canvas
        if(!this.options.skip_events) {
            LiteGraph.log_verbose("pointerevents: processMouseUp adjustEventListener");
            document.removeEventListener("pointermove", this._mousemove_callback,true);
            this.canvas.addEventListener("pointermove", this._mousemove_callback);
            document.removeEventListener("pointerup", this._mouseup_callback,true);
        }

        this.adjustMouseEvent(e);
        var now = LiteGraph.getTime();
        e.click_time = now - this.last_mouseclick;
        this.last_mouse_dragging = false;
        this.last_click_position = null;

        if(this.block_click) {
            LiteGraph.log_verbose("pointerevents: processMouseUp block_clicks");
            this.block_click = false; // used to avoid sending twice a click in a immediate button
        }

        LiteGraph.log_verbose("pointerevents: processMouseUp which: "+e.which);

        if (e.which == 1) {

            if( this.node_widget ) {
                this.processNodeWidgets( this.node_widget[0], this.graph_mouse, e );
            }

            // left button
            this.node_widget = null;

            if (this.selected_group) {
                var diffx =
                    this.selected_group.pos[0] -
                    Math.round(this.selected_group.pos[0]);
                var diffy =
                    this.selected_group.pos[1] -
                    Math.round(this.selected_group.pos[1]);
                this.selected_group.move(diffx, diffy, e.ctrlKey);
                this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);
                this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
                
                this.selected_group.recomputeInsideNodes();

                if(this.selected_group_resizing){
                    this.processCallbackHandlers("onGroupResized",{
                        def_cb: this.onGroupResized
                    }, this.selected_group );
                    this.graph.onGraphChanged({action: "groupResize", doSave: true});
                    this.graph.afterChange(); // this.selected_group
                }else{
                    if(diffx || diffy){
                        this.processCallbackHandlers("onGroupMoved",{
                            def_cb: this.onGroupMoved
                        }, this.selected_group );
                        this.graph.onGraphChanged({action: "groupMove", doSave: true});
                        this.graph.afterChange(); // this.selected_group
                    }
                }
                this.selected_group = null;
            }
            this.selected_group_resizing = false;

            var node = this.graph.getNodeOnPos(
                e.canvasX,
                e.canvasY,
                this.visible_nodes,
            );

            if (this.dragging_rectangle) {
                if (this.graph) {
                    var nodes = this.graph._nodes;
                    var node_bounding = new Float32Array(4);

                    // compute bounding and flip if left to right
                    var w = Math.abs(this.dragging_rectangle[2]);
                    var h = Math.abs(this.dragging_rectangle[3]);
                    var startx =
                        this.dragging_rectangle[2] < 0
                            ? this.dragging_rectangle[0] - w
                            : this.dragging_rectangle[0];
                    var starty =
                        this.dragging_rectangle[3] < 0
                            ? this.dragging_rectangle[1] - h
                            : this.dragging_rectangle[1];
                    this.dragging_rectangle[0] = startx;
                    this.dragging_rectangle[1] = starty;
                    this.dragging_rectangle[2] = w;
                    this.dragging_rectangle[3] = h;

                    // test dragging rect size, if minimun simulate a click
                    if (!node || (w > 10 && h > 10 )) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseUp", "computing box selection for nodes", this.dragging_rectangle);
                        // test against all nodes (not visible because the rectangle maybe start outside
                        var to_select = [];
                        for (let i = 0; i < nodes.length; ++i) {
                            var nodeX = nodes[i];
                            nodeX.getBounding(node_bounding);
                            if (
                                !LiteGraph.overlapBounding(
                                    this.dragging_rectangle,
                                    node_bounding,
                                )
                            ) {
                                continue;
                            } // out of the visible area
                            to_select.push(nodeX);
                        }
                        if (to_select.length) {
                            LiteGraph.log_debug("lgraphcanvas", "processMouseUp", "selecting nodes", to_select);
                            this.selectNodes(to_select,e.shiftKey); // add to selection with shift
                        }
                    }else{
                        // will select of update selection
                        this.selectNodes([node],e.shiftKey||e.ctrlKey); // add to selection add to selection with ctrlKey or shiftKey
                    }

                }
                this.dragging_rectangle = null;
            } else if (this.connecting_node) {
                // dragging a connection
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;

                var connInOrOut = this.connecting_output || this.connecting_input;
                var connType = connInOrOut.type;

                node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes,
                );

                // node below mouse
                if (node) {

                    // slot below mouse? connect
                    let slot;
                    if (this.connecting_output) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseUp", "connecting_output", this.connecting_output, "connecting_node", this.connecting_node, "connecting_slot", this.connecting_slot);
                        slot = this.isOverNodeInput(
                            node,
                            e.canvasX,
                            e.canvasY,
                        );
                        if (slot != -1) {
                            this.connecting_node.connect(this.connecting_slot, node, slot);
                        } else {
                            // not on top of an input
                            // look for a good slot
                            this.connecting_node.connectByType(this.connecting_slot,node,connType);
                        }

                    }else if (this.connecting_input) {
                        LiteGraph.log_debug("lgraphcanvas", "processMouseUp", "connecting_input", this.connecting_input, "connecting_node", this.connecting_node, "connecting_slot", this.connecting_slot);
                        slot = this.isOverNodeOutput(
                            node,
                            e.canvasX,
                            e.canvasY,
                        );

                        if (slot != -1) {

                            if(this.connecting && this.connecting.inputs){
                                // multi connect
                                for(let iC in this.connecting.inputs){
                                    node.connect(slot, this.connecting.inputs[iC].node, this.connecting.inputs[iC].slot);
                                }
                            }else{
                                // default single connect
                                node.connect(slot, this.connecting_node, this.connecting_slot); // this is inverted has output-input nature like
                            }

                        } else {
                            // not on top of an input
                            // look for a good slot
                            this.connecting_node.connectByTypeOutput(this.connecting_slot,node,connType);
                        }

                    }
                    // }
                }else{
                    // add menu when releasing link in empty space
                    if (LiteGraph.release_link_on_empty_shows_menu) {
                        if (e.shiftKey && this.allow_searchbox) {
                            if(this.connecting_output) {
                                this.showSearchBox(e,{node_from: this.connecting_node, slot_from: this.connecting_output, type_filter_in: this.connecting_output.type});
                            }else if(this.connecting_input) {
                                this.showSearchBox(e,{node_to: this.connecting_node, slot_from: this.connecting_input, type_filter_out: this.connecting_input.type});
                            }
                        }else{
                            if(this.connecting_output) {
                                this.showConnectionMenu({nodeFrom: this.connecting_node, slotFrom: this.connecting_output, e: e});
                            }else if(this.connecting_input) {
                                this.showConnectionMenu({nodeTo: this.connecting_node, slotTo: this.connecting_input, e: e});
                            }
                        }
                    }
                }

                this.connecting_output = null;
                this.connecting_input = null;
                this.connecting_pos = null;
                this.connecting_node = null;
                this.connecting_slot = -1;
                this.connecting = false;
            } else if (this.resizing_node) { // not dragging connection
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
                this.graph.afterChange(this.resizing_node);
                this.resizing_node = null;
            } else if (this.node_dragged) {
                // node being dragged?
                node = this.node_dragged;
                if (
                    node &&
                    e.click_time < 300 &&
                    LiteGraph.isInsideRectangle( e.canvasX, e.canvasY, node.pos[0], node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT )
                ) {
                    node.collapse();
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                if (this.graph.config.align_to_grid || this.align_to_grid ) {
                    this.node_dragged.alignToGrid();
                }
                // TAG callback graphrenderer event entrypoint
                this.processCallbackHandlers("onNodeMoved",{
                    def_cb: this.onNodeMoved
                }, this.node_dragged, this.selected_nodes );
                // multi nodes dragged ?
                for (let i in this.selected_nodes) {
                    let ndrg = this.selected_nodes[i];
                    ndrg.processCallbackHandlers("onMoved",{
                        def_cb: ndrg.onMoved
                    }, this.node_dragged, this.selected_nodes );
                }
                this.graph.onGraphChanged({action: "nodeDrag", doSave: true});
                this.graph.afterChange(this.node_dragged);
                this.node_dragged = null;
            } else { // no node being dragged
                // get node over
                node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes,
                );

                if (!node && e.click_time < 300) {
                    this.deselectAllNodes();
                }

                this.dirty_canvas = true;
                this.dragging_canvas = false;

                if (this.node_over) {
                    // TAG callback node event entrypoint
                    this.node_over.processCallbackHandlers("onMouseUp",{
                        def_cb: this.node_over.onMouseUp
                    }, e, [ e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1] ], this );
                }
                if ( this.node_capturing_input ) {
                    // TAG callback node event entrypoint
                    this.node_capturing_input.processCallbackHandlers("onMouseUp",{
                        def_cb: this.node_capturing_input.onMouseUp
                    }, e, [ e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1], ] );
                }
            }
        } else if (e.which == 2) {
            // middle button
            // trace("middle");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        } else if (e.which == 3) {
            // right button
            // trace("right");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        }

        /*
        if((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
            this.draw();
        */

        if (is_primary) {
            this.pointer_is_down = false;
            this.pointer_is_double = false;
        }

        this.graph.change();

        LiteGraph.log_verbose("pointerevents: processMouseUp stopPropagation");
        e.stopPropagation();
        e.preventDefault();
        return false;
    }

    /**
     * Called when a mouse wheel event has to be processed
     * @method processMouseWheel
     **/
    processMouseWheel = (e) => {
        if (!this.graph || !this.allow_dragcanvas) {
            return;
        }

        var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;

        this.adjustMouseEvent(e);

        var x = e.clientX;
        var y = e.clientY;
        var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
        if(!is_inside)
            return;

        var scale = this.ds.scale;

        if (delta > 0) {
            scale *= 1.1;
        } else if (delta < 0) {
            scale *= 1 / 1.1;
        }

        // TODO check this, probably should use DragAndScale instead
        // should check too that target is always the correct element when getting buondingBox
        // this.ds.changeScale(scale, [e.clientX, e.clientY]);
        var rect = e.target.getBoundingClientRect();
        this.setZoom( scale, [ e.clientX - rect.left, e.clientY - rect.top ] );

        this.graph.change();

        e.preventDefault();
        return false; // prevent default
    }

    /**
     * returns true if a position (in graph space) is on top of a node little corner box
     * @method isOverNodeBox
     **/
    isOverNodeBox(node, canvasx, canvasy) {
        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        if (
            LiteGraph.isInsideRectangle(
                canvasx,
                canvasy,
                node.pos[0] + 2,
                node.pos[1] + 2 - title_height,
                title_height - 4,
                title_height - 4,
            )
        ) {
            return true;
        }
        return false;
    }

    /**
     * returns the INDEX if a position (in graph space) is on top of a node input slot
     * @method isOverNodeInput
     **/
    isOverNodeInput(node, canvasx, canvasy, slot_pos) {
        if (node.inputs) {
            for (let i = 0, l = node.inputs.length; i < l; ++i) {
                var link_pos = node.getConnectionPos(true, i);
                var is_inside = false;
                if (node.horizontal) {
                    is_inside = LiteGraph.isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 5,
                        link_pos[1] - 10,
                        10,
                        20,
                    );
                } else {
                    is_inside = LiteGraph.isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        40,
                        10,
                    );
                }
                if (is_inside) {
                    if (slot_pos) {
                        slot_pos[0] = link_pos[0];
                        slot_pos[1] = link_pos[1];
                    }
                    return i;
                }
            }
        }
        return -1;
    }

    /**
     * returns the INDEX if a position (in graph space) is on top of a node output slot
     * @method isOverNodeOuput
     **/
    isOverNodeOutput(node, canvasx, canvasy, slot_pos) {
        if (node.outputs) {
            for (let i = 0, l = node.outputs.length; i < l; ++i) {
                var link_pos = node.getConnectionPos(false, i);
                var is_inside = false;
                if (node.horizontal) {
                    is_inside = LiteGraph.isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 5,
                        link_pos[1] - 10,
                        10,
                        20,
                    );
                } else {
                    is_inside = LiteGraph.isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        40,
                        10,
                    );
                }
                if (is_inside) {
                    if (slot_pos) {
                        slot_pos[0] = link_pos[0];
                        slot_pos[1] = link_pos[1];
                    }
                    return i;
                }
            }
        }
        return -1;
    }

    /**
     * process a key event
     * @method processKey
     **/
    /**
     * TODO : processKey replace static keys for config values
     * TODO : processKey save keys being down, fire single first keyDown instead of constantly pressed (use new event and promote that), clean on up
     * NOTE should use event.repeat meanwhile
     */
    processKey = (e) => {
        if (!this.graph) {
            return;
        }

        var block_default = false;
        let r = null;
        LiteGraph.log_verbose("lgraphcanvas","processKey",e);

        if (e.target.localName == "input") {
            return;
        }

        if (e.type == "keydown") {
            
            if (e.keyCode == 32) {
                // space
                this.dragging_canvas = true;
                block_default = true;
            }

            if (e.keyCode == 27) {
                // esc
                if(this.node_panel) this.node_panel.close();
                block_default = true;
            }

            // select all Control A
            if (e.keyCode == 65 && e.ctrlKey) {
                this.selectNodes();
                block_default = true;
            }

            if ((e.keyCode === 67) && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
                // copy
                if (this.selected_nodes) {
                    this.copyToClipboard();
                    block_default = true;
                }
            }

            if ((e.keyCode === 86) && (e.metaKey || e.ctrlKey)) {
                // paste
                this.pasteFromClipboard(e.shiftKey);
            }

            // delete or backspace
            if (e.keyCode == 46 || (LiteGraph.backspace_delete && e.keyCode == 8)) {
                if (
                    e.target.localName != "input" &&
                    e.target.localName != "textarea"
                ) {
                    this.deleteSelectedNodes();
                    block_default = true;
                }
            }

            // collapse
            // ...

            // ctlr+Z, ctlr+Y (or ctlr+shift+Z)
            if (LiteGraph.actionHistory_enabled) {
                if ((e.keyCode == 89 && e.ctrlKey) || (e.keyCode == 90 && e.ctrlKey && e.shiftKey)) {
                    // Y
                    this.graph.actionHistoryForward();
                }else if (e.keyCode == 90 && e.ctrlKey) {
                    // Z
                    this.graph.actionHistoryBack();
                }
            }

            if (Object.keys(this.selected_nodes).length) {
                for (let i in this.selected_nodes) {
                    // TAG callback node event entrypoint
                    // SHOULD check return value (block canvasProcess? block_default?)
                    r = this.selected_nodes[i].processCallbackHandlers("onKeyDown",{
                        def_cb: this.selected_nodes[i].onKeyDown
                    }, e );
                    // could a node stop replicating to the others ?
                    if(r!==null && (r===true || (typeof(r)=="object" && r.return_value===true))){
                        LiteGraph.log_debug("lgraphcanvas","processKey","onKeyDown has been processed with result true, prevent event bubbling");
                        block_default = true;
                    }
                }
            }

            // TAG callback GRAPHCANVAS event entrypoint
            // SHOULD check return value (block_default?)
            r = this.processCallbackHandlers("onKeyDown",{
                def_cb: this.onKeyDown
            }, e );
            if(r!==null && (r===true || (typeof(r)=="object" && r.return_value===true))){
                LiteGraph.log_debug("lgraphcanvas","processKey","onKeyDown has been processed with result true, prevent event bubbling");
                block_default = true;
            }else{
                LiteGraph.log_verbose("lgraphcanvas","processKey","onKeyDown processed by CB handlers",r);
            }

        } else if (e.type == "keyup") {
            if (e.keyCode == 32) {
                // space
                this.dragging_canvas = false;
            }

            if (this.selected_nodes) {
                for (let i in this.selected_nodes) {
                    // TAG callback node event entrypoint
                    // SHOULD check return value (block_default?)
                    this.selected_nodes[i].processCallbackHandlers("onKeyUp",{
                        def_cb: this.selected_nodes[i].onKeyUp
                    }, e );
                }
            }
        }

        this.graph.change();

        if (block_default) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return false;
        }
    }

    copyToClipboard() {
        var clipboard_info = {
            nodes: [],
            links: [],
        };
        var index = 0;
        var selected_nodes_array = [];
        for (let i in this.selected_nodes) {
            let node = this.selected_nodes[i];
            if (node.clonable === false)
                continue;
            node._relative_id = index;
            selected_nodes_array.push(node);
            index += 1;
        }

        for (let i = 0; i < selected_nodes_array.length; ++i) {
            let node = selected_nodes_array[i];
            if(node.clonable === false)
                continue;
            var cloned = node.clone();
            if(!cloned) {
                LiteGraph.log_warn("node type not found: " + node.type );
                continue;
            }
            clipboard_info.nodes.push(cloned.serialize());
            if (node.inputs && node.inputs.length) {
                for (var j = 0; j < node.inputs.length; ++j) {
                    var input = node.inputs[j];
                    if (!input || input.link == null) {
                        continue;
                    }
                    var link_info = this.graph.links[input.link];
                    if (!link_info) {
                        continue;
                    }
                    var target_node = this.graph.getNodeById(link_info.origin_id);
                    if (!target_node) {
                        continue;
                    }
                    clipboard_info.links.push([
                        target_node._relative_id,
                        link_info.origin_slot, // j,
                        node._relative_id,
                        link_info.target_slot,
                        target_node.id,
                    ]);
                }
            }
        }
        LiteGraph.log_verbose("copyToClipboard",clipboard_info);
        localStorage.setItem( "litegrapheditor_clipboard", JSON.stringify(clipboard_info), );
    }

    pasteFromClipboard(isConnectUnselected = false) {
        // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior
        if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
            return;
        }
        var data = localStorage.getItem("litegrapheditor_clipboard");
        if (!data) {
            return;
        }

        this.graph.beforeChange(); // TODO check and investigate beforeChange afterChange

        // create nodes
        var clipboard_info = JSON.parse(data);
        // calculate top-left node, could work without this processing but using diff with last node pos :: clipboard_info.nodes[clipboard_info.nodes.length-1].pos
        var posMin = false;
        var posMinIndexes = false;
        for (let i = 0; i < clipboard_info.nodes.length; ++i) {
            if (posMin) {
                if(posMin[0]>clipboard_info.nodes[i].pos[0]) {
                    posMin[0] = clipboard_info.nodes[i].pos[0];
                    posMinIndexes[0] = i;
                }
                if(posMin[1]>clipboard_info.nodes[i].pos[1]) {
                    posMin[1] = clipboard_info.nodes[i].pos[1];
                    posMinIndexes[1] = i;
                }
            } else{
                posMin = [clipboard_info.nodes[i].pos[0], clipboard_info.nodes[i].pos[1]];
                posMinIndexes = [i, i];
            }
        }
        var nodes = [];
        for (let i = 0; i < clipboard_info.nodes.length; ++i) {
            var node_data = clipboard_info.nodes[i];
            var node = LiteGraph.createNode(node_data.type);
            if (node) {
                node.configure(node_data);

                // paste in last known mouse position
                node.pos[0] += this.graph_mouse[0] - posMin[0]; // += 5;
                node.pos[1] += this.graph_mouse[1] - posMin[1]; // += 5;

                this.graph.add(node,{doProcessChange: false});

                nodes.push(node);
            }
        }

        // create links
        for (let i = 0; i < clipboard_info.links.length; ++i) {
            var link_info = clipboard_info.links[i];
            var origin_node = undefined;
            var origin_node_relative_id = link_info[0];
            if (origin_node_relative_id != null) {
                origin_node = nodes[origin_node_relative_id];
            } else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
                var origin_node_id = link_info[4];
                if (origin_node_id) {
                    origin_node = this.graph.getNodeById(origin_node_id);
                }
            }
            var target_node = nodes[link_info[2]];
            if( origin_node && target_node )
                origin_node.connect(link_info[1], target_node, link_info[3]);
            else
                LiteGraph.log_warn("Warning, nodes missing on pasting");
        }

        this.selectNodes(nodes);
        this.graph.onGraphChanged({action: "paste", doSave: true});
        this.graph.afterChange(); // TODO investigate and revise afterChange
    }

    /**
     * process a item drop event on top the canvas
     * @method processDrop
     **/
    processDrop = (e) => {
        e.preventDefault();
        this.adjustMouseEvent(e);

        let r = null;

        var x = e.clientX;
        var y = e.clientY;
        var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
        if(!is_inside) {
            LiteGraph.log_debug("graphcanvas processDrop","Outside viewport (client)",x,y);
            return;
        }

        x = e.localX;
        y = e.localY;
        is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
        if(!is_inside) {
            LiteGraph.log_debug("graphcanvas processDrop","Outside viewport (local)",x,y);
            return;
        }

        var pos = [e.canvasX, e.canvasY];
        var node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;

        LiteGraph.log_verbose("graphcanvas processDrop","going to process",pos,node);

        if (!node) {

            LiteGraph.log_verbose("lgraphcanvas", "processDrop", "look for drop implemetation in CANVAS", e);
            
            r = this.processCallbackHandlers("onDropItem",{
                def_cb: this.onDropItem
            }, e);
            if(r===null || !r || (typeof(r)=="object" && !r.return_value)){
                LiteGraph.log_verbose("lgraphcanvas", "processDrop", "running default implementation", e);
                this.checkDropItem(e);
                return r===null ? r : (typeof(r)=="object" ? r.return_value : r); // this is probably ignored
            }else{
                return r; // this is probably ignored
            }

        }else{
            
            // has dropped on node

            // check for dropped files
            var files = e.dataTransfer.files;
            if (files && files.length) {
                for (let i = 0; i < files.length; i++) {
                    var file = e.dataTransfer.files[0];
                    var filename = file.name;
                    
                    LiteGraph.log_debug("lgraphcanvas", "processDrop", "file on node", file);

                    // execute onDropFile on node
                    r = node.processCallbackHandlers("onDropFile",{
                        def_cb: node.onDropFile
                    }, file);

                    // if not getting a positive result, process file as data and call onDropData
                    if(!r || (typeof(r)=="object" && !r.return_value)){
                            
                        // prepare reader
                        var reader = new FileReader();
                        reader.onload = function(event) {
                            var data = event.target.result;
                            LiteGraph.log_debug("lgraphcanvas", "processDrop", "data on node", data, filename, file);
                            // execute onDropData on node
                            node.processCallbackHandlers("onDropData",{
                                def_cb: node.onDropData
                            }, data, filename, file);
                        };

                        // read data
                        var type = file.type.split("/")[0];
                        if (type == "text" || type == "") {
                            reader.readAsText(file);
                        } else if (type == "image") {
                            reader.readAsDataURL(file);
                        } else {
                            reader.readAsArrayBuffer(file);
                        }
                        
                    }

                }
            }

            // execute onDropItem on NODE
            r = node.processCallbackHandlers("onDropItem",{
                def_cb: node.onDropItem
            }, e);
            // if getting a positive result, return
            if(r === true || (typeof(r)=="object" && r.return_value)){
                return true;
            }

            // execute onDropItem on CANVAS
            r = this.processCallbackHandlers("onDropItem",{
                def_cb: this.onDropItem
            }, e);
            // if getting a positive result, return
            if(r === true || (typeof(r)=="object" && r.return_value)){
                return true;
            }

            LiteGraph.log_info("lgraphcanvas", "processDrop", "neither node and canvas has processed the drop");

            return false;
        }
    }

    // called if the graph doesn't have a default drop item behaviour
    checkDropItem(e) {
        if (e.dataTransfer.files.length) {
            var file = e.dataTransfer.files[0];
            var ext = LGraphCanvas.getFileExtension(file.name);
            var nodetype = LiteGraph.node_types_by_file_extension[ext];
            if (nodetype) {
                this.graph.beforeChange();
                var node = LiteGraph.createNode(nodetype.type);
                node.pos = [e.canvasX, e.canvasY];
                this.graph.add(node, false, {doProcessChange: false});
                node.processCallbackHandlers("onDropFile",{
                    def_cb: node.onDropFile
                }, file);
                this.graph.onGraphChanged({action: "fileDrop", doSave: true});
                this.graph.afterChange();
            }
        }
    }

    processNodeDblClicked(n) {

        let r = this.processCallbackHandlers("onShowNodePanel",{
            def_cb: this.onShowNodePanel
        }, n);
        if(r===null || ((typeof(r)=="object" && (r.return_value === null || !r.return_value)))){
            this.showShowNodePanel(n); // use onShowNodePanel, this is an only local method
        }

        this.processCallbackHandlers("onNodeDblClicked",{
            def_cb: this.onNodeDblClicked
        }, n);
        this.setDirty(true);
    }

    processNodeSelected(node, e) {
        this.selectNode(node, e && (e.shiftKey || e.ctrlKey || this.multi_select));
        this.processCallbackHandlers("onNodeSelected",{
            def_cb: this.onNodeSelected
        }, node);
    }

    /**
     * selects a given node (or adds it to the current selection)
     * @method selectNode
     **/
    selectNode(node, add_to_current_selection) {
        if (node == null) {
            this.deselectAllNodes();
        } else {
            this.selectNodes([node], add_to_current_selection);
        }
    }

    /**
     * selects several nodes (or adds them to the current selection)
     * @method selectNodes
     **/
    selectNodes(nodes, add_to_current_selection) {
        if (!add_to_current_selection) {
            this.deselectAllNodes();
        }

        nodes = nodes || this.graph._nodes;
        if(typeof nodes === "string") nodes = [nodes];
        if(typeof nodes.length === "undefined") nodes = [nodes];
        Object.values(nodes).forEach((node) => {
            if (node.is_selected) {
                this.deselectNode(node);
                return;
            }

            node.is_selected = true;
            this.selected_nodes[node.id] = node;

            node.processCallbackHandlers("onSelected",{
                def_cb: node.onSelected
            });

            node.inputs?.forEach((input) => {
                this.highlighted_links[input.link] = true;
            });

            node.outputs?.forEach((out) => {
                out.links?.forEach((link) => {
                    this.highlighted_links[link] = true;
                });
            });
        });
        this.processCallbackHandlers("onSelectionChange",{
            def_cb: this.onSelectionChange
        }, this.selected_nodes);
        this.setDirty(true);
    }

    /**
     * removes a node from the current selection
     * @method deselectNode
     **/
    deselectNode(node) {
        if (!node.is_selected) return;

        node.processCallbackHandlers("onDeselected",{
            def_cb: node.onDeselected
        });
        node.is_selected = false;
        this.processCallbackHandlers("onNodeDeselected",{
            def_cb: this.onNodeDeselected
        }, node);

        // Remove highlighted
        node.inputs?.forEach((input) => {
            delete this.highlighted_links?.[input.link]
        });
        node.outputs?.forEach((out) => {
            out.links?.forEach((link) => delete this.highlighted_links?.[link])
        });
    }


    /**
     * removes all nodes from the current selection
     * @method deselectAllNodes
     **/
    deselectAllNodes() {
        if (!this.graph) {
            return;
        }

        this.graph._nodes?.forEach((node) => {
            if (!node.is_selected) return;

            node.processCallbackHandlers("onDeselected",{
                def_cb: node.onDeselected
            });
            node.is_selected = false;
            this.processCallbackHandlers("onNodeDeselected",{
                def_cb: this.onNodeDeselected
            }, node);
        });

        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};

        this.processCallbackHandlers("onSelectionChange",{
            def_cb: this.onSelectionChange
        }, this.selected_nodes);
        this.setDirty(true);
    }


    /**
     * deletes all nodes in the current selection from the graph
     * @method deleteSelectedNodes
     **/
    deleteSelectedNodes() {

        this.graph.beforeChange();

        for (let i in this.selected_nodes) {
            var node = this.selected_nodes[i];

            if(node.block_delete)
                continue;

            // TODO make a better version
            // TODO should be an option default off
            // should use auto connect
            // autoconnect when possible (very basic, only takes into account first input-output)
            if(node.inputs && node.inputs.length && node.outputs && node.outputs.length && LiteGraph.isValidConnection( node.inputs[0].type, node.outputs[0].type ) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length ) {
                var input_link = node.graph.links[node.inputs[0].link];
                var output_link = node.graph.links[node.outputs[0].links[0]];
                var input_node = node.getInputNode(0);
                var output_node = node.getOutputNodes(0)[0];
                if(input_node && output_node)
                    input_node.connect( input_link.origin_slot, output_node, output_link.target_slot );
            }

            this.graph.remove(node);
            this.processCallbackHandlers("onNodeDeselected",{
                def_cb: this.onNodeDeselected
            }, node);
        }
        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};
        this.setDirty(true);
        this.graph.afterChange();
    }

    /**
     * centers the camera on a given node
     * @method centerOnNode
     **/
    centerOnNode(node) {
        this.ds.offset[0] =
            -node.pos[0] -
            node.size[0] * 0.5 +
            (this.canvas.width * 0.5) / this.ds.scale;
        this.ds.offset[1] =
            -node.pos[1] -
            node.size[1] * 0.5 +
            (this.canvas.height * 0.5) / this.ds.scale;
        this.setDirty(true, true);
    }

    recenter(){
        this.ds.offset[0] = 0;
        this.ds.offset[1] = 0;
        this.setDirty(true, true);
    }
    
    // BAD WIP
    // TODO check right scaling and positioning
    /*centerOnSelection(){
        // const canvas = LGraphCanvas.active_canvas;
        const bounds = this.getBoundaryForSelection();
        if(bounds){
            const boundPos = [bounds[0], bounds[1]];
            var canvasPos = this.convertCanvasToOffset(boundPos);
            this.ds.offset[0] = canvasPos[0]; // - (this.canvas.width * 0.5) / this.ds.scale;
            this.ds.offset[1] = canvasPos[1]; // - (this.canvas.height * 0.5) / this.ds.scale;
            this.ds.changeScale(this.canvas.width/bounds[2]*2, [canvasPos[0]+bounds[2]/2,canvasPos[1]+bounds[3]/2]);
            this.setDirty(true, true);
            return true;
        }else{
            return false;
        }
    }*/

    getMouseCoordinates(){
        return this.graph_mouse;
    }

    // getAdjustedMouseCoordinates(pos){
    //     var clientX_rel = 0;
    //     var clientY_rel = 0;

    //     if (this.canvas) {
    //         var b = this.canvas.getBoundingClientRect();
    //         clientX_rel = pos[0] - b.left;
    //         clientY_rel = pos[1] - b.top;
    //     } else {
    //         clientX_rel = pos[0];
    //         clientY_rel = pos[1];
    //     }
        
    //     return [clientX_rel / this.ds.scale - this.ds.offset[0]
    //             ,clientY_rel / this.ds.scale - this.ds.offset[1]
    //         ];
    // }

    /**
     * adds some useful properties to a mouse event, like the position in graph coordinates
     * @method adjustMouseEvent
     **/
    adjustMouseEvent(e) {
        let clientX_rel = 0;
        let clientX = 0;
        let clientY_rel = 0;
        let clientY = 0;

        if(!e.clientX){
            // simulate position via event (little hack)
            const mouseCoord = this.getMouseCoordinates();
            const gloCoord = this.convertOffsetToEditorArea(mouseCoord);
            
            // need prompt to be absolute positioned relative to editor-area that needs relative positioning
            
            // prevent error for some read-only events: setting getter-only property
            try{
                e.clientX = gloCoord[0];
                e.clientY = gloCoord[1];
            }catch(error){
                LiteGraph.log_debug("lgraphcanvas","adjustMouseEvent","failed set custom prop on event",e);
            }
            clientX = gloCoord[0];
            clientY = gloCoord[1];
        }else{
            clientX = e.clientX;
            clientY = e.clientY;
        }

        if (this.canvas) {
            var b = this.canvas.getBoundingClientRect();
            clientX_rel = clientX - b.left;
            clientY_rel = clientY - b.top;
        } else {
            clientX_rel = clientX;
            clientY_rel = clientY;
        }

        // e.deltaX = clientX_rel - this.last_mouse_position[0];
        // e.deltaY = clientY_rel- this.last_mouse_position[1];

        this.last_mouse_position[0] = clientX_rel;
        this.last_mouse_position[1] = clientY_rel;

        e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];
        e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];

        // DBG EXCESS LiteGraph.log_verbose("pointerevents: adjustMouseEvent "+e.clientX+":"+e.clientY+" "+clientX_rel+":"+clientY_rel+" "+e.canvasX+":"+e.canvasY);
    }

    /**
     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
     * @method setZoom
     **/
    setZoom(value, zooming_center) {
        this.ds.changeScale(value, zooming_center);
        
        /*
        if(!zooming_center && this.canvas)
            zooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];

        var center = this.convertOffsetToCanvas( zooming_center );

        this.ds.scale = value;

        if(this.scale > this.max_zoom)
            this.scale = this.max_zoom;
        else if(this.scale < this.min_zoom)
            this.scale = this.min_zoom;

        var new_center = this.convertOffsetToCanvas( zooming_center );
        var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];

        this.offset[0] += delta_offset[0];
        this.offset[1] += delta_offset[1];
        */

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
    }

    /**
     * converts a coordinate from graph coordinates to canvas2D coordinates
     * @method convertOffsetToCanvas
     **/
    convertOffsetToCanvas(pos, out) {
        return this.ds.convertOffsetToCanvas(pos, out);
    }

    /**
     * converts a coordinate from Canvas2D coordinates to graph space
     * @method convertCanvasToOffset
     **/
    convertCanvasToOffset(pos, out) {
        return this.ds.convertCanvasToOffset(pos, out);
    }
    
    /**
     * converts a coordinate from Canvas2D coordinates to global space
     * @method convertCanvasToOffset
     **/
    convertOffsetToEditorArea(pos) {
        // working actually for absolute positioning to editor-area eg. prompt with class graphdialog
        const rect = this.canvas.getBoundingClientRect();
        const canvasPos = this.convertOffsetToCanvas(pos);
        // return [canvasPos[0]+rect.left, canvasPos[1]+rect.top];
        return [canvasPos[0]+rect.left, canvasPos[1]+rect.top];
        // not working
        // const canvasAbsPos = this.cumulativeOffset(this.canvas);
        // const canvasPos = this.convertOffsetToCanvas(pos);
        // return [canvasPos[0]+canvasAbsPos[0], pos[1]+canvasAbsPos[1]];
    }

    // converts event coordinates from canvas2D to graph coordinates
    convertEventToCanvasOffset(e) {
        const rect = this.canvas.getBoundingClientRect();
        return this.convertCanvasToOffset([
            e.clientX - rect.left,
            e.clientY - rect.top,
        ]);
    }

    cumulativeOffset(element) {
        var top = 0, left = 0;
        do {
            top += element.offsetTop  || 0;
            left += element.offsetLeft || 0;
            element = element.offsetParent;
        } while(element);
        // return {top: top, left: left};
        return [left, top];
    }

    /**
     * brings a node to front (above all other nodes)
     * @method bringToFront
     **/
    bringToFront(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.push(node);
    }

    /**
     * sends a node to the back (below all other nodes)
     * @method sendToBack
     **/
    sendToBack(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.unshift(node);
    }

    /**
     * checks which nodes are visible (inside the camera area)
     * @method computeVisibleNodes
     **/
    computeVisibleNodes(nodes, out) {
        var visible_nodes = out || [];
        visible_nodes.length = 0;
        nodes = nodes || this.graph._nodes;
        for (var i = 0, l = nodes.length; i < l; ++i) {
            var n = nodes[i];

            // skip rendering nodes in live mode
            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {
                continue;
            }

            if (!LiteGraph.overlapBounding(this.visible_area, n.getBounding(temp, true))) {
                continue;
            } // out of the visible area

            visible_nodes.push(n);
        }
        return visible_nodes;
    }

    /**
     * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
     * @method draw
     **/
    draw(force_canvas, force_bgcanvas) {
        if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {
            return;
        }

        // fps counting
        var now = LiteGraph.getTime();
        this.render_time = (now - this.last_draw_time) * 0.001;
        this.last_draw_time = now;

        if (this.graph) {
            this.ds.computeVisibleArea(this.viewport);
        }

        if (
            this.dirty_bgcanvas ||
            force_bgcanvas ||
            this.always_render_background ||
            (this.graph &&
                this.graph._last_trigger_time &&
                now - this.graph._last_trigger_time < 1000)
        ) {
            this.drawBackCanvas();
        }

        var draw_front_canvas = this.dirty_canvas || force_canvas;
        if (draw_front_canvas) {
            this.drawFrontCanvas();
        }

        this.fps = this.render_time ? 1.0 / this.render_time : 0;
        this.frame += 1;

        // update low qualty counter
        if (this.ds.scale < 0.7) {
            if (draw_front_canvas) {
                // count only slow frames with havy rendering
                var threshold = this.low_quality_rendering_threshold;
                const acceptable_fps = 45;
                if (this.fps < acceptable_fps) {
                    this.low_quality_rendering_counter += acceptable_fps / this.fps;
                    this.low_quality_rendering_counter = Math.min(this.low_quality_rendering_counter, 2 * threshold); // clamp counter
                } else {
                    // make 100 slower the recovery as there are a lot of cahced rendering calls
                    this.low_quality_rendering_counter -= this.fps / acceptable_fps * 0.01;
                    this.low_quality_rendering_counter = Math.max(this.low_quality_rendering_counter, 0); // clamp counter
                }
            }
        } else {
            // force reset to high quality when zoomed in
            this.low_quality_rendering_counter = 0;
        }
    }

    /**
     * draws the front canvas (the one containing all the nodes)
     * @method drawFrontCanvas
     **/
    drawFrontCanvas() {
        this.dirty_canvas = false;

        if (!this.ctx) {
            this.ctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.ctx;
        if (!ctx) {
            // maybe is using webgl...
            LiteGraph.log_warn("lgraphcanvas", "drawFrontCanvas", "no ctx", this);
            return;
        }

        var canvas = this.canvas;
        if ( ctx.start2D && !this.viewport ) {
            ctx.start2D();
            ctx.restore();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // clip dirty area if there is one, otherwise work in full canvas
        var area = this.viewport || this.dirty_area;
        if (area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect( area[0],area[1],area[2],area[3] );
            ctx.clip();
        }

        // clear
        // canvas.width = canvas.width;
        if (this.clear_background) {
            if(area)
                ctx.clearRect( area[0],area[1],area[2],area[3] );
            else
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // draw bg canvas
        if (this.bgcanvas == this.canvas) {
            this.drawBackCanvas();
        } else {
            ctx.drawImage( this.bgcanvas, 0, 0 );
        }

        // rendering
        this.processCallbackHandlers("onRender",{
            def_cb: this.onRender
        }, canvas, ctx);

        // info widget
        if (this.show_info) {
            this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0 );
        }

        if (this.graph) {
            // apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            var visible_nodes = this.computeVisibleNodes(
                null,
                this.visible_nodes,
            );

            for (let i = 0; i < visible_nodes.length; ++i) {
                let node = visible_nodes[i];

                // transform coords system
                ctx.save();
                ctx.translate(node.pos[0], node.pos[1]);

                // Draw
                this.drawNode(node, ctx);

                // Restore
                ctx.restore();
            }

            // on top (debug)
            if (this.render_execution_order) {
                this.drawExecutionOrder(ctx);
            }

            // connections ontop?
            if (this.graph.config.links_ontop) {
                if (!this.live_mode) {
                    this.drawConnections(ctx);
                }
            }

            // current connection (the one being dragged by the mouse)
            if (this.connecting_pos != null) {
                ctx.lineWidth = this.connections_width;
                var link_color = null;

                var connInOrOut = this.connecting_output || this.connecting_input;

                var connType = connInOrOut.type;
                var connDir = connInOrOut.dir;
                if(connDir == null) {
                    if (this.connecting_output)
                        connDir = this.connecting_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT;
                    else
                        connDir = this.connecting_node.horizontal ? LiteGraph.UP : LiteGraph.LEFT;
                }
                var connShape = connInOrOut.shape;

                switch (connType) {
                    case LiteGraph.EVENT:
                    case LiteGraph.ACTION:
                        link_color = LiteGraph.EVENT_LINK_COLOR;
                        break;
                    default:
                        link_color = LiteGraph.CONNECTING_LINK_COLOR;
                }

                // the connection being dragged by the mouse
                this.renderLink(
                    ctx,
                    this.connecting_pos,
                    [this.graph_mouse[0], this.graph_mouse[1]],
                    null,
                    false,
                    null,
                    link_color,
                    connDir,
                    LiteGraph.CENTER,
                );

                ctx.beginPath();
                if (
                    connType === LiteGraph.EVENT ||
                    connType === LiteGraph.ACTION ||
                    connShape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(
                        this.connecting_pos[0] - 6 + 0.5,
                        this.connecting_pos[1] - 5 + 0.5,
                        14,
                        10,
                    );
                    ctx.fill();
                    ctx.beginPath();
                    ctx.rect(
                        this.graph_mouse[0] - 6 + 0.5,
                        this.graph_mouse[1] - 5 + 0.5,
                        14,
                        10,
                    );
                } else if (connShape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);
                    ctx.closePath();
                } else {
                    ctx.arc(
                        this.connecting_pos[0],
                        this.connecting_pos[1],
                        4,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(
                        this.graph_mouse[0],
                        this.graph_mouse[1],
                        4,
                        0,
                        Math.PI * 2,
                    );
                }
                ctx.fill();

                ctx.fillStyle = "#ffcc00";
                if (this._highlight_input) {
                    ctx.beginPath();
                    var shape = this._highlight_input_slot.shape;
                    if (shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
                        ctx.arc(
                            this._highlight_input[0],
                            this._highlight_input[1],
                            6,
                            0,
                            Math.PI * 2,
                        );
                    }
                    ctx.fill();
                }
                if (this._highlight_output) {
                    ctx.beginPath();
                    if (shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);
                        ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);
                        ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
                        ctx.arc(
                            this._highlight_output[0],
                            this._highlight_output[1],
                            6,
                            0,
                            Math.PI * 2,
                        );
                    }
                    ctx.fill();
                }
            }

            // the selection rectangle
            if (this.dragging_rectangle) {
                ctx.strokeStyle = "#FFF";
                ctx.strokeRect(
                    this.dragging_rectangle[0],
                    this.dragging_rectangle[1],
                    this.dragging_rectangle[2],
                    this.dragging_rectangle[3],
                );
            }

            // on top of link center
            if(this.over_link_center && this.render_link_tooltip){
                this.drawLinkTooltip( ctx, this.over_link_center );
            }else{
                // are we sure to call this here (?) should check for over_link
                this.processCallbackHandlers("onDrawLinkTooltip",{
                    def_cb: this.onDrawLinkTooltip
                }, ctx, null);
            }

            // custom info
            this.processCallbackHandlers("onDrawForeground",{
                def_cb: this.onDrawForeground
            }, ctx, this.visible_rect);
            ctx.restore();
        }else{
            LiteGraph.log_warn("lgraphcanvas", "drawFrontCanvas", "no graph", this);
        }

        // draws panel in the corner
        if (this._graph_stack && this._graph_stack.length) {
            this.drawSubgraphPanel( ctx );
        }
        this.processCallbackHandlers("onDrawOverlay",{
            def_cb: this.onDrawOverlay
        }, ctx);
        if (area) {
            ctx.restore();
        }
        ctx.finish2D?.(); // this is a function original developer (Javi tamat) use in webgl renderer
    }

    /**
     * draws the panel in the corner that shows subgraph properties
     * @method drawSubgraphPanel
     **/
    drawSubgraphPanel(ctx) {
        var subgraph = this.graph;
        if( !subgraph)
            return;
        var subnode = subgraph._subgraph_node;
        if (!subnode) {
            LiteGraph.log_warn("subgraph without subnode");
            return;
        }
        this.drawSubgraphPanelLeft(subgraph, subnode, ctx)
        this.drawSubgraphPanelRight(subgraph, subnode, ctx)
    }

    drawSubgraphPanelLeft(subgraph, subnode, ctx) {
        var num = subnode.inputs ? subnode.inputs.length : 0;
        var w = 200;
        var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);

        ctx.fillStyle = "#111";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.roundRect(10, 10, w, (num + 1) * h + 50, [8]);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#888";
        ctx.font = "14px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Graph Inputs", 20, 34);
        // var pos = this.mouse;

        if (this.drawButton(w - 20, 20, 20, 20, "X", "#151515")) {
            this.closeSubgraph();
            return;
        }

        var y = 50;
        ctx.font = "14px Arial";
        if (subnode.inputs)
            for (var i = 0; i < subnode.inputs.length; ++i) {
                var input = subnode.inputs[i];
                if (input.not_subgraph_input)
                    continue;

                // input button clicked
                if (this.drawButton(20, y + 2, w - 20, h - 2)) {
                    var type = subnode.constructor.input_node_type || "graph/input";
                    this.graph.beforeChange();
                    var newnode = LiteGraph.createNode(type);
                    if (newnode) {
                        subgraph.add(newnode, false, {doProcessChange: false} );
                        this.block_click = false;
                        this.last_click_position = null;
                        this.selectNodes([newnode]);
                        this.node_dragged = newnode;
                        this.dragging_canvas = false;
                        newnode.setProperty("name", input.name);
                        newnode.setProperty("type", input.type);
                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
                        this.graph.afterChange();
                    } else
                        LiteGraph.log_error("graph input node not found:", type);
                }
                ctx.fillStyle = "#9C9";
                ctx.beginPath();
                ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = "#AAA";
                ctx.fillText(input.name, 30, y + h * 0.75);
                // var tw = ctx.measureText(input.name);
                ctx.fillStyle = "#777";
                ctx.fillText(input.type, 130, y + h * 0.75);
                y += h;
            }
        // add + button
        if (this.drawButton(20, y + 2, w - 20, h - 2, "+", "#151515", "#222")) {
            this.showSubgraphPropertiesDialog(subnode);
        }
    }

    drawSubgraphPanelRight(subgraph, subnode, ctx) {
        var num = subnode.outputs ? subnode.outputs.length : 0;
        var canvas_w = this.bgcanvas.width;
        var w = 200;
        var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);

        ctx.fillStyle = "#111";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.roundRect(canvas_w - w - 10, 10, w, (num + 1) * h + 50, [8]);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#888";
        ctx.font = "14px Arial";
        ctx.textAlign = "left";
        const title_text = "Graph Outputs";
        var tw = ctx.measureText(title_text).width
        ctx.fillText(title_text, (canvas_w - tw) - 20, 34);
        // var pos = this.mouse;
        if (this.drawButton(canvas_w - w, 20, 20, 20, "X", "#151515")) {
            this.closeSubgraph();
            return;
        }

        var y = 50;
        ctx.font = "14px Arial";
        if (subnode.outputs)
            for (var i = 0; i < subnode.outputs.length; ++i) {
                var output = subnode.outputs[i];
                if (output.not_subgraph_input)
                    continue;

                // output button clicked
                if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2)) {
                    var type = subnode.constructor.output_node_type || "graph/output";
                    this.graph.beforeChange();
                    var newnode = LiteGraph.createNode(type);
                    if (newnode) {
                        subgraph.add(newnode, false, {doProcessChange: false} );
                        this.block_click = false;
                        this.last_click_position = null;
                        this.selectNodes([newnode]);
                        this.node_dragged = newnode;
                        this.dragging_canvas = false;
                        newnode.setProperty("name", output.name);
                        newnode.setProperty("type", output.type);
                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
                        this.graph.afterChange();
                    } else
                        LiteGraph.log_error("graph input node not found:", type);
                }
                ctx.fillStyle = "#9C9";
                ctx.beginPath();
                ctx.arc(canvas_w - w + 16, y + h * 0.5, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = "#AAA";
                ctx.fillText(output.name, canvas_w - w + 30, y + h * 0.75);
                // var tw = ctx.measureText(input.name);
                ctx.fillStyle = "#777";
                ctx.fillText(output.type, canvas_w - w + 130, y + h * 0.75);
                y += h;
            }
        // add + button
        if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2, "+", "#151515", "#222")) {
            this.showSubgraphPropertiesDialogRight(subnode);
        }
    }

    // Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
    drawButton(x, y, w, h, text, bgcolor, hovercolor, textcolor) {
        var ctx = this.ctx;
        bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
        hovercolor = hovercolor || "#555";
        textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;
        var pos = this.ds.convertOffsetToCanvas(this.graph_mouse);
        var hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
        pos = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;
        if(pos) {
            var rect = this.canvas.getBoundingClientRect();
            pos[0] -= rect.left;
            pos[1] -= rect.top;
        }
        var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );

        ctx.fillStyle = hover ? hovercolor : bgcolor;
        if(clicked)
            ctx.fillStyle = "#AAA";
        ctx.beginPath();
        ctx.roundRect(x,y,w,h,[4] );
        ctx.fill();

        if(text != null) {
            if(text.constructor == String) {
                ctx.fillStyle = textcolor;
                ctx.textAlign = "center";
                ctx.font = ((h * 0.65)|0) + "px Arial";
                ctx.fillText( text, x + w * 0.5,y + h * 0.75 );
                ctx.textAlign = "left";
            }
        }

        var was_clicked = clicked && !this.block_click;
        if(clicked)
            this.blockClick();
        return was_clicked;
    }

    isAreaClicked(x, y, w, h, hold_click) {
        var pos = this.last_click_position;
        var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
        var was_clicked = clicked && !this.block_click;
        if(clicked && hold_click)
            this.blockClick();
        return was_clicked;
    }

    /**
     * draws some useful stats in the corner of the canvas
     * @method renderInfo
     **/
    renderInfo(ctx, x, y) {
        x = x || 10;
        y = y || this.canvas.height - 80;

        ctx.save();
        ctx.translate(x, y);

        ctx.font = "10px Arial";
        ctx.fillStyle = "#888";
        ctx.textAlign = "left";
        if (this.graph) {
            ctx.fillText( "T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1 );
            ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2 );
            ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3 );
            ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
            ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
        } else {
            ctx.fillText("No graph selected", 5, 13 * 1);
        }
        ctx.restore();
    }

    /**
     * draws the back canvas (the one containing the background and the connections)
     * @method drawBackCanvas
     **/
    drawBackCanvas() {
        var canvas = this.bgcanvas;

        // ComfyUI compatibility
        // ensure correct sizing
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;

        if (!this.bgctx) {
            this.bgctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.bgctx;
        if (ctx.start) {
            ctx.start();
        }

        var viewport = this.viewport || [0,0,ctx.canvas.width,ctx.canvas.height];

        // clear
        if (this.clear_background) {
            ctx.clearRect( viewport[0], viewport[1], viewport[2], viewport[3] );
        }

        // show subgraph stack header
        if (this._graph_stack && this._graph_stack.length) {
            ctx.save();
            var subgraph_node = this.graph._subgraph_node;
            ctx.strokeStyle = subgraph_node.bgcolor;
            ctx.lineWidth = 10;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            ctx.lineWidth = 1;
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
            let title = "";
            this._graph_stack.slice(1).forEach((item, index) => {
                title += `${item._subgraph_node.getTitle()} ${index < this._graph_stack.length - 2 ? ">> " : ""}`;
            });
            ctx.fillText(
                title + subgraph_node.getTitle(),
                canvas.width * 0.5,
                40,
            );
            ctx.restore();
        }

        var bg_already_painted = false;
        let r = this.processCallbackHandlers("onRenderBackground",{
            def_cb: this.onRenderBackground
        }, canvas, ctx);
        if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
            bg_already_painted = true;
        }

        // reset in case of error
        if ( !this.viewport ) {
            ctx.restore();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        this.visible_links.length = 0;

        if (this.graph) {
            // apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            // render BG
            if ( this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color ) {
                ctx.fillStyle = this.clear_background_color;
                ctx.fillRect(
                    this.visible_area[0],
                    this.visible_area[1],
                    this.visible_area[2],
                    this.visible_area[3],
                );
            }

            if (
                this.background_image &&
                this.ds.scale > 0.5 &&
                !bg_already_painted
            ) {
                if (this.zoom_modify_alpha) {
                    ctx.globalAlpha =
                        (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;
                } else {
                    ctx.globalAlpha = this.editor_alpha;
                }
                ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false; // ctx.mozImageSmoothingEnabled =
                if (
                    !this._bg_img ||
                    this._bg_img.name != this.background_image
                ) {
                    this._bg_img = new Image();
                    this._bg_img.name = this.background_image;
                    this._bg_img.src = this.background_image;
                    var that = this;
                    this._bg_img.onload = function() {
                        that.draw(true, true);
                    };
                }

                var pattern = null;
                if (this._pattern == null && this._bg_img.width > 0) {
                    pattern = ctx.createPattern(this._bg_img, "repeat");
                    this._pattern_img = this._bg_img;
                    this._pattern = pattern;
                } else {
                    pattern = this._pattern;
                }
                if (pattern) {
                    ctx.fillStyle = pattern;
                    ctx.fillRect(
                        this.visible_area[0],
                        this.visible_area[1],
                        this.visible_area[2],
                        this.visible_area[3],
                    );
                    ctx.fillStyle = "transparent";
                }

                ctx.globalAlpha = 1.0;
                ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true; // = ctx.mozImageSmoothingEnabled
            }

            // groups
            if (this.graph._groups.length && !this.live_mode) {
                this.drawGroups(canvas, ctx);
            }

            this.processCallbackHandlers("onDrawBackground",{
                def_cb: this.onDrawBackground
            }, ctx, this.visible_area);

            if (this.onBackgroundRender) {
                // LEGACY
                LiteGraph.log_error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground ");
                this.onBackgroundRender = null;
            }

            // DEBUG: show clipping area
            // ctx.fillStyle = "red";
            // ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);

            // bg
            if (this.render_canvas_border) {
                ctx.strokeStyle = "#235";
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            if (this.render_connections_shadows) {
                ctx.shadowColor = "#000";
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.shadowBlur = 6;
            } else {
                ctx.shadowColor = "rgba(0,0,0,0)";
            }

            // draw connections
            if (!this.live_mode) {
                this.drawConnections(ctx);
            }

            ctx.shadowColor = "rgba(0,0,0,0)";

            // restore state
            ctx.restore();
        }

        ctx.finish?.();
        this.dirty_bgcanvas = false;
        this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas
    }

    /**
     * draws the given node inside the canvas
     * @method drawNode
     **/
    drawNode(node, ctx) {

        this.current_node = node;

        var color = node.color || node.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
        var bgcolor = node.bgcolor || node.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;
        var low_quality = this.ds.scale < 0.6; // zoomed out

        // only render if it forces it to do it
        if (this.live_mode) {
            if (!node.flags.collapsed) {
                ctx.shadowColor = "transparent";
                node.processCallbackHandlers("onDrawForeground",{
                    def_cb: node.onDrawForeground
                }, ctx, this, this.canvas);
            }
            return;
        }

        var editor_alpha = this.editor_alpha;
        ctx.globalAlpha = editor_alpha;

        if (this.render_shadows && !low_quality) {
            ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
            ctx.shadowOffsetX = 2 * this.ds.scale;
            ctx.shadowOffsetY = 2 * this.ds.scale;
            ctx.shadowBlur = 3 * this.ds.scale;
        } else {
            ctx.shadowColor = "transparent";
        }

        // custom draw collapsed method (draw after shadows because they are affected)
        if (node.flags.collapsed) {
            let r = node.processCallbackHandlers("onDrawCollapsed",{
                def_cb: node.onDrawCollapsed
            }, ctx, this);
            if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
                return;
            }
        }

        // clip if required (mask)
        var shape = node._shape || LiteGraph.BOX_SHAPE;
        var size = temp_vec2;
        temp_vec2.set(node.size);
        var horizontal = node.horizontal; // || node.flags.horizontal;

        if (node.flags.collapsed) {
            ctx.font = this.title_text_font;
            var title = node.getTitle ? node.getTitle() : node.title;
            if (title != null) {
                node._collapsed_width = Math.min(
                    node.size[0],
                    ctx.measureText(title).width + LiteGraph.NODE_TITLE_HEIGHT * 2,
                ); // LiteGraph.NODE_COLLAPSED_WIDTH;
                size[0] = node._collapsed_width;
                size[1] = 0;
            }
        }

        if (node.clip_area || this.clip_all_nodes) {
            // Start clipping
            ctx.save();
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(0, 0, size[0], size[1]);
            } else if (shape == LiteGraph.ROUND_SHAPE) {
                ctx.roundRect(0, 0, size[0], size[1], [10]);
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2,
                );
            }
            ctx.clip();
        }

        // draw shape
        if (node.has_errors) {
            bgcolor = "red";
        }
        this.drawNodeShape(
            node,
            ctx,
            size,
            color,
            bgcolor,
            node.is_selected,
            node.mouseOver,
        );
        ctx.shadowColor = "transparent";

        // draw foreground
        node.processCallbackHandlers("onDrawForeground",{
            def_cb: node.onDrawForeground
        }, ctx, this, this.canvas);

        // node tooltip
        if (LiteGraph.show_node_tooltip
            && node.mouseOver
            && (node.is_selected && (!this.selected_nodes || Object.keys(this.selected_nodes).length <= 1))
        ) {
            this.drawNodeTooltip(ctx,node);
        }

        // connection slots
        ctx.textAlign = horizontal ? "center" : "left";
        ctx.font = this.inner_text_font;

        var render_text = !this.lowQualityRenderingRequired(0.6);

        var out_slot = this.connecting_output;
        var in_slot = this.connecting_input;
        ctx.lineWidth = 1;

        var max_y = 0;
        var slot_pos = new Float32Array(2); // to reuse
        var doStroke;

        // render inputs and outputs
        if (!node.flags.collapsed) {
            // input connection slots
            if (node.inputs) {
                for (let i = 0; i < node.inputs.length; i++) {
                    let slot = node.inputs[i];
                    let slot_type = slot.type;
                    let slot_shape = slot.shape;

                    ctx.globalAlpha = editor_alpha;
                    // change opacity of incompatible slots when dragging a connection
                    if ( this.connecting_output && !LiteGraph.isValidConnection( slot.type , out_slot.type) ) {
                        ctx.globalAlpha = 0.4 * editor_alpha;
                    }

                    ctx.fillStyle =
                        slot.link != null
                            ? slot.color_on ||
                                this.default_connection_color_byType[slot_type] ||
                                this.default_connection_color.input_on
                            : slot.color_off ||
                                this.default_connection_color_byTypeOff[slot_type] ||
                                this.default_connection_color_byType[slot_type] ||
                                this.default_connection_color.input_off;

                    let pos = node.getConnectionPos(true, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.beginPath();

                    if (slot_type == "array") {
                        slot_shape = LiteGraph.GRID_SHAPE; // place in addInput? addOutput instead?
                    } else if (slot.name == "onTrigger" || slot.name == "onExecuted") {
                        slot_shape = LiteGraph.ARROW_SHAPE;
                    } else if(slot_type === LiteGraph.EVENT || slot_type === LiteGraph.ACTION) {
                        slot_shape = LiteGraph.BOX_SHAPE;
                    }

                    doStroke = true;

                    if (slot_shape === LiteGraph.BOX_SHAPE) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14,
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10,
                            );
                        }
                    } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else if (slot_shape === LiteGraph.GRID_SHAPE) {
                        ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);
                        doStroke = false;
                    } else {
                        if(low_quality)
                            ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 ); // faster
                        else
                            ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }
                    ctx.fill();

                    // render name
                    if (render_text
                        && !(slot.name == "onTrigger" || slot.name == "onExecuted")
                    ) {
                        let text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.UP) {
                                ctx.fillText(text, pos[0], pos[1] - 10);
                            } else {
                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            // output connection slots

            ctx.textAlign = horizontal ? "center" : "right";
            ctx.strokeStyle = "black";
            if (node.outputs) {
                for (let i = 0; i < node.outputs.length; i++) {
                    let slot = node.outputs[i];
                    let slot_type = slot.type;
                    let slot_shape = slot.shape;

                    // change opacity of incompatible slots when dragging a connection
                    if (this.connecting_input && !LiteGraph.isValidConnection( slot_type , in_slot.type) ) {
                        ctx.globalAlpha = 0.4 * editor_alpha;
                    }

                    let pos = node.getConnectionPos(false, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.fillStyle =
                        slot.links && slot.links.length
                            ? slot.color_on ||
                                this.default_connection_color_byType[slot_type] ||
                                this.default_connection_color.output_on
                            : slot.color_off ||
                                this.default_connection_color_byTypeOff[slot_type] ||
                                this.default_connection_color_byType[slot_type] ||
                                this.default_connection_color.output_off;
                    ctx.beginPath();
                    // ctx.rect( node.size[0] - 14,i*14,10,10);

                    if (slot_type == "array") {
                        slot_shape = LiteGraph.GRID_SHAPE;
                    } else if (slot.name == "onTrigger" || slot.name == "onExecuted") {
                        slot_shape = LiteGraph.ARROW_SHAPE;
                    } else if(slot_type === LiteGraph.EVENT || slot_type === LiteGraph.ACTION) {
                        slot_shape = LiteGraph.BOX_SHAPE;
                    }

                    doStroke = true;

                    if (slot_shape === LiteGraph.BOX_SHAPE) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14,
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10,
                            );
                        }
                    } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else if (slot_shape === LiteGraph.GRID_SHAPE) {
                        ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);
                        ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);
                        ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);
                        ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);
                        ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);
                        doStroke = false;
                    } else {
                        if(low_quality)
                            ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 );
                        else
                            ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }

                    // trigger
                    // if(slot.node_id != null && slot.slot == -1)
                    //	ctx.fillStyle = "#F85";

                    // if(slot.links != null && slot.links.length)
                    ctx.fill();
                    if(!low_quality && doStroke)
                        ctx.stroke();

                    // render output name
                    if (render_text
                        && !(slot.name == "onTrigger" || slot.name == "onExecuted")
                    ) {
                        let text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.DOWN) {
                                ctx.fillText(text, pos[0], pos[1] - 8);
                            } else {
                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            ctx.textAlign = "left";
            ctx.globalAlpha = 1;

            if (node.widgets) {
                var widgets_y = max_y;
                if (horizontal || node.widgets_up) {
                    widgets_y = 2;
                }
                if( node.widgets_start_y != null )
                    widgets_y = node.widgets_start_y;
                this.drawNodeWidgets(
                    node,
                    widgets_y,
                    ctx,
                    this.node_widget && this.node_widget[0] == node
                        ? this.node_widget[1]
                        : null,
                );
            }
        } else if (this.render_collapsed_slots) {
            // if collapsed
            var input_slot = null;
            var output_slot = null;

            // get first connected slot to render
            if (node.inputs) {
                for (let i = 0; i < node.inputs.length; i++) {
                    var slot_i = node.inputs[i];
                    if (slot_i.link == null) {
                        continue;
                    }
                    input_slot = slot_i;
                    break;
                }
            }
            if (node.outputs) {
                for (let i = 0; i < node.outputs.length; i++) {
                    var slot_o = node.outputs[i];
                    if (!slot_o.links || !slot_o.links.length) {
                        continue;
                    }
                    output_slot = slot_o;
                }
            }

            if (input_slot) {
                let x = 0;
                let y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = -LiteGraph.NODE_TITLE_HEIGHT;
                }
                ctx.fillStyle = "#686";
                ctx.beginPath();
                if (
                    input_slot.type === LiteGraph.EVENT || input_slot.type === LiteGraph.ACTION ||
                    input_slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (input_slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 8, y);
                    ctx.lineTo(x + -4, y - 4);
                    ctx.lineTo(x + -4, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            if (output_slot) {
                let x = node._collapsed_width;
                let y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = 0;
                }
                ctx.fillStyle = "#686";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                if (
                    output_slot.type === LiteGraph.EVENT || output_slot.type === LiteGraph.ACTION ||
                    output_slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (output_slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 6, y);
                    ctx.lineTo(x - 6, y - 4);
                    ctx.lineTo(x - 6, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
                // ctx.stroke();
            }
        }

        if (node.clip_area || this.clip_all_nodes) {
            ctx.restore();
        }

        ctx.globalAlpha = 1.0;
    }

    drawNodeTooltip( ctx, node ) {
        if(!node || !ctx) {
            LiteGraph.log_warn("drawNodeTooltip: invalid node or ctx",node,ctx);
            return;
        }
        var text = node.properties.tooltip!=undefined?node.properties.tooltip:"";
        if (!text || text=="") {
            if (LiteGraph.show_node_tooltip_use_descr_property && node.constructor.desc) {
                text = node.constructor.desc;
            }
        }
        text = (text+"").trim();
        if(!text || text == "") {
            // DBG("Empty tooltip");
            return;
        }

        var pos = [0,-LiteGraph.NODE_TITLE_HEIGHT]; // node.pos;
        // text = text.substr(0,30); //avoid weird
        // text = text + "\n" + text;
        var size = node.flags.collapsed? [LiteGraph.NODE_COLLAPSED_WIDTH, LiteGraph.NODE_TITLE_HEIGHT] : node.size;

        // using a trick to save the calculated height of the tip the first time using trasparent, to than show it
        // node.ttip_oTMultiRet is not set or false the first time

        ctx.font = "14px Courier New";
        // var info = ctx.measureText(text);
        var w = Math.max(node.size[0],160) + 20; // info.width + 20;
        var h = node.ttip_oTMultiRet ? node.ttip_oTMultiRet.height + 15 : 21;

        ctx.globalAlpha = 0.7 * this.editor_alpha;

        ctx.shadowColor = node.ttip_oTMultiRet?"black":"transparent";
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.shadowBlur = 3;
        ctx.fillStyle = node.ttip_oTMultiRet?"#454":"transparent";
        ctx.beginPath();

        ctx.roundRect( pos[0] - w*0.5 + size[0]/2, pos[1] - 15 - h, w, h, [3]);
        ctx.moveTo( pos[0] - 10 + size[0]/2, pos[1] - 15 );
        ctx.lineTo( pos[0] + 10 + size[0]/2, pos[1] - 15 );
        ctx.lineTo( pos[0] + size[0]/2, pos[1] - 5 );
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.textAlign = "center";
        ctx.fillStyle = node.ttip_oTMultiRet?"#CEC":"transparent";

        ctx.globalAlpha = this.editor_alpha;

        // ctx.fillText(text, pos[0] + size[0]/2, pos[1] - 15 - h * 0.3);
        const oTMultiRet = LiteGraph.canvasFillTextMultiline(ctx, text, pos[0] + size[0]/2, pos[1] - (h), w, 14);

        node.ttip_oTMultiRet = oTMultiRet;

        ctx.closePath();
    }

    // used by this.over_link_center
    drawLinkTooltip(ctx, link) {
        var pos = link._pos;
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc( pos[0], pos[1], 3, 0, Math.PI * 2 );
        ctx.fill();

        if(link.data == null)
            return;

        let r = this.processCallbackHandlers("onDrawLinkTooltip",{
            def_cb: this.onDrawLinkTooltip
        }, ctx, link, this);
        if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
            return;
        }

        var data = link.data;
        var text = null;

        if( data.constructor === Number )
            text = data.toFixed(2);
        else if( data.constructor === String )
            text = "\"" + data + "\"";
        else if( data.constructor === Boolean )
            text = String(data);
        else if (data.toToolTip)
            text = data.toToolTip();
        else
            text = "[" + data.constructor.name + "]";

        if(text == null)
            return;
        text = text.substr(0,30); // avoid weird

        ctx.font = "14px Courier New";
        var info = ctx.measureText(text);
        var w = info.width + 20;
        var h = 24;
        ctx.shadowColor = "black";
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.shadowBlur = 3;
        ctx.fillStyle = "#454";
        ctx.beginPath();
        ctx.roundRect( pos[0] - w*0.5, pos[1] - 15 - h, w, h, [3]);
        ctx.moveTo( pos[0] - 10, pos[1] - 15 );
        ctx.lineTo( pos[0] + 10, pos[1] - 15 );
        ctx.lineTo( pos[0], pos[1] - 5 );
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.textAlign = "center";
        ctx.fillStyle = "#CEC";
        ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);
    }

    drawNodeShape(node, ctx, size, fgcolor, bgcolor, selected, mouse_over) {
        // bg rect
        ctx.strokeStyle = fgcolor;
        ctx.fillStyle = bgcolor;

        let r = null;
        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        var low_quality = this.lowQualityRenderingRequired(0.5);

        // render node area depending on shape
        var shape = node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;

        var title_mode = node.constructor.title_mode;

        var render_title = true;
        if (title_mode == LiteGraph.TRANSPARENT_TITLE || title_mode == LiteGraph.NO_TITLE) {
            render_title = false;
        } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {
            render_title = true;
        }

        var area = tmp_area;
        area[0] = 0; // x
        area[1] = render_title ? -title_height : 0; // y
        area[2] = size[0] + 1; // w
        area[3] = render_title ? size[1] + title_height : size[1]; // h

        var old_alpha = ctx.globalAlpha;

        // full node shape
        // if(node.flags.collapsed)
        {
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                ctx.fillRect(area[0], area[1], area[2], area[3]);
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                ctx.roundRect(
                    area[0],
                    area[1],
                    area[2],
                    area[3],
                    shape == LiteGraph.CARD_SHAPE ? [this.round_radius,this.round_radius,0,0] : [this.round_radius],
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2,
                );
            }
            ctx.fill();

            // separator
            if(!node.flags.collapsed && render_title) {
                ctx.shadowColor = "transparent";
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillRect(0, -1, area[2], 2);
            }
        }
        ctx.shadowColor = "transparent";
        
        node.processCallbackHandlers("onDrawBackground",{
            def_cb: node.onDrawBackground
        }, ctx, this, this.canvas, this.graph_mouse);

        // title bg (remember, it is rendered ABOVE the node)
        if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {
            // title bar
            r = node.processCallbackHandlers("onDrawTitleBar",{
                def_cb: node.onDrawTitleBar
            }, ctx, title_height, size, this.ds.scale, fgcolor);
            if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
                // managed
            } else if (
                title_mode != LiteGraph.TRANSPARENT_TITLE &&
                (node.constructor.title_color || this.render_title_colored)
            ) {
                var title_color = node.constructor.title_color || fgcolor;

                if (node.flags.collapsed) {
                    ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
                }

                //* gradient test
                if (this.use_gradients) {
                    var grad = LGraphCanvas.gradients[title_color];
                    if (!grad) {
                        grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);
                        grad.addColorStop(0, title_color); // TODO refactor: validate color !! prevent DOMException
                        grad.addColorStop(1, "#000");
                    }
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = title_color;
                }

                // ctx.globalAlpha = 0.5 * old_alpha;
                ctx.beginPath();
                if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                    ctx.rect(0, -title_height, size[0] + 1, title_height);
                } else if ( shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE ) {
                    ctx.roundRect(
                        0,
                        -title_height,
                        size[0] + 1,
                        title_height,
                        node.flags.collapsed ? [this.round_radius] : [this.round_radius,this.round_radius,0,0],
                    );
                }
                ctx.fill();
                ctx.shadowColor = "transparent";
            }

            let colState = false;
            if (LiteGraph.node_box_coloured_by_mode && LiteGraph.NODE_MODES_COLORS[node.mode]) {
                colState = LiteGraph.NODE_MODES_COLORS[node.mode];
            }
            if (LiteGraph.node_box_coloured_when_on) {
                colState = node.action_triggered ? "#FFF" : (node.execute_triggered ? "#AAA" : colState);
            }

            // title box
            var box_size = 10;
            r = node.processCallbackHandlers("onDrawTitleBox",{
                def_cb: node.onDrawTitleBox
            }, ctx, title_height, size, this.ds.scale);
            if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
                // managed
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CIRCLE_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(
                        title_height * 0.5,
                        title_height * -0.5,
                        box_size * 0.5 + 1,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();
                }

                ctx.fillStyle = node.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
                if(low_quality)
                    ctx.fillRect( title_height * 0.5 - box_size *0.5, title_height * -0.5 - box_size *0.5, box_size , box_size );
                else {
                    ctx.beginPath();
                    ctx.arc(
                        title_height * 0.5,
                        title_height * -0.5,
                        box_size * 0.5,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();
                }
            } else {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(
                        (title_height - box_size) * 0.5 - 1,
                        (title_height + box_size) * -0.5 - 1,
                        box_size + 2,
                        box_size + 2,
                    );
                }
                ctx.fillStyle = node.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
                ctx.fillRect(
                    (title_height - box_size) * 0.5,
                    (title_height + box_size) * -0.5,
                    box_size,
                    box_size,
                );
            }
            ctx.globalAlpha = old_alpha;

            // title text
            node.processCallbackHandlers("onDrawTitleText",{
                    def_cb: node.onDrawTitleText
                },
                ctx,
                title_height,
                size,
                this.ds.scale,
                this.title_text_font,
                selected,
            );
            if (!low_quality) {
                ctx.font = this.title_text_font;
                var title = String(node.getTitle());
                if (title) {
                    if (selected) {
                        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
                    } else {
                        ctx.fillStyle =
                            node.constructor.title_text_color ||
                            this.node_title_color;
                    }
                    if (node.flags.collapsed) {
                        ctx.textAlign = "left";
                        ctx.fillText(
                            title, // NO? .substring(0,20), // avoid urls too long
                            title_height,// + measure.width * 0.5,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height,
                        );
                        ctx.textAlign = "left";
                    } else {
                        ctx.textAlign = "left";
                        ctx.fillText(
                            title,
                            title_height,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height,
                        );
                    }
                }
            }

            // subgraph box
            if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {
                var w = LiteGraph.NODE_TITLE_HEIGHT;
                var x = node.size[0] - w;
                var over = LiteGraph.isInsideRectangle( this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x+2, -w+2, w-4, w-4 );
                ctx.fillStyle = over ? "#888" : "#555";
                if( shape == LiteGraph.BOX_SHAPE || low_quality)
                    ctx.fillRect(x+2, -w+2, w-4, w-4);
                else {
                    ctx.beginPath();
                    ctx.roundRect(x+2, -w+2, w-4, w-4,[4]);
                    ctx.fill();
                }
                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.moveTo(x + w * 0.2, -w * 0.6);
                ctx.lineTo(x + w * 0.8, -w * 0.6);
                ctx.lineTo(x + w * 0.5, -w * 0.3);
                ctx.fill();
            }

            // custom title render
            node.processCallbackHandlers("onDrawTitle",{
                def_cb: node.onDrawTitle
            }, ctx);
        }

        // render selection marker
        if (selected) {
            node.processCallbackHandlers("onBounding",{
                def_cb: node.onBounding
            }, area);

            if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
                area[1] -= title_height;
                area[3] += title_height;
            }
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                );
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                (shape == LiteGraph.CARD_SHAPE && node.flags.collapsed)
            ) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    [this.round_radius * 2],
                );
            } else if (shape == LiteGraph.CARD_SHAPE) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    [this.round_radius * 2,2,this.round_radius * 2,2],
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5 + 6,
                    0,
                    Math.PI * 2,
                );
            }
            ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
            ctx.stroke();
            ctx.strokeStyle = fgcolor;
            ctx.globalAlpha = 1;
        }

        // these counter helps in conditioning drawing based on if the node has been executed or an action occurred
        if (node.execute_triggered>0) node.execute_triggered--;
        if (node.action_triggered>0) node.action_triggered--;
    }

    /**
     * draws every connection visible in the canvas
     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time
     * @method drawConnections
     **/
    drawConnections(ctx) {
        var now = LiteGraph.getTime();
        var visible_area = this.visible_area;
        margin_area[0] = visible_area[0] - 20;
        margin_area[1] = visible_area[1] - 20;
        margin_area[2] = visible_area[2] + 40;
        margin_area[3] = visible_area[3] + 40;

        // draw connections
        ctx.lineWidth = this.connections_width;

        ctx.fillStyle = "#AAA";
        ctx.strokeStyle = "#AAA";
        ctx.globalAlpha = this.editor_alpha;
        // for every node
        var nodes = this.graph._nodes;
        for (var n = 0, l = nodes.length; n < l; ++n) {
            var node = nodes[n];
            // for every input (we render just inputs because it is easier as every slot can only have one input)
            if (!node.inputs || !node.inputs.length) {
                continue;
            }

            for (let i = 0; i < node.inputs.length; ++i) {
                var input = node.inputs[i];
                if (!input || input.link == null) {
                    continue;
                }
                var link_id = input.link;
                var link = this.graph.links[link_id];
                if (!link) {
                    continue;
                }

                // find link info
                var start_node = this.graph.getNodeById(link.origin_id);
                if (start_node == null) {
                    continue;
                }
                var start_node_slot = link.origin_slot;
                var start_node_slotpos = null;
                if (start_node_slot == -1) {
                    start_node_slotpos = [
                        start_node.pos[0] + 10,
                        start_node.pos[1] + 10,
                    ];
                } else {
                    start_node_slotpos = start_node.getConnectionPos(
                        false,
                        start_node_slot,
                        tempA,
                    );
                }
                var end_node_slotpos = node.getConnectionPos(true, i, tempB);

                // compute link bounding
                link_bounding[0] = start_node_slotpos[0];
                link_bounding[1] = start_node_slotpos[1];
                link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];
                link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];
                if (link_bounding[2] < 0) {
                    link_bounding[0] += link_bounding[2];
                    link_bounding[2] = Math.abs(link_bounding[2]);
                }
                if (link_bounding[3] < 0) {
                    link_bounding[1] += link_bounding[3];
                    link_bounding[3] = Math.abs(link_bounding[3]);
                }

                // skip links outside of the visible area of the canvas
                if (!LiteGraph.overlapBounding(link_bounding, margin_area)) {
                    continue;
                }

                var start_slot = start_node.outputs[start_node_slot];
                var end_slot = node.inputs[i];
                if (!start_slot || !end_slot) {
                    continue;
                }
                var start_dir =
                    start_slot.dir ||
                    (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);
                var end_dir =
                    end_slot.dir ||
                    (node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);

                this.renderLink(
                    ctx,
                    start_node_slotpos,
                    end_node_slotpos,
                    link,
                    false,
                    0,
                    null,
                    start_dir,
                    end_dir,
                );

                // event triggered rendered on top
                if (link && link._last_time && now - link._last_time < 1000) {
                    var f = 2.0 - (now - link._last_time) * 0.002;
                    var tmp = ctx.globalAlpha;
                    ctx.globalAlpha = tmp * f;
                    this.renderLink(
                        ctx,
                        start_node_slotpos,
                        end_node_slotpos,
                        link,
                        true,
                        f,
                        "white",
                        start_dir,
                        end_dir,
                    );
                    ctx.globalAlpha = tmp;
                }
            }
        }
        ctx.globalAlpha = 1;
    }

    /**
     * draws a link between two points
     * @method renderLink
     * @param {vec2} a start pos
     * @param {vec2} b end pos
     * @param {Object} link the link object with all the link info
     * @param {boolean} skip_border ignore the shadow of the link
     * @param {boolean} flow show flow animation (for events)
     * @param {string} color the color for the link
     * @param {number} start_dir the direction enum
     * @param {number} end_dir the direction enum
     * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
     **/
    renderLink(
        ctx,
        a,
        b,
        link,
        skip_border,
        flow,
        color,
        start_dir,
        end_dir,
        num_sublines,
    ) {
        if (link) {
            this.visible_links.push(link);
        }

        // choose color
        if (!color && link) {
            color = link.color || LGraphCanvas.link_type_colors[link.type];
        }
        if (!color) {
            color = this.default_link_color;
        }
        if (link != null && this.highlighted_links[link.id]) {
            color = "#FFF";
        }

        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = LiteGraph.distance(a, b);

        if (this.render_connections_border && this.ds.scale > 0.6) {
            ctx.lineWidth = this.connections_width + 4;
        }
        ctx.lineJoin = "round";
        num_sublines = num_sublines || 1;
        if (num_sublines > 1) {
            ctx.lineWidth = 0.5;
        }

        // begin line shape
        ctx.beginPath();
        for (let i = 0; i < num_sublines; i += 1) {
            var offsety = (i - (num_sublines - 1) * 0.5) * 5;

            if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                let start_offset_x = 0;
                let start_offset_y = 0;
                let end_offset_x = 0;
                let end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = dist * 0.25;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = dist * 0.25;
                        break;
                }
                ctx.bezierCurveTo(
                    a[0] + start_offset_x,
                    a[1] + start_offset_y + offsety,
                    b[0] + end_offset_x,
                    b[1] + end_offset_y + offsety,
                    b[0],
                    b[1] + offsety,
                );
            } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                let start_offset_x = 0;
                let start_offset_y = 0;
                let end_offset_x = 0;
                let end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = 1;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = 1;
                        break;
                }
                var l = 15;
                ctx.lineTo(
                    a[0] + start_offset_x * l,
                    a[1] + start_offset_y * l + offsety,
                );
                ctx.lineTo(
                    b[0] + end_offset_x * l,
                    b[1] + end_offset_y * l + offsety,
                );
                ctx.lineTo(b[0], b[1] + offsety);
            } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
                ctx.moveTo(a[0], a[1]);
                var start_x = a[0];
                var start_y = a[1];
                var end_x = b[0];
                var end_y = b[1];
                if (start_dir == LiteGraph.RIGHT) {
                    start_x += 10;
                } else {
                    start_y += 10;
                }
                if (end_dir == LiteGraph.LEFT) {
                    end_x -= 10;
                } else {
                    end_y -= 10;
                }
                ctx.lineTo(start_x, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, end_y);
                ctx.lineTo(end_x, end_y);
                ctx.lineTo(b[0], b[1]);
            } else {
                return;
            } // unknown
        }

        // rendering the outline of the connection can be a little bit slow
        if (
            this.render_connections_border &&
            this.ds.scale > 0.6 &&
            !skip_border
        ) {
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.stroke();
        }

        ctx.lineWidth = this.connections_width;
        ctx.fillStyle = ctx.strokeStyle = color;
        ctx.stroke();
        // end line shape

        var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);
        if (link && link._pos) {
            link._pos[0] = pos[0];
            link._pos[1] = pos[1];
        }

        // render arrow in the middle
        if (
            this.ds.scale >= 0.6 &&
            this.highquality_render &&
            end_dir != LiteGraph.CENTER
        ) {
            // render arrow
            if (this.render_connection_arrows) {
                // compute two points in the connection
                var posA = this.computeConnectionPoint(
                    a,
                    b,
                    0.25,
                    start_dir,
                    end_dir,
                );
                var posB = this.computeConnectionPoint(
                    a,
                    b,
                    0.26,
                    start_dir,
                    end_dir,
                );
                var posC = this.computeConnectionPoint(
                    a,
                    b,
                    0.75,
                    start_dir,
                    end_dir,
                );
                var posD = this.computeConnectionPoint(
                    a,
                    b,
                    0.76,
                    start_dir,
                    end_dir,
                );

                // compute the angle between them so the arrow points in the right direction
                var angleA = 0;
                var angleB = 0;
                if (this.render_curved_connections) {
                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
                } else {
                    angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
                }

                // render arrow
                ctx.save();
                ctx.translate(posA[0], posA[1]);
                ctx.rotate(angleA);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(posC[0], posC[1]);
                ctx.rotate(angleB);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
            }

            // circle
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // render flowing points
        if (flow) {
            ctx.fillStyle = color;
            for (let i = 0; i < 5; ++i) {
                var f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1;
                pos = this.computeConnectionPoint(
                    a,
                    b,
                    f,
                    start_dir,
                    end_dir,
                );
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }

    // returns the link center point based on curvature
    computeConnectionPoint(a, b, t, start_dir, end_dir) {
        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = LiteGraph.distance(a, b);
        var p0 = a;
        var p1 = [a[0], a[1]];
        var p2 = [b[0], b[1]];
        var p3 = b;

        switch (start_dir) {
            case LiteGraph.LEFT:
                p1[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p1[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p1[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p1[1] += dist * 0.25;
                break;
        }
        switch (end_dir) {
            case LiteGraph.LEFT:
                p2[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p2[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p2[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p2[1] += dist * 0.25;
                break;
        }

        var c1 = (1 - t) * (1 - t) * (1 - t);
        var c2 = 3 * ((1 - t) * (1 - t)) * t;
        var c3 = 3 * (1 - t) * (t * t);
        var c4 = t * t * t;

        var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];
        var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];
        return [x, y];
    }

    drawExecutionOrder(ctx) {
        ctx.shadowColor = "transparent";
        ctx.globalAlpha = 0.25;

        ctx.textAlign = "center";
        ctx.strokeStyle = "white";
        ctx.globalAlpha = 0.75;

        var visible_nodes = this.visible_nodes;
        for (let i = 0; i < visible_nodes.length; ++i) {
            var node = visible_nodes[i];
            ctx.fillStyle = "black";
            ctx.fillRect(
                node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
                node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT,
            );
            if (node.order == 0) {
                ctx.strokeRect(
                    node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    LiteGraph.NODE_TITLE_HEIGHT,
                    LiteGraph.NODE_TITLE_HEIGHT,
                );
            }
            ctx.fillStyle = "#FFF";
            ctx.fillText(
                node.order,
                node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
                node.pos[1] - 6,
            );
        }
        ctx.globalAlpha = 1;
    }

    /**
     * draws the widgets stored inside a node
     * @method drawNodeWidgets
     **/
    drawNodeWidgets(node, posY, ctx, active_widget) {
        if (!node.widgets || !node.widgets.length) {
            return 0;
        }
        var width = node.size[0];
        var widgets = node.widgets;
        posY += 2;
        var H = LiteGraph.NODE_WIDGET_HEIGHT;
        var show_text = !this.lowQualityRenderingRequired(0.5);
        ctx.save();
        ctx.globalAlpha = this.editor_alpha;
        var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
        var background_color = LiteGraph.WIDGET_BGCOLOR;
        var text_color = LiteGraph.WIDGET_TEXT_COLOR;
        var secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
        var margin = 15;
        var is_over_widget = false;

        for (let i = 0; i < widgets.length; ++i) {
            var w = widgets[i];
            var y = posY;
            if (w.y) {
                y = w.y;
            }
            w.last_y = y;
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = "#222";
            ctx.textAlign = "left";
            // ctx.lineWidth = 2;
            if(w.disabled)
                ctx.globalAlpha *= 0.5;
            var widget_width = w.width || width;

            // is over this widget?
            is_over_widget = this.over_widget == w;
            // is this widget active(clicked)?
            if(active_widget == w){
                //
            }
            
            switch (w.type) {
                case "button":
                    if (w.clicked) {
                        ctx.fillStyle = "#AAA";
                        w.clicked = false;
                        this.dirty_canvas = true;
                    }
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
                    if(show_text && !w.disabled)
                        ctx.strokeRect( margin, y, widget_width - margin * 2, H );
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        if(is_over_widget || this.options.hide_widget_label_when_small===true || this.options.hide_widget_label_when_small < width){
                            ctx.fillText(w.label || w.name, widget_width * 0.5, y + H * 0.7);
                        }
                    }
                    break;
                case "toggle":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
                        ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);
                    else
                        ctx.rect(margin, y, widget_width - margin * 2, H );
                    ctx.fill();
                    if(show_text && !w.disabled)
                        ctx.stroke();
                    ctx.fillStyle = w.value ? "#89A" : "#333";
                    ctx.beginPath();
                    ctx.arc( widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2 );
                    ctx.fill();
                    if (show_text) {
                        ctx.fillStyle = secondary_text_color;
                        const label = w.label || w.name;
                        if (label != null) {
                            if(is_over_widget || this.options.hide_widget_label_when_small===true || this.options.hide_widget_label_when_small < width){
                                ctx.fillText(label, margin * 2, y + H * 0.7);
                            }
                        }
                        ctx.fillStyle = w.value ? text_color : secondary_text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(
                            w.value
                                ? w.options.on || "on"
                                : w.options.off || "off",
                            widget_width - 40,
                            y + H * 0.7,
                        );
                    }
                    break;
                case "slider":
                    ctx.fillStyle = background_color;
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
                    var range = w.options.max - w.options.min;
                    var nvalue = (w.value - w.options.min) / range;
                    if(nvalue < 0.0) nvalue = 0.0;
                    if(nvalue > 1.0) nvalue = 1.0;
                    ctx.fillStyle = w.options.hasOwnProperty("slider_color") ? w.options.slider_color : (active_widget == w ? "#89A" : "#678");
                    ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);
                    if(show_text && !w.disabled)
                        ctx.strokeRect(margin, y, widget_width - margin * 2, H);
                    if (w.marker) {
                        var marker_nvalue = (w.marker - w.options.min) / range;
                        if(marker_nvalue < 0.0) marker_nvalue = 0.0;
                        if(marker_nvalue > 1.0) marker_nvalue = 1.0;
                        ctx.fillStyle = w.options.hasOwnProperty("marker_color") ? w.options.marker_color : "#AA9";
                        ctx.fillRect( margin + marker_nvalue * (widget_width - margin * 2), y, 2, H );
                    }
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        if(is_over_widget || this.options.hide_widget_label_when_small===true || this.options.hide_widget_label_when_small < width){
                            ctx.fillText(
                                w.label ||
                                    w.name + "  "
                                    + LiteGraph.formatNumber(w.value, w.options.precision != null ? w.options.precision : 3)
                                ,
                                widget_width * 0.5,
                                y + H * 0.7,
                            );
                        }
                    }
                    break;
                case "number":
                case "combo":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if(show_text)
                        ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5] );
                    else
                        ctx.rect(margin, y, widget_width - margin * 2, H );
                    ctx.fill();
                    if (show_text) {
                        if(!w.disabled)
                            ctx.stroke();
                        ctx.fillStyle = text_color;
                        if(!w.disabled) {
                            ctx.beginPath();
                            ctx.moveTo(margin + 16, y + 5);
                            ctx.lineTo(margin + 6, y + H * 0.5);
                            ctx.lineTo(margin + 16, y + H - 5);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(widget_width - margin - 16, y + 5);
                            ctx.lineTo(widget_width - margin - 6, y + H * 0.5);
                            ctx.lineTo(widget_width - margin - 16, y + H - 5);
                            ctx.fill();
                        }
                        ctx.fillStyle = secondary_text_color;
                        if(is_over_widget || this.options.hide_widget_label_when_small===true || this.options.hide_widget_label_when_small < width){
                            ctx.fillText(w.label || w.name, margin * 2 + 5, y + H * 0.7);
                        }
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        if (w.type == "number") {
                            ctx.fillText(
                                LiteGraph.formatNumber(w.value, w.options.precision !== undefined ? w.options.precision : 3),
                                widget_width - margin * 2 - 20,
                                y + H * 0.7,
                            );
                        } else {
                            var v = w.value;
                            if( w.options.values ) {
                                var values = w.options.values;
                                if( values.constructor === Function )
                                    values = values();
                                if(values && values.constructor !== Array)
                                    v = values[w.value];
                            }
                            ctx.fillText(
                                v,
                                widget_width - margin * 2 - 20,
                                y + H * 0.7,
                            );
                        }
                    }
                    break;
                case "string":
                case "text":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
                        ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);
                    else
                        ctx.rect( margin, y, widget_width - margin * 2, H );
                    ctx.fill();
                    if (show_text) {
                        if(!w.disabled)
                            ctx.stroke();
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(margin, y, widget_width - margin * 2, H);
                        ctx.clip();

                        // ctx.stroke();
                        ctx.fillStyle = secondary_text_color;
                        const label = w.label || w.name;
                        if (label != null) {
                            if(is_over_widget || this.options.hide_widget_label_when_small===true || this.options.hide_widget_label_when_small < width){
                                ctx.fillText(label, margin * 2, y + H * 0.7);
                            }
                        }
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(String(w.value).substr(0,30), widget_width - margin * 2, y + H * 0.7); // 30 chars max
                        ctx.restore();
                    }
                    break;
                default:
                    if (w.draw) {
                        w.draw(ctx, node, widget_width, y, H);
                    }
                    break;
            }
            posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;
            ctx.globalAlpha = this.editor_alpha;

        }
        ctx.restore();
        ctx.textAlign = "left";
    }

    /**
     * process an event on widgets, or check overed widget if no event 
     * @method processNodeWidgets
     **/
    processNodeWidgets(node, pos, event, active_widget) {
        // if node has no widgets or not allowed interaction, return null
        if (!node.widgets || !node.widgets.length || (!this.allow_interaction && !node.flags.allow_interaction)) {
            if(!node.widgets || !node.widgets.length) LiteGraph.log_verbose("graph processNodeWidgets","no widgets for node", node);
            if(!this.allow_interaction && !node.flags.allow_interaction) LiteGraph.log_verbose("graph processNodeWidgets","interaction not allowed on graph and not overridden on node", node);
            return null;
        }

        var x = pos[0] - node.pos[0];
        var y = pos[1] - node.pos[1];
        var width = node.size[0];
        var height = LiteGraph.NODE_WIDGET_HEIGHT;
        var deltaX = event?.deltaX || event?.deltax || 0;
        var that = this;
        var ref_window = this.getCanvasWindow();
        var widget_width = width;
        var widget_height = height;

        for (let i = 0; i < node.widgets.length; ++i) {
            var w = node.widgets[i];
            if(!w || w.disabled)
                continue;
            if(typeof(w.computeSize)=="function"){
                const wSize = w.computeSize(node.size[0], node.size[1]);
                widget_width = wSize[0];
                widget_height = wSize[1];
            }else{
                widget_width = w.width || width;
                widget_height = w.height || height;
            }
            // outside
            if ( w != active_widget &&
                (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined) ){
                continue;
            }

            var old_value = w.value;

            LiteGraph.log_verbose("graph processNodeWidgets","has widget", w);

            // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {
            // inside widget
            if(event){
                switch (w.type) {
                    case "button":
                        if (event.type === "pointerdown") {
                            if (w.callback) {
                                LiteGraph.log_debug("graph processNodeWidgets","button, calling callback", w.callback);
                                setTimeout(function() {
                                    w.callback(w, that, node, pos, event);
                                }, 20);
                            }else{
                                LiteGraph.log_verbose("graph processNodeWidgets","button, has not callback", w);
                            }
                            w.clicked = true;
                            this.dirty_canvas = true;
                        }else{
                            LiteGraph.log_verbose("graph processNodeWidgets","button, event is not pointer down", event);
                        }
                        break;
                    case "slider":
                        var nvalue = LiteGraph.clamp((x - 15) / (widget_width - 30), 0, 1);
                        if(w.options.read_only) break;
                        w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
                        if (old_value != w.value) {
                            setTimeout(function() {
                                inner_value_change(w, w.value, old_value);
                            }, 20);
                        }
                        this.dirty_canvas = true;
                        break;
                    case "number":
                    case "combo":
                    case "enum":
                        if (event.type == "pointermove" && w.type == "number") {
                            if(deltaX)
                                w.value += deltaX * 0.1 * (w.options.step || 1);
                            if ( w.options.min != null && w.value < w.options.min ) {
                                w.value = w.options.min;
                            }
                            if ( w.options.max != null && w.value > w.options.max ) {
                                w.value = w.options.max;
                            }
                        } else if (event.type == "pointerdown") {
                            var values = w.options.values;
                            if (values && values.constructor === Function) {
                                values = w.options.values(w, node);
                            }
                            var values_list = null;

                            if( w.type != "number")
                                values_list = values.constructor === Array ? values : Object.keys(values);

                            let delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
                            if (w.type == "number") {
                                w.value += delta * (w.options.step || 1);
                                if ( w.options.min != null && w.value < w.options.min ) {
                                    w.value = w.options.min;
                                }
                                if ( w.options.max != null && w.value > w.options.max ) {
                                    w.value = w.options.max;
                                }
                            } else if (delta) { // clicked in arrow, used for combos
                                var index = -1;
                                this.last_mouseclick = 0; // avoids double click event
                                if(values.constructor === Object)
                                    index = values_list.indexOf( String( w.value ) ) + delta;
                                else
                                    index = values_list.indexOf( w.value ) + delta;
                                if (index >= values_list.length) {
                                    index = values_list.length - 1;
                                }
                                if (index < 0) {
                                    index = 0;
                                }
                                if( values.constructor === Array )
                                    w.value = values[index];
                                else
                                    w.value = index;
                            } else { // combo clicked
                                var text_values = values != values_list ? Object.values(values) : values;
                                let inner_clicked = function(v) {
                                    if(values != values_list)
                                        v = text_values.indexOf(v);
                                    this.value = v;
                                    inner_value_change(this, v, old_value);
                                    that.dirty_canvas = true;
                                    return false;
                                }
                                LiteGraph.ContextMenu(
                                    text_values, {
                                        scale: Math.max(1, this.ds.scale),
                                        event: event,
                                        className: "dark",
                                        callback: inner_clicked.bind(w),
                                    },
                                    ref_window,
                                );
                            }
                            // end mousedown
                        } else if(event.type == "pointerup" && w.type == "number") {
                            let delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
                            if (event.click_time < 200 && delta == 0) {
                                this.prompt(
                                    "Value",w.value,function(v) {
                                    // check if v is a valid equation or a number
                                        if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v)) {
                                            try {// solve the equation if possible
                                                v = eval(v);
                                            } catch (error) {
                                                LiteGraph.log_warn(error);
                                            }
                                        }
                                        this.value = Number(v);
                                        inner_value_change(this, this.value, old_value);
                                    }.bind(w),
                                    event,
                                );
                            }
                        }

                        if( old_value != w.value )
                            setTimeout(
                                function() {
                                    inner_value_change(this, this.value, old_value);
                                }.bind(w),
                                20,
                            );
                        this.dirty_canvas = true;
                        break;
                    case "toggle":
                        if (event.type == "pointerdown") {
                            w.value = !w.value;
                            setTimeout(function() {
                                inner_value_change(w, w.value);
                            }, 20);
                        }
                        break;
                    case "string":
                    case "text":
                        if (event.type == "pointerdown") {
                            this.prompt(
                                "Value",w.value,function(v) {
                                    // @TODO: this.value = v; // CHECK
                                    inner_value_change(this, v);
                                }.bind(w),
                                event,w.options ? w.options.multiline : false,
                            );
                        }
                        break;
                    default:
                        if (w.mouse) {
                            this.dirty_canvas = w.mouse(event, [x, y], node);
                        }
                        break;
                }
            }

            return w;
        }// end for

        function inner_value_change(widget, value, old_value) {
            LiteGraph.log_debug("inner_value_change for processNodeWidgets",widget,value);
            // value changed
            if( old_value != w.value ) {
                node.processCallbackHandlers("onWidgetChanged",{
                    def_cb: node.onWidgetChanged
                }, w.name, w.value, old_value, w);
                // node.graph._version++;
                node.graph.onGraphChanged({action: "widgetChanged", doSave: true}); // tag: graph event entrypoint
            }
            if(widget.type == "number") {
                value = Number(value);
            }
            widget.value = value;
            if ( widget.options && widget.options.property && node.properties[widget.options.property] !== undefined ) {
                node.setProperty( widget.options.property, value );
            }
            if (widget.callback) {
                widget.callback(widget.value, that, node, pos, event);
            }
        }

        return null;
    }

    /**
     * draws every group area in the background
     * @method drawGroups
     **/
    drawGroups(canvas, ctx) {
        if (!this.graph) {
            return;
        }

        var groups = this.graph._groups;

        ctx.save();

        for (let i = 0; i < groups.length; ++i) {
            var group = groups[i];

            if (!LiteGraph.overlapBounding(this.visible_area, group._bounding)) {
                continue;
            } // out of the visible area

            ctx.fillStyle = group.color || "#335";
            ctx.strokeStyle = group.color || "#335";
            if(this.options.groups_border_alpha>=0){
                if(ctx.setStrokeColor){ // only webkit
                    ctx.setStrokeColor(ctx.strokeStyle, this.options.groups_border_alpha);
                }
            }
            var pos = group._pos;
            var size = group._size;
            ctx.globalAlpha = this.options.groups_alpha * this.editor_alpha; // check, not affecting
            ctx.beginPath();
            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);
            ctx.fill();
            ctx.globalAlpha = this.editor_alpha;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0] - this.options.groups_triangle_handler_size, pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - this.options.groups_triangle_handler_size);
            ctx.fill();

            var font_size = group.font_size || this.options.groups_title_font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
            ctx.font = font_size + "px "+this.options.groups_title_font;
            ctx.textAlign = this.options.groups_title_alignment;
            if(this.options.groups_title_wrap){
                LiteGraph.canvasFillTextMultiline(ctx, group.title, pos[0] + 4, pos[1] + font_size, size[0], font_size);
            }else{
                ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);
            }
        }

        ctx.restore();
    }

    adjustNodesSize() {
        var nodes = this.graph._nodes;
        for (let i = 0; i < nodes.length; ++i) {
            nodes[i].size = nodes[i].computeSize();
        }
        this.setDirty(true, true);
    }

    /**
     * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
     * @method resize
     **/
    resize(width, height) {
        if (!width && !height) {
            var parent = this.canvas.parentNode;
            width = parent.offsetWidth;
            height = parent.offsetHeight;
            LiteGraph.log_debug("lgraphcanvas","resize","not passed: AUTO",parent,width,height);
        }else{
            LiteGraph.log_debug("lgraphcanvas","resize","passed",width,height,parent);
        }
        if (this.canvas.width == width && this.canvas.height == height) {
            return;
        }
        this.canvas.width = width;
        this.canvas.height = height;
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;
        this.setDirty(true, true);
    }

    /**
     * switches to live mode (node shapes are not rendered, only the content)
     * this feature was designed when graphs where meant to create user interfaces
     * @method switchLiveMode
     **/
    switchLiveMode(transition) {
        if (!transition) {
            this.live_mode = !this.live_mode;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
            return;
        }

        var self = this;
        var delta = this.live_mode ? 1.1 : 0.9;
        if (this.live_mode) {
            this.live_mode = false;
            this.editor_alpha = 0.1;
        }

        var t = setInterval(function() {
            self.editor_alpha *= delta;
            self.dirty_canvas = true;
            self.dirty_bgcanvas = true;

            if (delta < 1 && self.editor_alpha < 0.01) {
                clearInterval(t);
                if (delta < 1) {
                    self.live_mode = true;
                }
            }
            if (delta > 1 && self.editor_alpha > 0.99) {
                clearInterval(t);
                self.editor_alpha = 1;
            }
        }, 1);
    }

    /* @TODO: Validate this is never called
    onNodeSelectionChange() {
        return; // disabled
    }
    */

    /* this is an implementation for touch not in production and not ready
        */
    /* LGraphCanvas.prototype.touchHandler = function(event) {
        //alert("foo");
        var touches = event.changedTouches,
            first = touches[0],
            type = "";

        switch (event.type) {
            case "touchstart":
                type = "pointerdown";
                break;
            case "touchmove":
                type = "pointermove";
                break;
            case "touchend":
                type = "pointerup";
                break;
            default:
                return;
        }

        //initMouseEvent(type, canBubble, cancelable, view, clickCount,
        //           screenX, screenY, clientX, clientY, ctrlKey,
        //           altKey, shiftKey, metaKey, button, relatedTarget);

        // this is eventually a Dom object, get the LGraphCanvas back
        if(typeof this.getCanvasWindow == "undefined"){
            var window = this.lgraphcanvas.getCanvasWindow();
        }else{
            var window = this.getCanvasWindow();
        }

        var document = window.document;

        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(
            type,
            true,
            true,
            window,
            1,
            first.screenX,
            first.screenY,
            first.clientX,
            first.clientY,
            false,
            false,
            false,
            false,
            0, //left
            null
        );
        first.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    };*/

    /* CONTEXT MENU ********************/

    static onGroupAdd(info, entry, mouse_event) {
        const canvas = LGraphCanvas.active_canvas;
        var group = new LiteGraph.LGraphGroup();
        if(canvas.options.groups_add_around_selected && Object.keys(canvas.selected_nodes).length){
            const bounds = canvas.getBoundaryForSelection();
            if(bounds){ 
                const spacing = canvas.options.groups_add_default_spacing;
                const titleSpace = canvas.options.groups_title_font_size*1.5;
                group.pos = [   bounds[0] - spacing
                                ,bounds[1] - titleSpace - spacing
                            ];
                group.size = [  bounds[2] + (spacing*2)
                                ,bounds[3]+ titleSpace + (spacing*2)
                            ];
                LiteGraph.log_debug("lgraphcanvas","onGroupAdd","groups_add_around_selected",bounds,group);
            }else{
                group.pos = canvas.convertEventToCanvasOffset(mouse_event); // as default
            }
        }else{
            group.pos = canvas.convertEventToCanvasOffset(mouse_event);
        }
        canvas.graph.add(group);
    }

    /**
     * Determines the furthest nodes in each direction
     * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted
     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
     */
    static getBoundaryNodes(nodes) {
        let top = null;
        let right = null;
        let bottom = null;
        let left = null;
        for (const nID in nodes) {
            const node = nodes[nID];
            const [x, y] = node.pos;
            const [width, height] = node.size;

            if (top === null || y < top.pos[1]) {
                top = node;
            }
            if (right === null || x + width > right.pos[0] + right.size[0]) {
                right = node;
            }
            if (bottom === null || y + height > bottom.pos[1] + bottom.size[1]) {
                bottom = node;
            }
            if (left === null || x < left.pos[0]) {
                left = node;
            }
        }

        return {
            "top": top,
            "right": right,
            "bottom": bottom,
            "left": left,
        };
    }

    /**
     * Determines the furthest nodes in each direction for the currently selected nodes
     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
     */
    boundaryNodesForSelection() {
        return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));
    }

    // returns x, y, w, h
    getBoundaryForSelection(){
        const nodesBounds = this.boundaryNodesForSelection();
        if(!nodesBounds || nodesBounds.left===null) return false;
        const ln = nodesBounds.left.getBounding();
        const tn = nodesBounds.top.getBounding();
        const rn = nodesBounds.right.getBounding();
        const bn = nodesBounds.bottom.getBounding();
        return [ ln[0]
                ,tn[1]
                ,rn[0]+rn[2] - ln[0]
                ,bn[1]+bn[3] - tn[1]
            ];
    }

    getCoordinateCenter(ob4v){
        return [ ob4v[0]+(ob4v[2]/2), ob4v[1]+(ob4v[3]/2) ];
    }

    /**
     *
     * @param {LGraphNode[]} nodes a list of nodes
     * @param {"top"|"bottom"|"left"|"right"} direction Direction to align the nodes
     * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)
     */
    static alignNodes(nodes, direction, align_to) {
        if (!nodes) {
            return;
        }

        const canvas = LGraphCanvas.active_canvas;
        let boundaryNodes = []
        if (align_to === undefined) {
            boundaryNodes = LGraphCanvas.getBoundaryNodes(nodes)
        } else {
            boundaryNodes = {
                "top": align_to,
                "right": align_to,
                "bottom": align_to,
                "left": align_to,
            }
        }

        for (const [_, node] of Object.entries(canvas.selected_nodes)) {
            switch (direction) {
                case "right":
                    node.pos[0] = boundaryNodes["right"].pos[0] + boundaryNodes["right"].size[0] - node.size[0];
                    break;
                case "left":
                    node.pos[0] = boundaryNodes["left"].pos[0];
                    break;
                case "top":
                    node.pos[1] = boundaryNodes["top"].pos[1];
                    break;
                case "bottom":
                    node.pos[1] = boundaryNodes["bottom"].pos[1] + boundaryNodes["bottom"].size[1] - node.size[1];
                    break;
            }
        }

        canvas.dirty_canvas = true;
        canvas.dirty_bgcanvas = true;
    }

    static onNodeAlign(value, options, event, prev_menu, node) {
        LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
            event: event,
            callback: inner_clicked,
            parentMenu: prev_menu,
        });

        function inner_clicked(value) {
            LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase(), node);
        }
    }

    static onGroupAlign(value, options, event, prev_menu) {
        LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
            event: event,
            callback: inner_clicked,
            parentMenu: prev_menu,
        });

        function inner_clicked(value) {
            LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase());
        }
    }

    static onMenuAdd(node, options, e, prev_menu, callback) {

        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();
        var graph = canvas.graph;
        if (!graph)
            return;

        function inner_onMenuAdded(base_category, prev_menu) {

            var categories = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category) {
                return category.startsWith(base_category)
            });
            var entries = [];

            categories.map(function(category) {

                if (!category)
                    return;

                var base_category_regex = new RegExp('^(' + base_category + ')');
                var category_name = category.replace(base_category_regex,"").split('/')[0];
                var category_path = base_category === '' ? category_name + '/' : base_category + category_name + '/';

                var name = category_name;
                if(name.indexOf("::") != -1) // in case it has a namespace like "shader::math/rand" it hides the namespace
                    name = name.split("::")[1];

                var index = entries.findIndex(function(entry) {
                    return entry.value === category_path
                });
                if (index === -1) {
                    entries.push({
                        value: category_path,
                        content: name,
                        has_submenu: true,
                        callback: function(value, event, mouseEvent, contextMenu) {
                            LiteGraph.log_debug("onMenuAdd","inner_onMenuAdded","categories callback",...arguments);
                            inner_onMenuAdded(value.value, contextMenu);
                        },
                    });
                }

            });

            var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);
            nodes.map(function(node) {

                if (node.skip_list)
                    return;

                var entry = {
                    value: node.type,
                    content: node.title,
                    has_submenu: false ,
                    callback: function(value, event, mouseEvent, contextMenu) {
                        var first_event = contextMenu.getFirstEvent();
                        canvas.graph.beforeChange();
                        var node = LiteGraph.createNode(value.value);
                        LiteGraph.log_debug("onMenuAdd","inner_onMenuAdded","node entry callback",first_event,...arguments);
                        if (node) {
                            node.pos = canvas.convertEventToCanvasOffset(first_event);
                            canvas.graph.add(node);
                        }
                        if(callback){
                            callback(node);
                        }
                        canvas.graph.afterChange();
                    },
                };

                entries.push(entry);

            });

            const e_check = e ? e : options.event;
            // LiteGraph.log_debug("lgraphcanvas", "onMenuAdd", "inner_onMenuAdded", "opening ContextMenu", e, options);
            LiteGraph.log_debug("lgraphcanvas", "onMenuAdd", "inner_onMenuAdded", "opening ContextMenu", entries, { event: e_check, parentMenu: prev_menu }, ref_window);

            LiteGraph.ContextMenu( entries, { event: e_check, parentMenu: prev_menu }, ref_window );

        }

        inner_onMenuAdded('',prev_menu);
        return false;

    }

    static onMenuCollapseAll() {}
    static onMenuNodeEdit() {}

    static showMenuNodeOptionalInputs(v, options, e, prev_menu, node) {
        if (!node) {
            return;
        }

        var that = this;
        let r = null;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        options = node.optional_inputs;
        r = node.processCallbackHandlers("onGetInputs",{
            def_cb: node.onGetInputs
        });
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                options = r.return_value;
            }else if(typeof(r.length)!=="undefined"){
                options = r;
            }
        }

        var entries = [];
        if (options) {
            for (let i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    entries.push(null);
                    continue;
                }
                var label = entry[0];
                if(!entry[2])
                    entry[2] = {};

                if (entry[2].label) {
                    label = entry[2].label;
                }

                entry[2].removable = true;
                entry[2].optional = true;
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.ACTION) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        // add callback for modifing the menu elements onMenuNodeInputs
        r = node.processCallbackHandlers("onMenuNodeInputs",{
            def_cb: node.onMenuNodeInputs
        }, entries);
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                entries = r.return_value;
            }
        }

        if (LiteGraph.do_add_triggers_slots) { // canvas.allow_addOutSlot_onExecuted
            if (node.findInputSlot("onTrigger") == -1) {
                entries.push({content: "On Trigger", value: ["onTrigger", LiteGraph.EVENT, {nameLocked: true, removable: true, optional: true}], className: "event"}); // , opts: {}
            }
        }

        if (!entries.length) {
            LiteGraph.log_debug("lgraphcanvas","showMenuNodeOptionalInputs","no input entries");
            return;
        }

        LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node,
            },
            ref_window,
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (v.value) {
                node.graph.beforeChange();
                var slotOpts = {}; // TODO CHECK THIS :: can be removed: removabled:true? .. optional: true?
                if (v.value[2]) slotOpts = Object.assign(slotOpts, v.value[2]);

                node.addInput(v.value[0], v.value[1], slotOpts);
                // a callback to the node when adding a slot
                node.processCallbackHandlers("onNodeInputAdd",{
                    def_cb: node.onNodeInputAdd
                }, v.value);
                node.setDirtyCanvas(true, true);
                node.graph.afterChange();
            }
        }

        return false;
    }

    static showMenuNodeOptionalOutputs(v, options, e, prev_menu, node) {
        if (!node) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        options = node.optional_outputs;
        let r = node.processCallbackHandlers("onGetOutputs",{
            def_cb: node.onGetOutputs
        });
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                options = r.return_value;
            }else if(typeof(r.length)!=="undefined"){
                options = r;
            }
        }

        var entries = [];
        if (options) {
            for (let i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    // separator?
                    entries.push(null);
                    continue;
                }

                if (
                    node.flags &&
                    node.flags.skip_repeated_outputs &&
                    node.findOutputSlot(entry[0]) != -1
                ) {
                    continue;
                } // skip the ones already on
                var label = entry[0];
                if(!entry[2])
                    entry[2] = {};
                if (entry[2].label) {
                    label = entry[2].label;
                }
                entry[2].removable = true;
                entry[2].optional = true;
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.EVENT) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        // add callback for modifing the menu elements onMenuNodeOutputs
        r = node.processCallbackHandlers("onMenuNodeOutputs",{
            def_cb: node.onMenuNodeOutputs
        }, entries);
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                entries = r.return_value;
            }
        }

        if (LiteGraph.do_add_triggers_slots) { // canvas.allow_addOutSlot_onExecuted
            if (node.findOutputSlot("onExecuted") == -1) {
                entries.push({
                    content: "On Executed",
                    value: [
                        "onExecuted",
                        LiteGraph.EVENT,
                        {
                            nameLocked: true,
                            removable: true,
                            optional: true,
                        },
                    ],
                    className: "event",
                });
            }
        }

        if (!entries.length) {
            return;
        }

        LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node,
            },
            ref_window,
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (!v.value) {
                return;
            }

            var value = v.value[1];

            if (
                value &&
                (value.constructor === Object || value.constructor === Array)
            ) {
                // submenu why?
                var entries = [];
                for (let i in value) {
                    entries.push({ content: i, value: value[i] });
                }
                LiteGraph.ContextMenu(entries, {
                    event: e,
                    callback: inner_clicked,
                    parentMenu: prev_menu,
                    node: node,
                });
                return false;
            } else {
                node.graph.beforeChange();
                var slotOpts = {}; // TODO CHECK THIS :: can be removed: removabled:true? .. optional: true?
                if (v.value[2]) slotOpts = Object.assign(slotOpts, v.value[2]);
                // if(v.opts) slotOpts = Object.assign(slotOpts, v.opts);

                node.addOutput(v.value[0], v.value[1], slotOpts);
                // a callback to the node when adding a slot
                node.processCallbackHandlers("onNodeOutputAdd",{
                    def_cb: node.onNodeOutputAdd
                }, v.value);
                node.setDirtyCanvas(true, true);
                node.graph.afterChange();
            }
        }

        return false;
    }

    doShowMenuNodeProperties(element, options, e, prev_menu, node) {
        LGraphCanvas.onShowMenuNodeProperties(element, options, e, prev_menu, node);
    }

    static onShowMenuNodeProperties(element, options, e, prev_menu, node) {
        if (!node || !node.properties) {
            return;
        }

        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        let entries = [];
        for (let i in node.properties) {
            let value = node.properties[i] !== undefined ? node.properties[i] : " ";
            if( typeof value == "object" )
                value = JSON.stringify(value);
            let info = node.getPropertyInfo(i);
            let info_type = info && info!==null ? info.type : "string";
            let propName = info && info!==null && info.label ? info.label : i;

            // parse combo
            if(info_type == "enum" || info_type == "combo"){
                value = LGraphCanvas.getPropertyPrintableValue( value, info.values );
            }

            // value could contain invalid html characters, clean that
            value = LGraphCanvas.decodeHTML(value);
            let htmlEntry = "<span class='property_name'>"
                                + propName
                            + "</span>"
                            + "<span class='property_value'>"
                                + value
                            + "</span>";
            
            let callbacks_on_element_created = []; // can pass in element construction function

            // allow property binding
            if(LiteGraph.properties_allow_input_binding){
                let relSlotOb = node.findInputSlot(propName, true);
                let hasSlotByName = relSlotOb !== -1;
                let slotBinded = hasSlotByName ? relSlotOb.param_bind : false;
                htmlEntry += "<span class='property_input_bind'>"
                                + ( slotBinded
                                        // input exists and is binded
                                        ?   "<span class='property_input_binded'>linked</span>"
                                        // input is not binded or does not exist
                                        :   ( hasSlotByName
                                                ?   "<span class='property_input_exist'>"
                                                        + "<input type='button' class='btn_confirm btn_bind_property_to_input' value='link input' />"
                                                    + "</span>"
                                                : "<span class=''>"
                                                        + "<input type='button' class='btn_confirm btn_bind_property_to_input' value='create input' />"
                                                    + "</span>"
                                            )
                                    )
                            +"</span>";
                    callbacks_on_element_created.push(function(el, menu){
                    LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","calling callback_on_element_created",propName,el,slotBinded,relSlotOb);
                    let btnConfirm = el.querySelector('.btn_confirm');
                    if(!btnConfirm){
                        el.disabled = "disabled";
                        LiteGraph.log_warn("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties",".btn_confirm not found",propName,el);
                    }else{
                        LiteGraph.log_info("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties",".btn_confirm binding!",btnConfirm,propName);
                        btnConfirm.addEventListener("click", function(ev){
                            relSlotOb = node.findInputSlot(propName, true);
                            hasSlotByName = relSlotOb !== -1;
                            slotBinded = hasSlotByName ? relSlotOb.param_bind : false;
                            if ( !slotBinded ){
                                if( !hasSlotByName ){
                                    LiteGraph.log_info("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","CREATING NEW INPUT ON NODE",relSlotOb,propName);
                                    // propName
                                    node.addInput(propName, info_type, {removable: true, nameLocked: true});
                                    relSlotOb = node.findInputSlot(propName, true);
                                }
                                LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","Linking property to input",relSlotOb);
                                relSlotOb.param_bind = true;
                                menu.close?.(ev, true);
                            }else{
                                LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","Property already binded",relSlotOb,propName);
                            }
                            ev.preventDefault();
                            ev.stopPropagation();
                        });
                    }
                });
            }
            // WIP TODO RESTART FROM HERE allow widget binding
            if(LiteGraph.properties_allow_widget_binding){
                const relWidgetOb = node.widgets?.find((widget) => widget && widget.options?.property === propName);
                const hasWidgetByName = relWidgetOb && relWidgetOb !== null;
            //     let relSlotOb = node.findInputSlot(propName, true);
            //     let hasSlotByName = relSlotOb !== -1;
            //     let slotBinded = hasSlotByName ? relSlotOb.param_bind : false;
            //     htmlEntry += "<span class='property_input_bind'>"
            //                     + ( slotBinded
            //                             // input exists and is binded
            //                             ?   "<span class='property_input_binded'>linked</span>"
            //                             // input is not binded or does not exist
            //                             :   ( hasSlotByName
            //                                     ?   "<span class='property_input_exist'>"
            //                                             + "<input type='button' class='btn_confirm btn_bind_property_to_input' value='link input' />"
            //                                         + "</span>"
            //                                     : "<span class=''>"
            //                                             + "<input type='button' class='btn_confirm btn_bind_property_to_input' value='create input' />"
            //                                         + "</span>"
            //                                 )
            //                         )
            //                 +"</span>";
            //         callbacks_on_element_created.push(function(el, menu){
            //         LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","calling callback_on_element_created",propName,el,slotBinded,relSlotOb);
            //         let btnConfirm = el.querySelector('.btn_confirm');
            //         if(!btnConfirm){
            //             el.disabled = "disabled";
            //             LiteGraph.log_warn("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties",".btn_confirm not found",propName,el);
            //         }else{
            //             LiteGraph.log_info("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties",".btn_confirm binding!",btnConfirm,propName);
            //             btnConfirm.addEventListener("click", function(ev){
            //                 relSlotOb = node.findInputSlot(propName, true);
            //                 hasSlotByName = relSlotOb !== -1;
            //                 slotBinded = hasSlotByName ? relSlotOb.param_bind : false;
            //                 if ( !slotBinded ){
            //                     if( !hasSlotByName ){
            //                         LiteGraph.log_info("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","CREATING NEW INPUT ON NODE",relSlotOb,propName);
            //                         // propName
            //                         node.addInput(propName, info_type, {removable: true, nameLocked: true});
            //                         relSlotOb = node.findInputSlot(propName, true);
            //                     }
            //                     LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","Linking property to input",relSlotOb);
            //                     relSlotOb.param_bind = true;
            //                     menu.close?.(ev, true);
            //                 }else{
            //                     LiteGraph.log_debug("lgraphcanvas","showLinkMenu","onShowMenuNodeProperties","callback_on_element_created","properties_allow_input_binding","btnConfirm","Property already binded",relSlotOb,propName);
            //                 }
            //                 ev.preventDefault();
            //                 ev.stopPropagation();
            //             });
            //         }
            //     });
            }

            entries.push({
                content: htmlEntry,
                value: i,
                callbacks_on_element_created: callbacks_on_element_created
            });
        }
        if (!entries.length) {
            return;
        }

        LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                allow_html: true,
                node: node,
            },
            ref_window,
        );

        function inner_clicked(v, options, event, parent_menu, rel_node) {
            LiteGraph.log_debug("lgraphcanvas", "onShowMenuNodeProperties", "inncer_clicked", this, ...arguments);
            if (!node) {
                return;
            }
            if( !this.disabled && !v.disabled ){
                var rect = this.getBoundingClientRect();
                canvas.showEditPropertyValue(node, v.value, { position: [rect.left, rect.top] });
            }
        }

        return false;
    }

    static decodeHTML(str) {
        var e = document.createElement("div");
        e.innerText = str;
        return e.innerHTML;
    }

    static onMenuResizeNode(value, options, e, menu, node) {
        if (!node) {
            return;
        }

        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();
        var graph = canvas.graph;
        graph?.onGraphChanged({action: "resize", doSave: true});
        
        const fApplyMultiNode = (node) => {
            node.size = node.computeSize();
            node.processCallbackHandlers("onResize",{
                def_cb: node.onResize
            }, node.size);
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
            fApplyMultiNode(node);
        }else{
            for (let i in graphcanvas.selected_nodes) {
                fApplyMultiNode(graphcanvas.selected_nodes[i]);
            }
        }

        node.setDirtyCanvas(true, true);
    }

    showLinkMenu(link, e) {
        var that = this;
        LiteGraph.log_verbose(link);
        var node_left = that.graph.getNodeById( link.origin_id );
        var node_right = that.graph.getNodeById( link.target_id );
        var fromType = false;
        if (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;
        var destType = false;
        if (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;

        var options = ["Add Node",null,"Delete",null];


        var menu = LiteGraph.ContextMenu(options, {
            event: e,
            title: link.data != null ? link.data.constructor.name : null,
            callback: inner_clicked,
        });

        function inner_clicked(v,options,e) {
            switch (v) {
                case "Add Node":
                    LiteGraph.log_debug("lgraphcanvas","showLinkMenu","inner_clicked","calling onMenuAdd");
                    LGraphCanvas.onMenuAdd(null, null, e, menu, function(node) {
                        if(!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length) {
                            return;
                        }
                        LiteGraph.log_debug("lgraphcanvas","showLinkMenu","inner_clicked","node autoconnect on add node on link");
                        // leave the connection type checking inside connectByType
                        if (node_left.connectByType( link.origin_slot, node, fromType )) {
                            node.connectByType( link.target_slot, node_right, destType );
                            node.pos[0] -= node.size[0] * 0.5;
                        }
                    });
                    break;

                case "Delete":
                    LiteGraph.log_debug("lgraphcanvas","showLinkMenu","inner_clicked","remove link");
                    that.graph.removeLink(link.id);
                    break;
                default:
                    LiteGraph.log_debug("lgraphcanvas","showLinkMenu","inner_clicked","node in the middle or other operation",...arguments);
                    /* var nodeCreated = createDefaultNodeForSlot({   nodeFrom: node_left
                                                                    ,slotFrom: link.origin_slot
                                                                    ,nodeTo: node
                                                                    ,slotTo: link.target_slot
                                                                    ,e: e
                                                                    ,nodeType: "AUTO"
                                                                });
                    if(nodeCreated) LiteGraph.log_debug("new node in beetween "+v+" created");*/
            }
        }

        return false;
    }

    createDefaultNodeForSlot(optPass = {}) { // addNodeMenu for connection
        var opts = Object.assign(
            {
                nodeFrom: null, // input
                slotFrom: null, // input
                nodeTo: null, // output
                slotTo: null, // output
                position: [],	// pass the event coords
                nodeType: null,	// choose a nodetype to add, AUTO to set at first good
                posAdd: [0,0],	// adjust x,y
                posSizeFix: [0,0], // alpha, adjust the position x,y based on the new node size w,h
            },
            optPass,
        );
        var that = this;

        var isFrom = opts.nodeFrom && opts.slotFrom!==null;
        var isTo = !isFrom && opts.nodeTo && opts.slotTo!==null;

        if (!isFrom && !isTo) {
            LiteGraph.log_warn("lgraphcanvas","createDefaultNodeForSlot","No data passed "+opts.nodeFrom+" "+opts.slotFrom+" "+opts.nodeTo+" "+opts.slotTo);
            return false;
        }
        if (!opts.nodeType) {
            LiteGraph.log_warn("lgraphcanvas","createDefaultNodeForSlot","No type");
            return false;
        }

        var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
        var slotX = isFrom ? opts.slotFrom : opts.slotTo;

        var iSlotConn = false;
        switch (typeof slotX) {
            case "string":
                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX,false) : nodeX.findInputSlot(slotX,false);
                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
                break;
            case "object":
                // ok slotX
                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
                break;
            case "number":
                iSlotConn = slotX;
                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
                break;
            default:
                // bad ?
                // iSlotConn = 0;
                LiteGraph.log_warn("lgraphcanvas","createDefaultNodeForSlot","Cant get slot information "+slotX);
                return false;
        }

        if (slotX===false || iSlotConn===false) {
            LiteGraph.log_warn("lgraphcanvas","createDefaultNodeForSlot","bad slotX "+slotX+" "+iSlotConn);
        }

        // check for defaults nodes for this slottype
        var fromSlotType = slotX.type==LiteGraph.EVENT?"_event_":slotX.type;
        var slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
        if(slotTypesDefault && slotTypesDefault[fromSlotType]) {
            if (slotX.link !== null) {
                // is connected
            }else{
                // is not not connected
            }
            var nodeNewType = false;
            if(typeof slotTypesDefault[fromSlotType] == "object") {
                for(var typeX in slotTypesDefault[fromSlotType]) {
                    if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == "AUTO") {
                        nodeNewType = slotTypesDefault[fromSlotType][typeX];
                        LiteGraph.log_verbose("lgraphcanvas","createDefaultNodeForSlot","opts.nodeType == slotTypesDefault[fromSlotType][typeX] :: "+opts.nodeType);
                        break; // --------
                    }
                }
            } else {
                if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == "AUTO")
                    nodeNewType = slotTypesDefault[fromSlotType];
            }
            if (nodeNewType) {
                var nodeNewOpts = false;
                if (typeof nodeNewType == "object" && nodeNewType.node) {
                    nodeNewOpts = nodeNewType;
                    nodeNewType = nodeNewType.node;
                }

                // that.graph.beforeChange();

                var newNode = LiteGraph.createNode(nodeNewType);
                if(newNode) {
                    // if is object pass options
                    if (nodeNewOpts) {
                        if (nodeNewOpts.properties) {
                            for (const [key, value] of Object.entries(nodeNewOpts.properties)) {
                                newNode.addProperty(key, value);
                            }
                        }
                        if (nodeNewOpts.inputs) {
                            newNode.inputs = [];
                            Object.values(nodeNewOpts.inputs).forEach((value) => {
                                newNode.addOutput(value[0], value[1]);
                            });
                        }
                        if (nodeNewOpts.outputs) {
                            newNode.outputs = [];
                            Object.values(nodeNewOpts.outputs).forEach((value) => {
                                newNode.addOutput(value[0], value[1]);
                            });
                        }
                        if (nodeNewOpts.title) {
                            newNode.title = nodeNewOpts.title;
                        }
                        if (nodeNewOpts.json) {
                            newNode.configure(nodeNewOpts.json);
                        }

                    }

                    // add the node
                    that.graph.add(newNode);
                    newNode.pos = [
                        opts.position[0]+opts.posAdd[0]+(opts.posSizeFix[0]?opts.posSizeFix[0]*newNode.size[0]:0),
                        opts.position[1]+opts.posAdd[1]+(opts.posSizeFix[1]?opts.posSizeFix[1]*newNode.size[1]:0),
                    ]; // that.last_click_position; //[e.canvasX+30, e.canvasX+5];*/

                    // that.graph.afterChange();

                    // connect the two!
                    if (isFrom) {
                        opts.nodeFrom.connectByType( iSlotConn, newNode, fromSlotType );
                    }else{
                        opts.nodeTo.connectByTypeOutput( iSlotConn, newNode, fromSlotType );
                    }

                    /* if connecting in between
                    if (isFrom && isTo){
                        //@TODO
                        // managing externally ? eg. link
                    }
                    */

                    return true;

                }else{
                    LiteGraph.log_warn("lgraphcanvas","createDefaultNodeForSlot","failed creating "+nodeNewType);
                }
            }
        }
        return false;
    }

    showConnectionMenu(optPass = {}) { // addNodeMenu for connection

        var opts = Object.assign({
            nodeFrom: null, // input
            slotFrom: null, // input
            nodeTo: null, // output
            slotTo: null, // output
            e: null,
            isCustomEvent: false
        },optPass);

        var that = this;
        var isFrom = opts.nodeFrom && opts.slotFrom;
        var isTo = !isFrom && opts.nodeTo && opts.slotTo;

        if (!isFrom && !isTo) {
            LiteGraph.log_warn("lgraphcanvas","showConnectionMenu","No data passed to showConnectionMenu");
            return false;
        }

        var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
        var slotX = isFrom ? opts.slotFrom : opts.slotTo;

        var iSlotConn = false;
        switch (typeof slotX) {
            case "string":
                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX,false) : nodeX.findInputSlot(slotX,false);
                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
                break;
            case "object":
                // ok slotX
                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
                break;
            case "number":
                iSlotConn = slotX;
                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
                break;
            default:
                // bad ?
                // iSlotConn = 0;
                LiteGraph.log_warn("lgraphcanvas","showConnectionMenu","Cant get slot information "+slotX);
                return false;
        }

        var options = ["Add Node",null];

        if (that.allow_searchbox) {
            options.push("Search");
            options.push(null);
        }

        // get defaults nodes for this slottype
        const fromSlotType = slotX.type === LiteGraph.EVENT ? "_event_" : slotX.type;
        const slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;

        if (slotTypesDefault && slotTypesDefault[fromSlotType]) {
            const slotType = slotTypesDefault[fromSlotType];

            if (Array.isArray(slotType) || typeof slotType === "object") {
                Object.values(slotType).forEach((typeX) => {
                    options.push(typeX);
                });
            } else {
                options.push(slotType);
            }
        }

        // build menu
        var menu = LiteGraph.ContextMenu(options, {
            event: opts.e,
            isCustomEvent: opts.isCustomEvent,
            title: (slotX && slotX.name!="" ? (slotX.name + (fromSlotType?" | ":"")) : "")+(slotX && fromSlotType ? fromSlotType : ""),
            callback: (v, options, e) => {
                const cases = {
                    "Add Node": () => {
                        LiteGraph.log_debug("lgraphcanvas","showConnectionMenu","callback","Add Node calling onMenuAdd",v,options,e);
                        LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {
                            isFrom ? opts.nodeFrom.connectByType(iSlotConn, node, fromSlotType) : opts.nodeTo.connectByTypeOutput(iSlotConn, node, fromSlotType);
                        });
                    },
                    "Search": () => {
                        isFrom ? that.showSearchBox(e, {node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType}) : that.showSearchBox(e, {node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType});
                    },
                    "default": () => {
                        LiteGraph.log_debug("lgraphcanvas","showConnectionMenu","callback","createDefaultNodeForSlot",v,options,e);
                        // const new_pos = this.convertOffsetToEditorArea([opts.e.clientX, opts.e.clientY]);
                        const new_pos = [opts.e.canvasX, opts.e.canvasY];
                        that.createDefaultNodeForSlot(Object.assign(opts, {position: new_pos, nodeType: v}));
                    },
                };

                // Execute the corresponding function based on the value of v
                (cases[v] || cases["default"])();
            },
        });

        return false;
    }

    doShowNodeInfoEditor(node, item, e, options){
        LGraphCanvas.onShowNodeInfoEditor(item, options, e, null, node);
    }

    // TODO refactor :: this is used fot title but not for properties!
    static onShowNodeInfoEditor(item, options, e, menu, node) {
        var property = item.property || "title";
        var value = node[property];

        // TODO refactor :: use createDialog ?

        var dialog = document.createElement("div");
        dialog.is_modified = false;
        dialog.className = "graphdialog";
        dialog.innerHTML =
            "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
        dialog.close = () => {
            dialog.parentNode?.removeChild(dialog);
        };
        var title = dialog.querySelector(".name");
        title.innerText = property;
        var input = dialog.querySelector(".value");

        const inner = () => {
            if (input) {
                setValue(input.value);
            }
        };

        if (input) {
            input.value = value;
            input.addEventListener("blur", function(_event) {
                this.focus();
            });
            input.addEventListener("keydown", function(e) {
                dialog.is_modified = true;
                if (e.keyCode == 27) {
                    // ESC
                    dialog.close();
                } else if (e.keyCode == 13) {
                    inner(); // save
                } else if (e.keyCode != 13 && e.target.localName != "textarea") {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
            });
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);
        canvas.parentNode.appendChild(dialog);

        if(input) input.focus();

        let dialogCloseTimer = null;

        dialog.addEventListener("pointerleave", (_event) => {
            if (LiteGraph.dialog_close_on_mouse_leave && !dialog.is_modified) {
                dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
            }
        });

        dialog.addEventListener("pointerenter", (_event) => {
            if (LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer) {
                clearTimeout(dialogCloseTimer);
            }
        });

        const setValue = (value) => {
            switch (item.type) {
                case "Number":
                    value = Number(value);
                    break;
                case "Boolean":
                    value = Boolean(value);
                    break;
            }
            node[property] = value;
            dialog.parentNode?.removeChild(dialog);
            node.setDirtyCanvas(true, true);
        };
    }

    // refactor: there are different dialogs, some uses createDialog some dont
    // prompt v2
    prompt(title = "", value, callback, event, multiline) {

        var dialog = document.createElement("div");
        dialog.is_modified = false;
        dialog.className = "graphdialog rounded";
        if(multiline)
            dialog.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>";
        else
            dialog.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";

        dialog.close = () => {
            this.prompt_box = null;
            dialog.parentNode?.removeChild(dialog);
        };

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;
        canvas.parentNode.appendChild(dialog);

        if (this.ds.scale > 1) {
            dialog.style.transform = `scale(${this.ds.scale})`;
        }

        var dialogCloseTimer = null;
        var prevent_timeout = false;
        dialog.addEventListener("pointerleave", (_event) => {
            if (prevent_timeout) return;
            if (LiteGraph.dialog_close_on_mouse_leave && !dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {
                dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
            }
        });

        dialog.addEventListener("pointerenter", (_event) => {
            if (LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer) {
                clearTimeout(dialogCloseTimer);
            }
        });

        const selInDia = dialog.querySelectorAll("select");
        if (selInDia) {
            // @BUG: prevent_timeout is never used.  This is literally thrashing just to keep some timeout from happening!
            let prevent_timeout = 0;
            selInDia.forEach((selIn) => {
                selIn.addEventListener("click", (_event) => {
                    prevent_timeout++;
                });
                selIn.addEventListener("blur", (_event) => {
                    prevent_timeout = 0;
                });
                selIn.addEventListener("change", (_event) => {
                    prevent_timeout = -1;
                });
            });
        }

        this.prompt_box?.close();
        this.prompt_box = dialog;

        var name_element = dialog.querySelector(".name");
        name_element.innerText = title;
        var value_element = dialog.querySelector(".value");
        value_element.value = value;

        const input = value_element;
        input.addEventListener("keydown", (e) => {
            dialog.is_modified = true;

            switch (e.keyCode) {
                case 27: // ESC key
                    dialog.close();
                    break;
                case 13: // Enter key
                    if (e.target.localName !== "textarea" && typeof(callback)=="function") {
                        callback(input.value);
                        this.setDirty(true); // CHECK should probably call graphChanged instead
                    }
                    LiteGraph.log_debug("lgraphcanvas","prompt","prompt v2 ENTER",input.value,e.target.localName,callback);
                    dialog.close();
                    break;
                default:
                    return; // Ignore other key codes
            }

            e.preventDefault();
            e.stopPropagation();
        });

        const button = dialog.querySelector("button");
        button.addEventListener("click", (_event) => {
            if (typeof(callback)=="function") {
                callback(input.value);
                this.setDirty(true); // CHECK should probably call graphChanged instead
            }
            LiteGraph.log_debug("lgraphcanvas","prompt","prompt v2 OK",input.value,callback);
            dialog.close();
        });

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        setTimeout(function() {
            input.focus();
        }, 10);

        return dialog;
    }

    showSearchBox(event, options) {
        // proposed defaults
        var def_options = {
            slot_from: null,
            node_from: null,
            node_to: null,
            do_type_filter: LiteGraph.search_filter_enabled, // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out
            type_filter_in: false, // these are default: pass to set initially set values
            type_filter_out: false,
            show_general_if_none_on_typefilter: true,
            show_general_after_typefiltered: true,
            hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
            hide_on_mouse_leave_time: LiteGraph.search_hide_on_mouse_leave_time,
            show_all_if_empty: true,
            show_all_on_open: LiteGraph.search_show_all_on_open,
        };
        options = Object.assign(def_options, options || {});

        if(typeof(event)!=="object" || typeof(event.target)=="undefined"){
            if(typeof(options.event)!=="undefined"){
                LiteGraph.log_debug("lgraphcanvas","showSearchBox","event not passed directly, using event from options",options.event,"first par was:",event);
                event = options.event;
            }
        }
        LiteGraph.log_debug("lgraphcanvas","showSearchBox",event,options);

        if(typeof(that)=="undefined"){
            var that = this;
        }else{
            LiteGraph.log_debug("lgraphcanvas","showSearchBox","using already present graphcanvas reference",that,"this is other?",this);
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;
        var root_document = canvas.ownerDocument || document;

        var dialog = document.createElement("div");
        dialog.className = "litegraph litesearchbox graphdialog rounded";
        dialog.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>";
        if (options.do_type_filter) {
            dialog.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>";
            dialog.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>";
        }
        if(options.show_close_button) {
            dialog.innerHTML += "<button class='close_searchbox close'>X</button>";
        }
        dialog.innerHTML += "<div class='helper'></div>";

        if( root_document.fullscreenElement )
            root_document.fullscreenElement.appendChild(dialog);
        else {
            root_document.body.appendChild(dialog);
            root_document.body.style.overflow = "hidden";
        }
        // dialog element has been appended

        if (options.do_type_filter) {
            var selIn = dialog.querySelector(".slot_in_type_filter");
            var selOut = dialog.querySelector(".slot_out_type_filter");
        }

        dialog.close = function() {
            that.search_box = null;
            this.blur();
            canvas.focus();
            root_document.body.style.overflow = "";

            setTimeout(function() {
                that.canvas?.focus();
                if(!that.canvas){
                    LiteGraph.log_debug("lgraphcanvas","showSearchBox","dont have reference to canvas",that,"this is other?",this);
                }
            }, 20); // important, if canvas loses focus keys wont be captured
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        if(typeof(that.ds)!=="undefined"){
            if (that.ds.scale > 1) {
                dialog.style.transform = `scale(${that.ds.scale})`;
            }
        }else{
            LiteGraph.log_debug("lgraphcanvas","showSearchBox","ds reference not found, is this graphcanvas or what","that",that,"this",this);
        }

        // hide on mouse leave
        if(options.hide_on_mouse_leave) {
            var prevent_timeout = false;
            var timeout_close = null;
            dialog.addEventListener("pointerenter", function(_event) {
                if (timeout_close) {
                    clearTimeout(timeout_close);
                    timeout_close = null;
                }
            });
            dialog.addEventListener("pointerleave", function(_event) {
                if (prevent_timeout) {
                    return;
                }
                timeout_close = setTimeout(function() {
                    dialog.close();
                }, options.hide_on_mouse_leave_time);
            });
            // if filtering, check focus changed to comboboxes and prevent closing
            if (options.do_type_filter) {
                selIn.addEventListener("click", function(_event) {
                    prevent_timeout++;
                });
                selIn.addEventListener("blur", function(_event) {
                    prevent_timeout = 0;
                });
                selIn.addEventListener("change", function(_event) {
                    prevent_timeout = -1;
                });
                selOut.addEventListener("click", function(_event) {
                    prevent_timeout++;
                });
                selOut.addEventListener("blur", function(_event) {
                    prevent_timeout = 0;
                });
                selOut.addEventListener("change", function(_event) {
                    prevent_timeout = -1;
                });
            }
        }

        if (that.search_box) {
            that.search_box.close();
        }
        that.search_box = dialog;

        var helper = dialog.querySelector(".helper");

        var first = null;
        var timeout = null;
        var selected = null;

        var input = dialog.querySelector("input");
        if (input) {
            input.addEventListener("blur", function(_event) {
                if(that.search_box)
                    this.focus();
            });
            input.addEventListener("keydown", function(e) {
                if (e.keyCode == 38) { // @TODO: deprecated
                    // UP
                    changeSelection(false);
                } else if (e.keyCode == 40) {
                    // DOWN
                    changeSelection(true);
                } else if (e.keyCode == 27) {
                    // ESC
                    dialog.close();
                } else if (e.keyCode == 13) {
                    refreshHelper();
                    if (selected) {
                        select(selected.innerHTML);
                    } else if (first) {
                        select(first);
                    } else {
                        dialog.close();
                    }
                } else {
                    if (timeout) {
                        clearInterval(timeout);
                    }
                    timeout = setTimeout(refreshHelper, 250);
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return true;
            });
        }

        // if should filter on type, load and fill selected and choose elements if passed
        if (options.do_type_filter) {
            if (selIn) {
                let aSlots = LiteGraph.slot_types_in;
                let nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length;

                if (options.type_filter_in == LiteGraph.EVENT || options.type_filter_in == LiteGraph.ACTION)
                    options.type_filter_in = "_event_";
                /* this will filter on * .. but better do it manually in case
                else if(options.type_filter_in === "" || options.type_filter_in === 0)
                    options.type_filter_in = "*";*/

                for (let iK=0; iK<nSlots; iK++) {
                    let opt = document.createElement('option');
                    opt.value = aSlots[iK];
                    opt.innerHTML = aSlots[iK];
                    selIn.appendChild(opt);
                    if(options.type_filter_in !==false && (options.type_filter_in+"").toLowerCase() == (aSlots[iK]+"").toLowerCase()) {
                        // selIn.selectedIndex ..
                        opt.selected = true; // ? check this: multiselect!! (NO!,NO?)
                        // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas","showSearchBox","comparing IN INCLUDED"+options.type_filter_in+" :: "+aSlots[iK]);
                    }else{
                        // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas","showSearchBox","excluded comparing IN "+options.type_filter_in+" :: "+aSlots[iK]);
                    }
                }
                selIn.addEventListener("change",function() {
                    refreshHelper();
                });
            }
            if (selOut) {
                let aSlots = LiteGraph.slot_types_out;
                let nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length;

                if (options.type_filter_out == LiteGraph.EVENT || options.type_filter_out == LiteGraph.ACTION)
                    options.type_filter_out = "_event_";
                /* this will filter on * .. but better do it manually in case
                else if(options.type_filter_out === "" || options.type_filter_out === 0)
                    options.type_filter_out = "*";*/

                for (let iK = 0; iK < nSlots; iK++) {
                    let opt = document.createElement('option');
                    opt.value = aSlots[iK];
                    opt.innerHTML = aSlots[iK];
                    selOut.appendChild(opt);
                    if(options.type_filter_out !==false && (options.type_filter_out+"").toLowerCase() == (aSlots[iK]+"").toLowerCase()) {
                        // selOut.selectedIndex ..
                        opt.selected = true; // ? check this: multiselect!! (NO!,NO?)
                        // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas","showSearchBox","comparing IN INCLUDED"+options.type_filter_in+" :: "+aSlots[iK]);
                    }else{
                        // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas","showSearchBox","excluded comparing IN "+options.type_filter_in+" :: "+aSlots[iK]);
                    }
                }
                selOut.addEventListener("change",function() {
                    refreshHelper();
                });
            }
        }

        if(options.show_close_button) {
            var button = dialog.querySelector(".close");
            button.addEventListener("click", dialog.close);
        }

        // compute best position
        var rect = canvas.getBoundingClientRect();

        var left = ( event ? event.clientX : (rect.left + rect.width * 0.5) ) - 80;
        var top = ( event ? event.clientY : (rect.top + rect.height * 0.5) ) - 20;

        if (rect.width - left < 470) left = rect.width - 470;
        if (rect.height - top < 220) top = rect.height - 220;
        if (left < rect.left + 20) left = rect.left + 20;
        if (top < rect.top + 20) top = rect.top + 20;

        dialog.style.left = left + "px";
        dialog.style.top = top + "px";

        /*
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }
        canvas.parentNode.appendChild(dialog);
        */

        input.focus();
        if (options.show_all_on_open) refreshHelper();

        function select(name) {
            if (name) {
                let r = that.processCallbackHandlers("onSearchBoxSelection",{
                    def_cb: that.onSearchBoxSelection
                }, name, event, graphcanvas);
                if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
                    // managed
                } else {
                    var extra = LiteGraph.searchbox_extras[name.toLowerCase()];
                    if (extra) {
                        name = extra.type;
                    }

                    graphcanvas.graph.beforeChange();
                    var node = LiteGraph.createNode(name);

                    if(!node){
                        LiteGraph.log_warn("lgraphcanvas", "showSearchBox", "select", "failed creating the node", node);
                        dialog.close();
                        return false;
                    }

                    node.pos = graphcanvas.convertEventToCanvasOffset(event);
                    graphcanvas.graph.add(node, false, {doProcessChange: false});

                    if (extra && extra.data) {
                        if (extra.data.properties) {
                            for (let i in extra.data.properties) {
                                node.addProperty( i, extra.data.properties[i] );
                            }
                        }
                        if (extra.data.inputs) {
                            node.inputs = [];
                            for (let i in extra.data.inputs) {
                                node.addOutput(
                                    extra.data.inputs[i][0],
                                    extra.data.inputs[i][1],
                                );
                            }
                        }
                        if (extra.data.outputs) {
                            node.outputs = [];
                            for (let i in extra.data.outputs) {
                                node.addOutput(
                                    extra.data.outputs[i][0],
                                    extra.data.outputs[i][1],
                                );
                            }
                        }
                        if (extra.data.title) {
                            node.title = extra.data.title;
                        }
                        if (extra.data.json) {
                            node.configure(extra.data.json);
                        }

                    }

                    let iS;

                    // join node after inserting
                    if (options.node_from) {
                        iS = false;
                        switch (typeof options.slot_from) {
                            case "string":
                                iS = options.node_from.findOutputSlot(options.slot_from);
                                break;
                            case "object":
                                if (options.slot_from.name) {
                                    iS = options.node_from.findOutputSlot(options.slot_from.name);
                                }else{
                                    iS = -1;
                                }
                                if (iS==-1 && typeof options.slot_from.slot_index !== "undefined") iS = options.slot_from.slot_index;
                                break;
                            case "number":
                                iS = options.slot_from;
                                break;
                            default:
                                iS = 0; // try with first if no name set
                        }
                        if (typeof options.node_from.outputs[iS] !== "undefined") {
                            if (iS!==false && iS>-1) {
                                options.node_from.connectByType( iS, node, options.node_from.outputs[iS].type );
                            }
                        }else{
                            LiteGraph.log_warn("lgraphcanvas", "showSearchBox", "select", "cant find slot node_from to join using from slot type", options.slot_from, options.node_from.outputs);
                        }
                    }
                    if (options.node_to) {
                        iS = false;
                        switch (typeof options.slot_from) {
                            case "string":
                                iS = options.node_to.findInputSlot(options.slot_from);
                                break;
                            case "object":
                                if (options.slot_from.name) {
                                    iS = options.node_to.findInputSlot(options.slot_from.name);
                                }else{
                                    iS = -1;
                                }
                                if (iS==-1 && typeof options.slot_from.slot_index !== "undefined") iS = options.slot_from.slot_index;
                                break;
                            case "number":
                                iS = options.slot_from;
                                break;
                            default:
                                iS = 0; // try with first if no name set
                        }
                        if (typeof options.node_to.inputs[iS] !== "undefined") {
                            if (iS!==false && iS>-1) {
                                // try connection
                                options.node_to.connectByTypeOutput(iS,node,options.node_to.inputs[iS].type);
                            }
                        }else{
                            LiteGraph.log_warn("lgraphcanvas", "showSearchBox", "select", "cant find slot node_to to join using from slot type", options.slot_from, options.node_to.inputs);
                        }
                    }

                    graphcanvas.graph.afterChange();
                }
            }

            dialog.close();
        }

        function changeSelection(forward) {
            var prev = selected;
            if (selected) {
                selected.classList.remove("selected");
            }
            if (!selected) {
                selected = forward
                    ? helper.childNodes[0]
                    : helper.childNodes[helper.childNodes.length];
            } else {
                selected = forward
                    ? selected.nextSibling
                    : selected.previousSibling;
                if (!selected) {
                    selected = prev;
                }
            }
            if (!selected) {
                return;
            }
            selected.classList.add("selected");
            selected.scrollIntoView({block: "end", behavior: "smooth"});
        }

        function refreshHelper() {
            timeout = null;
            var str = input.value;
            first = null;
            helper.innerHTML = "";
            if (!str && !options.show_all_if_empty) {
                return;
            }

            if (that.onSearchBox) {
                var list = that.onSearchBox(helper, str, graphcanvas);
                if (list) {
                    for (let i = 0; i < list.length; ++i) {
                        addResult(list[i]);
                    }
                }
            } else {
                var c = 0;
                str = str.toLowerCase();
                var filter = graphcanvas.filter || graphcanvas.graph.filter;

                let sIn, sOut;

                // filter by type preprocess
                if(options.do_type_filter && that.search_box) {
                    sIn = that.search_box.querySelector(".slot_in_type_filter");
                    sOut = that.search_box.querySelector(".slot_out_type_filter");
                }else{
                    sIn = false;
                    sOut = false;
                }

                // extras
                for (let i in LiteGraph.searchbox_extras) {
                    var extra = LiteGraph.searchbox_extras[i];
                    // var passTextSearch = extra.desc.toLowerCase().indexOf(str) !== -1;
                    let str_node = extra.desc.toLowerCase();
                    let str_title = extra.title ? extra.title.toLowerCase() : "";
                    let a_srch_parts = str.toLowerCase().split(" ");
                    let passTextSearch = true;
                    for(let i_srch of a_srch_parts){
                        // DBG EXCESS LiteGraph.log_verbose("search","check",i_srch,str_node); // verbose debug, make new higher level
                        if(i_srch.trim() === "") continue;
                        if(str_node.indexOf(i_srch) == -1 && str_title.indexOf(i_srch) == -1){
                            passTextSearch = false;
                            // DBG EXCESS LiteGraph.log_verbose("search","do not pass",i_srch,str_node); // verbose debug, make new higher level
                            break;
                        }
                    }
                    if ((!options.show_all_if_empty || str) && !passTextSearch) {
                        continue;
                    }
                    var ctor = LiteGraph.registered_node_types[extra.type];
                    if( ctor && ctor.filter != filter )
                        continue;
                    if( ! inner_test_filter(extra.type) )
                        continue;
                    addResult( extra.desc, "searchbox_extra" );
                    if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                        break;
                    }
                }

                var filtered = null;
                // filter by nodetype
                if (Array.prototype.filter) { // filter supported
                    let keys = Object.keys( LiteGraph.registered_node_types ); // types
                    filtered = keys.filter( inner_test_filter );
                } else {
                    filtered = [];
                    for (let i in LiteGraph.registered_node_types) {
                        if( inner_test_filter(i) ){
                            filtered.push(i);
                        }
                    }
                }
                // add filter by title and desc
                // TODO
                /* if (Array.prototype.filter) { // filter supported
                    let keys = Object.keys( LiteGraph.registered_node_types ); // types
                    filtered = keys.filter( inner_test_filter );
                } else {
                    filtered = [];
                    for (let i in LiteGraph.registered_node_types) {
                        if( inner_test_filter(i) ){
                            filtered.push(i);
                        }
                    }
                } */

                for (let i = 0; i < filtered.length; i++) {
                    addResult(filtered[i]);
                    if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                        break;
                    }
                }

                // add general type if filtering
                if (options.show_general_after_typefiltered
                    && (sIn.value || sOut.value)
                ) {
                    let filtered_extra = [];
                    for (let i in LiteGraph.registered_node_types) {
                        if( inner_test_filter(i, {inTypeOverride: sIn&&sIn.value?"*":false, outTypeOverride: sOut&&sOut.value?"*":false}) )
                            filtered_extra.push(i);
                    }
                    for (let i = 0; i < filtered_extra.length; i++) {
                        addResult(filtered_extra[i], "generic_type");
                        if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                            break;
                        }
                    }
                }

                // check il filtering gave no results
                if ((sIn.value || sOut.value) &&
                    ( (helper.childNodes.length == 0 && options.show_general_if_none_on_typefilter) )
                ) {
                    let filtered_extra = [];
                    for (let i in LiteGraph.registered_node_types) {
                        if( inner_test_filter(i, {skipFilter: true}) )
                            filtered_extra.push(i);
                    }
                    for (let i = 0; i < filtered_extra.length; i++) {
                        addResult(filtered_extra[i], "not_in_filter");
                        if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                            break;
                        }
                    }
                }

                function inner_test_filter(type, optsIn = {}) {
                    var optsDef = {
                        skipFilter: false,
                        inTypeOverride: false,
                        outTypeOverride: false,
                    };
                    var opts = Object.assign(optsDef,optsIn);
                    var ctor = LiteGraph.registered_node_types[type];
                    if(filter && ctor.filter != filter )
                        return false;
                    
                    let str_node = type.toLowerCase();
                    let a_srch_parts = str.toLowerCase().split(" ");
                    let passTextSearch = true;
                    for(let i_srch of a_srch_parts){
                        LiteGraph.log_verbose("search","check",i_srch,str_node); // verbose debug, make new higher level
                        if(i_srch.trim() === "") continue;
                        if(str_node.indexOf(i_srch) == -1){
                            passTextSearch = false;
                            LiteGraph.log_verbose("search","do not pass",i_srch,str_node); // verbose debug, make new higher level
                            break;
                        }
                    }

                    if ((!options.show_all_if_empty || str) && !passTextSearch)
                        return false;

                    // filter by slot IN, OUT types
                    if(options.do_type_filter && !opts.skipFilter) {
                        var sType = type;
                        let doesInc;

                        var sV = sIn.value;
                        if (opts.inTypeOverride!==false) sV = opts.inTypeOverride;
                        // if (sV.toLowerCase() == "_event_") sV = LiteGraph.EVENT; // -1

                        if(sIn && sV) {
                            // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN will check filter against "+sV);
                            if (LiteGraph.registered_slot_in_types[sV] && LiteGraph.registered_slot_in_types[sV].nodes) { // type is stored
                                // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN check "+sType+" in "+LiteGraph.registered_slot_in_types[sV].nodes);
                                doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);
                                if (doesInc!==false) {
                                    // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN "+sType+" HAS "+sV);
                                }else{
                                    // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN "+LiteGraph.registered_slot_in_types[sV]," DONT includes "+type);
                                    return false;
                                }
                            }
                        }

                        sV = sOut.value;
                        if (opts.outTypeOverride!==false) {
                            sV = opts.outTypeOverride;
                        }
                        // if (sV.toLowerCase() == "_event_") sV = LiteGraph.EVENT; // -1

                        if(sOut && sV) {
                            // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN will check filter against "+sV);
                            if (LiteGraph.registered_slot_out_types[sV] && LiteGraph.registered_slot_out_types[sV].nodes) { // type is stored
                                // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN check "+sType+" in "+LiteGraph.registered_slot_in_types[sV].nodes);
                                doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);
                                if (doesInc!==false) {
                                    // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN "+sType+" HAS "+sV);
                                }else{
                                    // DBG EXCESS LiteGraph.log_verbose("lgraphcanvas", "showSearchBox", "inner_test_filter", "IN "+LiteGraph.registered_slot_in_types[sV]," DONT includes "+type);
                                    return false;
                                }
                            }
                        }
                    }
                    return true;
                }
            }

            function addResult(type, className) {
                var help = document.createElement("div");
                if (!first) {
                    first = type;
                }
                help.innerText = type;
                help.dataset["type"] = escape(type); // @TODO: deprecated
                help.className = "litegraph lite-search-item";
                if (className) {
                    help.className += " " + className;
                }
                help.addEventListener("click", function(_event) {
                    select(unescape(this.dataset["type"]));
                });
                helper.appendChild(help);
            }
        }

        return dialog;
    }

    showEditPropertyValue(node, property, options) {
        if (!node || node.properties[property] === undefined) {
            return;
        }

        options = options || {};

        var info = node.getPropertyInfo(property);
        let type = info && info!==null ? info.type : "string";

        let input_html;

        if (type == "string" || type == "number" || type == "array" || type == "object" || type == "code") {
            input_html = "<input autofocus type='text' class='value'/>";
        } else if ( (type == "enum" || type == "combo") && info.values) {
            LiteGraph.log_debug("lgraphcanvas", "showEditPropertyValue", "CREATING ENUM COMBO",input,type,dialog);
            input_html = "<select autofocus type='text' class='value'>";
            for (let i in info.values) {
                var v = i;
                if( info.values.constructor === Array )
                    v = info.values[i];

                input_html +=
                    "<option value='" +
                    v +
                    "' " +
                    (v == node.properties[property] ? "selected" : "") +
                    ">" +
                    info.values[i] +
                    "</option>";
            }
            input_html += "</select>";
        } else if (type == "boolean" || type == "toggle") {
            input_html =
                "<input autofocus type='checkbox' class='value' " +
                (node.properties[property] ? "checked" : "") +
                "/>";
        } else {
            LiteGraph.log_warn("lgraphcanvas", "showEditPropertyValue", "unknown type", type);
            return;
        }

        var dialog = this.createDialog(
            "<span class='name'>" +
                (info.label ? info.label : property) +
                "</span>" +
                input_html +
                "<button>OK</button>",
            options,
        );

        var input = false;
        if ((type == "enum" || type == "combo") && info.values) {
            LiteGraph.log_debug("lgraphcanvas", "showEditPropertyValue", "showEditPropertyValue ENUM COMBO",input,type,dialog);
            input = dialog.querySelector("select");
            input.addEventListener("change", function(e) {
                dialog.modified();
                LiteGraph.log_debug("lgraphcanvas", "showEditPropertyValue", "Enum change",input,info,e.target);
                setValue(e.target.value);
                // var index = e.target.value;
                // setValue( e.options[e.selectedIndex].value );
            });
        } else if (type == "boolean" || type == "toggle") {
            LiteGraph.log_debug("lgraphcanvas", "showEditPropertyValue", "TOGGLE", input, type, dialog);
            input = dialog.querySelector("input");
            if (input) {
                input.addEventListener("click", function(_event) {
                    dialog.modified();
                    setValue(!!input.checked);
                });
            }
        } else {
            input = dialog.querySelector("input");
            LiteGraph.log_debug("lgraphcanvas", "showEditPropertyValue", input, type, dialog);
            if (input) {
                input.addEventListener("blur", function(_event) {
                    this.focus();
                });

                v = node.properties[property] !== undefined ? node.properties[property] : "";
                if (type !== 'string') {
                    v = JSON.stringify(v);
                }

                input.value = v;
                input.addEventListener("keydown", function(e) {
                    if (e.keyCode == 27) {
                        // ESC
                        dialog.close();
                    } else if (e.keyCode == 13) {
                        // ENTER
                        inner(); // save
                    } else if (e.keyCode != 13) {
                        dialog.modified();
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
        }
        if (input) input.focus();

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);

        function inner() {
            setValue(input.value);
        }

        function setValue(value) {

            if(info && info.values && info.values.constructor === Object && info.values[value] != undefined )
                value = info.values[value];

            if (typeof node.properties[property] == "number") {
                value = Number(value);
            }
            if (type == "array" || type == "object") {
                value = JSON.parse(value);
            }
            const prevValue = node.properties[property];
            node.properties[property] = value;
            node.graph?.onGraphChanged({action: "propertyChanged", doSave: true});
            
            // Call onPropertyChanged and block the change if needed
            let r = node.processCallbackHandlers("onPropertyChanged",{
                def_cb: node.onPropertyChanged
            }, property, value, prevValue);
            if(r===false || (r!==null && (typeof(r)=="object" && r.return_value===false))){
                node.properties[property] = prevValue;
                LiteGraph.log_debug("lgraphcanvas","showEditPropertyValue","setValue","prevent property set by cbHandler",property,value,prevValue,r);
            }
            
            if(options.onclose)
                options.onclose();
            dialog.close();
            node.setDirtyCanvas(true, true);
        }

        return dialog;
    }

    // TODO refactor, theer are different dialog, some uses createDialog, some dont
    createDialog(html, options) {
        var def_options = { checkForInput: false, closeOnLeave: true, closeOnLeave_checkModified: true };
        options = Object.assign(def_options, options || {});

        var dialog = document.createElement("div");
        dialog.className = "graphdialog";
        dialog.innerHTML = html;
        dialog.is_modified = false;

        var rect = this.canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (options.position) {
            offsetx += options.position[0];
            offsety += options.position[1];
        } else if (options.event) {
            offsetx += options.event.clientX;
            offsety += options.event.clientY;
        } else { // centered
            offsetx += this.canvas.width * 0.5;
            offsety += this.canvas.height * 0.5;
        }

        dialog.style.left = offsetx + "px";
        dialog.style.top = offsety + "px";

        this.canvas.parentNode.appendChild(dialog);

        // check for input and use default behaviour: save on enter, close on esc
        if (options.checkForInput) {
            var aI = [];
            var focused = false;
            aI = dialog.querySelectorAll("input");
            if (aI) {
                aI.forEach(function(iX) {
                    iX.addEventListener("keydown",function(e) {
                        dialog.modified();
                        if (e.keyCode == 27) {
                            dialog.close();
                        } else if (e.keyCode != 13) {
                            return;
                        }
                        // set value ?
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    if (!focused) iX.focus();
                });
            }
        }

        dialog.modified = function() {
            dialog.is_modified = true;
        }
        dialog.close = function() {
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        var dialogCloseTimer = null;
        var prevent_timeout = false;
        dialog.addEventListener("pointerleave", function(_event) {
            if (prevent_timeout)
                return;
            if(options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave)
                if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
                    dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay); // dialog.close();
        });
        dialog.addEventListener("pointerenter", function(_event) {
            if(options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave)
                if(dialogCloseTimer) clearTimeout(dialogCloseTimer);
        });
        var selInDia = dialog.querySelectorAll("select");
        if (selInDia) {
            // if filtering, check focus changed to comboboxes and prevent closing
            selInDia.forEach(function(selIn) {
                selIn.addEventListener("click", function(_event) {
                    prevent_timeout++;
                });
                selIn.addEventListener("blur", function(_event) {
                    prevent_timeout = 0;
                });
                selIn.addEventListener("change", function(_event) {
                    prevent_timeout = -1;
                });
            });
        }

        return dialog;
    }

    createPanel(title, options) {
        options = options || {};

        var ref_window = options.window || window;
        var root = document.createElement("div");
        root.className = "litegraph dialog";
        root.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>";
        root.header = root.querySelector(".dialog-header");

        if(options.width)
            root.style.width = options.width + (options.width.constructor === Number ? "px" : "");
        if(options.height)
            root.style.height = options.height + (options.height.constructor === Number ? "px" : "");
        if(options.closable) {
            var close = document.createElement("span");
            close.innerHTML = "&#10005;";
            close.classList.add("close");
            close.addEventListener("click",function() {
                root.close();
            });
            root.header.appendChild(close);
        }
        root.title_element = root.querySelector(".dialog-title");
        root.title_element.innerText = title;
        root.content = root.querySelector(".dialog-content");
        root.alt_content = root.querySelector(".dialog-alt-content");
        root.footer = root.querySelector(".dialog-footer");

        root.close = function() {
            if (root.onClose && typeof root.onClose == "function") {
                root.onClose();
            }
            if(root.parentNode)
                root.parentNode.removeChild(root);
            /* XXX CHECK THIS */
            if(this.parentNode) {
                this.parentNode.removeChild(this);
            }
            /* XXX this was not working, was fixed with an IF, check this */
            // check: maybe need a .call(this)
        }

        // function to swap panel content
        root.toggleAltContent = function(force) {
            let vTo, vAlt;
            if (typeof force != "undefined") {
                vTo = force ? "block" : "none";
                vAlt = force ? "none" : "block";
            }else{
                vTo = root.alt_content.style.display != "block" ? "block" : "none";
                vAlt = root.alt_content.style.display != "block" ? "none" : "block";
            }
            root.alt_content.style.display = vTo;
            root.content.style.display = vAlt;
        }

        root.toggleFooterVisibility = function(force) {
            let vTo;
            if (typeof force != "undefined") {
                vTo = force ? "block" : "none";
            }else{
                vTo = root.footer.style.display != "block" ? "block" : "none";
            }
            root.footer.style.display = vTo;
        }

        root.clear = function() {
            this.content.innerHTML = "";
        }

        root.addHTML = function(code, classname, on_footer) {
            var elem = document.createElement("div");
            if(classname)
                elem.className = classname;
            elem.innerHTML = code;
            if(on_footer)
                root.footer.appendChild(elem);
            else
                root.content.appendChild(elem);
            return elem;
        }

        root.addButton = function( name, callback, options ) {
            var elem = document.createElement("button");
            elem.innerText = name;
            elem.options = options;
            elem.classList.add("btn");
            elem.addEventListener("click",callback);
            root.footer.appendChild(elem);
            return elem;
        }

        root.addSeparator = function() {
            var elem = document.createElement("div");
            elem.className = "separator";
            root.content.appendChild(elem);
        }

        root.addWidget = function( type, name, value, options, callback ) {
            options = options || {};
            var str_value = String(value);
            type = type.toLowerCase();
            if(type == "number")
                str_value = LiteGraph.formatNumber(value,3);

            var elem = document.createElement("div");
            elem.className = "property";
            elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
            elem.querySelector(".property_name").innerText = options.label || name;
            var value_element = elem.querySelector(".property_value");
            value_element.innerText = str_value;
            elem.dataset["property"] = name;
            elem.dataset["type"] = options.type || type;
            elem.options = options;
            elem.value = value;

            LiteGraph.log_debug("lgraphcanvas", "createPanel", "addWidget", type, value, value_element, options);

            if(type == "code") {
                elem.addEventListener("click", function(_event) {
                    root.inner_showCodePad( this.dataset["property"] );
                });
            } else if (type == "boolean") {
                elem.classList.add("boolean");
                if(value)
                    elem.classList.add("bool-on");
                elem.addEventListener("click", function() {
                    // var v = node.properties[this.dataset["property"]];
                    // node.setProperty(this.dataset["property"],!v); this.innerText = v ? "on" : "off";
                    var propname = this.dataset["property"];
                    this.value = !this.value;
                    this.classList.toggle("bool-on");
                    this.querySelector(".property_value").innerText = this.value ? "on" : "off";
                    innerChange(propname, this.value );
                });
            } else if (type == "string" || type == "number") {
                value_element.setAttribute("contenteditable",true);
                value_element.addEventListener("keydown", function(e) {
                    if(e.code == "Enter" && (type != "string" || !e.shiftKey)) { // allow for multiline
                        e.preventDefault();
                        this.blur();
                    }
                });
                value_element.addEventListener("blur", function() {
                    var v = this.innerText;
                    var propname = this.parentNode.dataset["property"];
                    var proptype = this.parentNode.dataset["type"];
                    if( proptype == "number")
                        v = Number(v);
                    innerChange(propname, v);
                });
            } else if (type == "enum" || type == "combo") {
                str_value = LGraphCanvas.getPropertyPrintableValue( value, options.values );
                value_element.innerText = str_value;

                LiteGraph.log_debug("lgraphcanvas", "createPanel", "addWidget", "ENUM COMBO", type, str_value, value_element, options);

                value_element.addEventListener("click", function(event) {
                    var values = options.values || [];
                    var propname = this.parentNode.dataset["property"];
                    var elem_that = this;
                    LiteGraph.ContextMenu(
                        values,{
                            event: event,
                            className: "dark",
                            callback: inner_clicked,
                        },
                        ref_window,
                    );
                    function inner_clicked(v) {
                        // node.setProperty(propname,v);
                        // graphcanvas.dirty_canvas = true;
                        elem_that.innerText = v;
                        innerChange(propname,v);
                        return false;
                    }
                });
            }

            root.content.appendChild(elem);

            function innerChange(name, value) {
                LiteGraph.log_debug("lgraphcanvas", "createPanel", "addWidget", "innerChange", name, value, options);
                // that.dirty_canvas = true;
                if(options.callback)
                    options.callback(name,value,options);
                if(callback)
                    callback(name,value,options);
            }

            return elem;
        }

        if (root.onOpen && typeof root.onOpen == "function") root.onOpen();

        return root;
    }

    static getPropertyPrintableValue(value, values) {
        if(!values)
            return String(value);

        if(values.constructor === Array) {
            return String(value);
        }

        if(values.constructor === Object) {
            var desc_value = "";
            for(var k in values) {
                if(values[k] != value)
                    continue;
                desc_value = k;
                break;
            }
            return String(value) + " ("+desc_value+")";
        }
    }

    showShowGraphOptionsPanel(refOpts, obEv) {
        let graphcanvas;
        if(this.constructor && this.constructor.name == "HTMLDivElement") {
            // assume coming from the menu event click
            if (! obEv?.event?.target?.lgraphcanvas) {
                LiteGraph.log_warn("lgraphcanvas", "showShowGraphOptionsPanel", "References not found to add optionPanel", refOpts, obEv); // need a ref to canvas obj
                LiteGraph.log_debug("lgraphcanvas", "showShowGraphOptionsPanel", "!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas",obEv,obEv.event,obEv.event.target,obEv.event.target.lgraphcanvas);
                return;
            }
            graphcanvas = obEv.event.target.lgraphcanvas;
        }else{
            // assume called internally
            graphcanvas = this;
        }
        graphcanvas.closePanels();
        var ref_window = graphcanvas.getCanvasWindow();
        panel = graphcanvas.createPanel("Options",{
            closable: true,
            window: ref_window,
            onOpen: function() {
                graphcanvas.OPTIONPANEL_IS_OPEN = true;
            },
            onClose: function() {
                graphcanvas.OPTIONPANEL_IS_OPEN = false;
                graphcanvas.options_panel = null;
            },
        });
        graphcanvas.options_panel = panel;
        panel.id = "option-panel";
        panel.classList.add("settings");

        function inner_refresh() {

            panel.content.innerHTML = ""; // clear

            const fUpdate = (name, value, options) => {
                switch(name) {
                    /* case "Render mode":
                        // Case ""..
                        if (options.values && options.key){
                            var kV = Object.values(options.values).indexOf(value);
                            if (kV>=0 && options.values[kV]){
                                LiteGraph.log_debug("update graph options: "+options.key+": "+kV);
                                graphcanvas[options.key] = kV;
                                //LiteGraph.log_debug(graphcanvas);
                                break;
                            }
                        }
                        LiteGraph.log_warn("unexpected options");
                        LiteGraph.log_debug(options);
                        break;*/
                    default:
                        LiteGraph.log_verbose("lgraphcanvas", "showShowGraphOptionsPanel", "want to update graph options: "+name+": "+value);
                        if (options && options.key) {
                            name = options.key;
                        }
                        if (options.values) {
                            value = Object.values(options.values).indexOf(value);
                        }
                        LiteGraph.log_verbose("lgraphcanvas", "showShowGraphOptionsPanel", "update graph option: "+name+": "+value);
                        graphcanvas[name] = value;
                        break;
                }
            };

            // panel.addWidget( "string", "Graph name", "", {}, fUpdate); // implement

            var aProps = LiteGraph.availableCanvasOptions;
            aProps.sort();
            for(var pI in aProps) {
                var pX = aProps[pI];
                panel.addWidget( "boolean", pX, graphcanvas[pX], {key: pX, on: "on", off: "off"}, fUpdate);
            }

            panel.addWidget( "combo", "Render mode", LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], {key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES}, fUpdate);

            panel.addSeparator();

            panel.footer.innerHTML = ""; // clear

        }
        inner_refresh();

        graphcanvas.canvas.parentNode.appendChild( panel );
    }

    showShowNodePanel(node) {
        this.SELECTED_NODE = node;
        this.closePanels();
        var ref_window = this.getCanvasWindow();

        var graphcanvas = this;
        var panel = this.createPanel(node.title || "",{
            closable: true,
            window: ref_window,
            onOpen: function() {
                graphcanvas.NODEPANEL_IS_OPEN = true;
            },
            onClose: function() {
                graphcanvas.NODEPANEL_IS_OPEN = false;
                graphcanvas.node_panel = null;
            },
        });
        graphcanvas.node_panel = panel;
        panel.id = "node-panel";
        panel.node = node;
        panel.classList.add("settings");

        function inner_refresh() {
            panel.content.innerHTML = ""; // clear
            panel.addHTML("<span class='node_type'>"+node.type+"</span>"+
                "<span class='node_desc'>"+(node.constructor.desc || "")+"</span>"+
                "<span class='separator'></span>");

            panel.addHTML("<h3>Properties</h3>");

            const fUpdate = (name,value) => {
                graphcanvas.graph.beforeChange(node);
                switch(name) {
                    case "Title":
                        node.title = value;
                        break;
                    case "Mode":
                        var kV = Object.values(LiteGraph.NODE_MODES).indexOf(value);
                        if (kV>=0 && LiteGraph.NODE_MODES[kV]) {
                            node.changeMode(kV);
                        }else{
                            LiteGraph.log_warn("lgraphcanvas", "showShowNodePanel", "unexpected mode",value,kV);
                        }
                        break;
                    case "Color":
                        if (LGraphCanvas.node_colors[value]) {
                            node.color = LGraphCanvas.node_colors[value].color;
                            node.bgcolor = LGraphCanvas.node_colors[value].bgcolor;
                        }else{
                            LiteGraph.log_warn("lgraphcanvas", "showShowNodePanel", "unexpected color",value);
                        }
                        break;
                    default:
                        node.setProperty(name,value);
                        break;
                }
                graphcanvas.graph.afterChange();
                graphcanvas.dirty_canvas = true;
            };

            panel.addWidget( "string", "Title", node.title, {}, fUpdate);

            panel.addWidget( "combo", "Mode", LiteGraph.NODE_MODES[node.mode], {values: LiteGraph.NODE_MODES}, fUpdate);

            var nodeCol = "";
            if (node.color !== undefined) {
                nodeCol = Object.keys(LGraphCanvas.node_colors).filter(function(nK) {
                    return LGraphCanvas.node_colors[nK].color == node.color;
                });
            }

            panel.addWidget( "combo", "Color", nodeCol, {values: Object.keys(LGraphCanvas.node_colors)}, fUpdate);

            for(var pName in node.properties) {
                var value = node.properties[pName];
                var info = node.getPropertyInfo(pName);
                let type = info && info!==null ? info.type : "string";

                // in case the user wants control over the side panel widget
                if( node.onAddPropertyToPanel && node.onAddPropertyToPanel(pName, panel, value, info, fUpdate) ) {
                    continue;
                }
                panel.addWidget( info.widget || type, pName, value, info, fUpdate);
            }

            panel.addSeparator();

            if(node.onShowCustomPanelInfo)
                node.onShowCustomPanelInfo(panel);

            panel.footer.innerHTML = ""; // clear
            panel.addButton("Delete",function() {
                if(node.block_delete)
                    return;
                node.graph.remove(node);
                panel.close();
            }).classList.add("delete");
        }

        panel.inner_showCodePad = function( propname ) {
            panel.classList.remove("settings");
            panel.classList.add("centered");

            /* TODO restore, export to extensions
            if(window.CodeFlask) //disabled for now
            {
                panel.content.innerHTML = "<div class='code'></div>";
                var flask = new CodeFlask( "div.code", { language: 'js' });
                flask.updateCode(node.properties[propname]);
                flask.onUpdate( function(code) {
                    node.setProperty(propname, code);
                });
            }
            else
            {*/
            panel.alt_content.innerHTML = "<textarea class='code'></textarea>";
            var textarea = panel.alt_content.querySelector("textarea");
            var fDoneWith = () => {
                panel.toggleAltContent(false); // if(node_prop_div) node_prop_div.style.display = "block"; // panel.close();
                panel.toggleFooterVisibility(true);
                textarea.parentNode.removeChild(textarea);
                panel.classList.add("settings");
                panel.classList.remove("centered");
                inner_refresh();
            }
            textarea.value = node.properties[propname];
            textarea.addEventListener("keydown", function(e) {
                if(e.code == "Enter" && e.ctrlKey ) {
                    node.setProperty(propname, textarea.value);
                    fDoneWith();
                }
            });
            panel.toggleAltContent(true);
            panel.toggleFooterVisibility(false);
            textarea.style.height = "calc(100% - 40px)";
            /* }*/
            var assign = panel.addButton( "Assign", function() {
                node.setProperty(propname, textarea.value);
                fDoneWith();
            });
            panel.alt_content.appendChild(assign); // panel.content.appendChild(assign);
            var button = panel.addButton( "Close", fDoneWith);
            button.style.float = "right";
            panel.alt_content.appendChild(button); // panel.content.appendChild(button);
        }

        inner_refresh();

        this.canvas.parentNode.appendChild( panel );
    }

    showSubgraphPropertiesDialog(node) {
        LiteGraph.log_debug("lgraphcanvas", "showSubgraphPropertiesDialog", "showing subgraph properties dialog");

        var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
        if(old_panel)
            old_panel.close();

        var panel = this.createPanel("Subgraph Inputs",{closable: true, width: 500});
        panel.node = node;
        panel.classList.add("subgraph_dialog");

        function inner_refresh() {
            panel.clear();

            // show currents
            if(node.inputs)
                for(let i = 0; i < node.inputs.length; ++i) {
                    var input = node.inputs[i];
                    if(input.not_subgraph_input)
                        continue;
                    var html = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
                    var elem = panel.addHTML(html,"subgraph_property");
                    elem.dataset["name"] = input.name;
                    elem.dataset["slot"] = i;
                    elem.querySelector(".name").innerText = input.name;
                    elem.querySelector(".type").innerText = input.type;
                    elem.querySelector("button").addEventListener("click",function(_event) {
                        node.removeInput( Number( this.parentNode.dataset["slot"] ) );
                        inner_refresh();
                    });
                }
        }

        // add extra
        var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
        var elem = panel.addHTML(html,"subgraph_property extra", true);
        elem.querySelector("button").addEventListener("click", function(_event) {
            var elem = this.parentNode;
            var name = elem.querySelector(".name").value;
            var type = elem.querySelector(".type").value;
            if(!name || node.findInputSlot(name) != -1)
                return;
            if(["event","action"].indexOf(type)>-1){
                type = LiteGraph.EVENT;
            }
            node.addInput(name,type);
            elem.querySelector(".name").value = "";
            elem.querySelector(".type").value = "";
            inner_refresh();
        });

        inner_refresh();
        this.canvas.parentNode.appendChild(panel);
        return panel;
    }

    showSubgraphPropertiesDialogRight(node) {

        LiteGraph.log_verbose("lgraphcanvas", "showSubgraphPropertiesDialogRight", "showing subgraph properties dialog RIGHT");

        // old_panel if old_panel is exist close it
        var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
        if (old_panel)
            old_panel.close();
        // new panel
        var panel = this.createPanel("Subgraph Outputs", { closable: true, width: 500 });
        panel.node = node;
        panel.classList.add("subgraph_dialog");

        function inner_refresh() {
            panel.clear();
            // show currents
            if (node.outputs)
                for (let i = 0; i < node.outputs.length; ++i) {
                    var input = node.outputs[i];
                    if (input.not_subgraph_output)
                        continue;
                    var html = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
                    var elem = panel.addHTML(html, "subgraph_property");
                    elem.dataset["name"] = input.name;
                    elem.dataset["slot"] = i;
                    elem.querySelector(".name").innerText = input.name;
                    elem.querySelector(".type").innerText = input.type;
                    elem.querySelector("button").addEventListener("click", function (_event) {
                        node.removeOutput(Number(this.parentNode.dataset["slot"]));
                        inner_refresh();
                    });
                }
        }

        // add extra
        var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
        var elem = panel.addHTML(html, "subgraph_property extra", true);
        elem.querySelector(".name").addEventListener("keydown", function (_event) {
            if (_event.keyCode == 13) {
                addOutput.apply(this)
            }
        })
        elem.querySelector("button").addEventListener("click", function (_event) {
            addOutput.apply(this)
        });
        function addOutput() {
            var elem = this.parentNode;
            var name = elem.querySelector(".name").value;
            var type = elem.querySelector(".type").value;
            if (!name || node.findOutputSlot(name) != -1)
                return;
            if(["event","action"].indexOf(type)>-1){
                type = LiteGraph.EVENT;
            }
            node.addOutput(name, type);
            elem.querySelector(".name").value = "";
            elem.querySelector(".type").value = "";
            inner_refresh();
        }

        inner_refresh();
        this.canvas.parentNode.appendChild(panel);
        return panel;
    }

    /**
     * will close node-panel and option-panel
     * @returns void 
     */
    closePanels() {
        var panel = document.querySelector("#node-panel");
        if(panel)
            panel.close(); // ? panel.close.call(panel);
        panel = document.querySelector("#option-panel");
        if(panel)
            panel.close(); // ? panel.close.call(panel);
    }

    /**
     * will close .litegraph.dialog
     * @returns void
     */
    checkPanels() {
        if(!this.canvas)
            return;
        var panels = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
        for(let i = 0; i < panels.length; ++i) {
            var panel = panels[i];
            if( !panel.node )
                continue;
            if( !panel.node.graph || panel.graph != this.graph )
                panel.close();
        }
    }

    static onMenuNodeCollapse(value, options, e, menu, node) {
        node.graph.beforeChange(/* ?*/);

        var fApplyMultiNode = function(node) {
            node.collapse();
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
            fApplyMultiNode(node);
        }else{
            for (let i in graphcanvas.selected_nodes) {
                fApplyMultiNode(graphcanvas.selected_nodes[i]);
            }
        }

        node.graph.afterChange(/* ?*/);
    }

    static onMenuNodePin(value, options, e, menu, node) {
        node.pin();
    }

    static onMenuNodeMode(value, options, e, menu, node) {
        LiteGraph.ContextMenu(
            LiteGraph.NODE_MODES,
            { event: e, callback: inner_clicked, parentMenu: menu, node: node },
        );

        function inner_clicked(v) {
            if (!node) {
                return;
            }
            var kV = Object.values(LiteGraph.NODE_MODES).indexOf(v);
            const fApplyMultiNode = (node) => {
                if (kV>=0 && LiteGraph.NODE_MODES[kV])
                    node.changeMode(kV);
                else{
                    LiteGraph.log_warn("lgraphcanvas", "onMenuNodeMode", "unexpected mode", v, kV);
                    node.changeMode(LiteGraph.ALWAYS);
                }
            }

            var graphcanvas = LGraphCanvas.active_canvas;
            if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
                fApplyMultiNode(node);
            }else{
                for (let i in graphcanvas.selected_nodes) {
                    fApplyMultiNode(graphcanvas.selected_nodes[i]);
                }
            }
        }

        return false;
    }

    static onMenuNodeColors(value, options, e, menu, node) {
        if (!node) {
            // ? happens ?
            // throw new Error("no node for color");
            LiteGraph.log_warn("lgraphcanvas", "onMenuNodeColors", "invalid node");
            return;
        }

        var values = [];
        values.push({
            value: null,
            content:
                "<span style='display: block; padding-left: 4px;'>No color</span>",
        });

        for (let i in LGraphCanvas.node_colors) {
            let color = LGraphCanvas.node_colors[i];
            value = {
                value: i,
                content:
                    "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " +
                    color.color +
                    "; background-color:" +
                    color.bgcolor +
                    "'>" +
                    i +
                    "</span>",
            };
            values.push(value);
        }
        LiteGraph.ContextMenu(values, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node,
        });

        function inner_clicked(v) {
            if (!node) {
                LiteGraph.log_warn("lgraphcanvas", "onMenuNodeColors", "inner_clicked", "no node");
                return;
            }

            let color = v.value ? LGraphCanvas.node_colors[v.value] : null;

            const fApplyColor = (node) => {
                if (color) {
                    if (node.constructor === LiteGraph.LGraphGroup) {
                        node.color = color.groupcolor;
                    } else {
                        node.color = color.color;
                        node.bgcolor = color.bgcolor;
                    }
                } else {
                    delete node.color;
                    delete node.bgcolor;
                }
            }

            var graphcanvas = LGraphCanvas.active_canvas;
            if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
                fApplyColor(node);
            }else{
                for (let i in graphcanvas.selected_nodes) {
                    fApplyColor(graphcanvas.selected_nodes[i]);
                }
            }
            node.setDirtyCanvas(true, true);
        }

        return false;
    }

    static onMenuNodeShapes(value, options, e, menu, node) {
        if (!node) {
            // ? happens ?
            // throw new Error("no node passed");
            LiteGraph.log_warn("lgraphcanvas", "onMenuNodeShapes", "invalid node");
            return;
        }

        LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node,
        });

        function inner_clicked(v) {
            if (!node) {
                LiteGraph.log_warn("lgraphcanvas", "onMenuNodeShapes", "inner_clicked", "no node");
                return;
            }
            node.graph.beforeChange(/* ?*/); // node

            const fApplyMultiNode = (node) => {
                node.shape = v;
            }

            var graphcanvas = LGraphCanvas.active_canvas;
            if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
                fApplyMultiNode(node);
            }else{
                for (let i in graphcanvas.selected_nodes) {
                    fApplyMultiNode(graphcanvas.selected_nodes[i]);
                }
            }

            node.graph.afterChange(/* ?*/); // node
            node.setDirtyCanvas(true);
        }

        return false;
    }

    static onMenuNodeRemove(value, options, e, menu, node) {
        if (!node) {
            // ? happens ?
            // throw new Error("no node passed");
            LiteGraph.log_warn("lgraphcanvas", "onMenuNodeShapes", "invalid node");
            return;
        }

        var graph = node.graph;
        graph.beforeChange();

        const fApplyMultiNode = (node) => {
            if (node.removable === false) {
                return;
            }
            graph.remove(node);
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
            fApplyMultiNode(node);
        }else{
            for (let i in graphcanvas.selected_nodes) {
                fApplyMultiNode(graphcanvas.selected_nodes[i]);
            }
        }

        graph.afterChange();
        node.setDirtyCanvas(true, true);
    }

    static onMenuNodeToSubgraph(value, options, e, menu, node) {
        var graph = node.graph;
        var graphcanvas = LGraphCanvas.active_canvas;
        if(!graphcanvas){
            // ? happens ?
            // throw new Error("no graph");
            LiteGraph.log_warn("lgraphcanvas", "onMenuNodeToSubgraph", "graphcanvas invalid");
            return;
        }

        var nodes_list = Object.values( graphcanvas.selected_nodes || {} );
        if( !nodes_list.length )
            nodes_list = [ node ];

        var subgraph_node = LiteGraph.createNode("graph/subgraph");
        subgraph_node.pos = node.pos.concat();
        graph.add(subgraph_node);

        subgraph_node.buildFromNodes( nodes_list );

        graphcanvas.deselectAllNodes();
        node.setDirtyCanvas(true, true);
    }

    static onMenuNodeClone(value, options, e, menu, node) {

        node.graph.beforeChange();

        var newSelected = {};

        const fApplyMultiNode = (node) => {
            if (node.clonable === false) {
                return;
            }
            var newnode = node.clone();
            if (!newnode) {
                return;
            }
            newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];
            node.graph.add(newnode);
            newSelected[newnode.id] = newnode;
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
            fApplyMultiNode(node);
        }else{
            for (let i in graphcanvas.selected_nodes) {
                fApplyMultiNode(graphcanvas.selected_nodes[i]);
            }
        }

        if(Object.keys(newSelected).length) {
            graphcanvas.selectNodes(newSelected);
        }

        node.graph.afterChange();

        node.setDirtyCanvas(true, true);
    }

    getCanvasMenuOptions() {
        var options = null;
        var that = this;
        let r = this.processCallbackHandlers("getMenuOptions",{
            def_cb: this.getMenuOptions
        });
        if(r!==null && (r === true || (typeof(r)=="object" && r.return_value === true))){
            // managed
        } else {

            options = [
                {
                    content: "Add Node",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuAdd,
                },
                {
                    content: "Search",
                    has_submenu: false,
                    callback: that.showSearchBox,
                },
                { content: "Add Group", callback: LGraphCanvas.onGroupAdd },
                // { content: "Arrange", callback: that.graph.arrange },
                // {content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
            ];

            if (Object.keys(this.selected_nodes).length > 1) {
                options.push({
                    content: "Align",
                    has_submenu: true,
                    callback: LGraphCanvas.onGroupAlign,
                })
            }

            if (this._graph_stack && this._graph_stack.length > 0) {
                options.push(null, {
                    content: "Close subgraph",
                    callback: this.closeSubgraph.bind(this),
                });
            }
        }

        r = this.processCallbackHandlers("getExtraMenuOptions",{
            def_cb: this.getExtraMenuOptions
        }, this, options);
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                options = options.concat(r.return_value);
            }
        }

        return options;
    }

    // called by processContextMenu to extract the menu list
    getNodeMenuOptions(node) {
        var options = null;

        let r = node.processCallbackHandlers("getMenuOptions",{
            def_cb: node.getMenuOptions
        }, this);
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                options = r.return_value;
            }
        }
        if(options===null){
            options = [
                {
                    content: "Inputs",
                    has_submenu: true,
                    // disabled: true, // disable Input and Output slots ? would need better check :: TODO use showMenuNodeOptional ins
                    callback: LGraphCanvas.showMenuNodeOptionalInputs,
                },
                {
                    content: "Outputs",
                    has_submenu: true,
                    // disabled: true, // disable Input and Output slots ? would need better check :: TODO use showMenuNodeOptional ins
                    callback: LGraphCanvas.showMenuNodeOptionalOutputs,
                },
                null,
                {
                    content: "Properties",
                    has_submenu: true,
                    callback: LGraphCanvas.onShowMenuNodeProperties,
                },
                null,
                {
                    content: "Title",
                    callback: LGraphCanvas.onShowNodeInfoEditor,
                },
                {
                    content: "Mode",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeMode,
                }];
            if(node.resizable !== false) {
                options.push({
                    content: "Resize",
                    callback: LGraphCanvas.onMenuResizeNode,
                });
            }
            options.push(
                {
                    content: "Collapse",
                    callback: LGraphCanvas.onMenuNodeCollapse,
                },
                { content: "Pin", callback: LGraphCanvas.onMenuNodePin },
                {
                    content: "Colors",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeColors,
                },
                {
                    content: "Shapes",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeShapes,
                },
                null,
            );
        }

        // disable Input and Output slots ? would need better check :: TODO use showMenuNodeOptional instead

        // r = node.processCallbackHandlers("onGetInputs",{
        //     def_cb: node.onGetInputs
        // });
        // if(r!==null && (typeof(r)=="object")){
        //     if(typeof(r.return_value)=="object"){
        //         if(typeof(r.return_value.length)!=="undefined" && r.return_value.length){
        //             options[0].disabled = false;
        //         }
        //     }else if(typeof(r.length)!=="undefined" && r.length){
        //         options[0].disabled = false;
        //     }
        // }

        // r = node.processCallbackHandlers("onGetOutputs",{
        //     def_cb: node.onGetOutputs
        // });
        // if(r!==null && (typeof(r)=="object")){
        //     if(typeof(r.return_value)=="object"){
        //         if(typeof(r.return_value.length)!=="undefined" && r.return_value.length){
        //             options[1].disabled = false;
        //         }
        //     }else if(typeof(r.length)!=="undefined" && r.length){
        //         options[0].disabled = false;
        //     }
        // }

        if (LiteGraph.do_add_triggers_slots)
            options[1].disabled = false;

        r = node.processCallbackHandlers("getExtraMenuOptions",{
            def_cb: node.getExtraMenuOptions
        }, this, options);
        if(r!==null && (typeof(r)=="object")){
            if(typeof(r.return_value)=="object"){
                if(typeof(r.return_value.length)!=="undefined" && r.return_value.length){
                    extra.push(null);
                    options = extra.concat(r.return_value);
                }
            }
        }

        if (node.clonable !== false) {
            options.push({
                content: "Clone",
                callback: LGraphCanvas.onMenuNodeClone,
            });
        }
        /*
        if(0) // @TODO: implement collpase to SubGraph
        options.push({
            content: "To Subgraph",
            callback: LGraphCanvas.onMenuNodeToSubgraph
        });
        */
        if (Object.keys(this.selected_nodes).length > 1) {
            options.push({
                content: "Align Selected To",
                has_submenu: true,
                callback: LGraphCanvas.onNodeAlign,
            })
        }

        options.push(null, {
            content: "Remove",
            disabled: !(node.removable !== false && !node.block_delete ),
            callback: LGraphCanvas.onMenuNodeRemove,
        });

        if (node.graph) {
            node.graph.processCallbackHandlers("onGetNodeMenuOptions",{
                def_cb: node.graph.onGetNodeMenuOptions
            }, options, node);
        }

        return options;
    }

    getGroupMenuOptions() {
        var o = [
            { content: "Title", callback: LGraphCanvas.onShowNodeInfoEditor },
            {
                content: "Color",
                has_submenu: true,
                callback: LGraphCanvas.onMenuNodeColors,
            },
            {
                content: "Font size",
                property: "font_size",
                type: "Number",
                callback: LGraphCanvas.onShowNodeInfoEditor,
            },
            null,
            { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove },
        ];

        return o;
    }

    processContextMenu(node, event) {
        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var menu_info = null;
        var options = {
            event: event,
            callback: inner_option_clicked,
            extra: node,
        };

        if(node)
            options.title = node.type;

        // check if mouse is in input
        var slot = null;
        if (node) {
            slot = node.getSlotInPosition(event.canvasX, event.canvasY);
            LGraphCanvas.active_node = node;
        }

        if (slot) {
            // on slot
            menu_info = [];
            let r = node.processCallbackHandlers("getSlotMenuOptions",{
                def_cb: node.getSlotMenuOptions
            }, slot);
            if(r!==null && (typeof(r)=="object" && typeof(r.return_value) == "object")){
                menu_info = r.return_value;
            } else {
                if (slot?.output?.links?.length || slot.input?.link) {
                    menu_info.push({ content: "Disconnect Links", slot: slot });
                }
                var _slot = slot.input || slot.output;
                if (_slot.removable && LiteGraph.canRemoveSlots) {
                    menu_info.push(_slot.locked
                        ? "Cannot remove"
                        : { content: "Remove Slot", slot: slot });
                }
                if (!_slot.nameLocked && LiteGraph.canRenameSlots) {
                    menu_info.push({ content: "Rename Slot", slot: slot });
                }

            }
            var slotOb = slot.input || slot.output;
            options.title = slotOb.type || "*";
            if (slotOb.type == LiteGraph.ACTION) {
                options.title = "Action";
            } else if (slotOb.type == LiteGraph.EVENT) {
                options.title = "Event";
            }
        } else {
            if (node) {
                // on node
                menu_info = this.getNodeMenuOptions(node);
            } else {
                menu_info = this.getCanvasMenuOptions();
                var group = this.graph.getGroupOnPos(
                    event.canvasX,
                    event.canvasY,
                );
                options.filter_enabled = false;
                if (group) {
                    // on group
                    menu_info.push(null, {
                        content: "Edit Group",
                        has_submenu: true,
                        submenu: {
                            title: "Group",
                            extra: group,
                            options: this.getGroupMenuOptions(group),
                        },
                    });
                    menu_info.push(null, {
                        content: "Select nodes",
                        canvas: this,
                        group: group,
                        callback: function(this_mi, options, e, menu){
                            console.warn(this_mi);
                            this_mi.canvas.selectNodes(this_mi.group._nodes);
                        }
                    });
                }
            }
        }

        // show menu
        if (!menu_info) {
            return;
        }

        LiteGraph.ContextMenu(menu_info, options, ref_window);

        function inner_option_clicked(v, options) {
            if (!v) {
                return;
            }
            let info;

            if (v.content == "Remove Slot") {
                info = v.slot;
                node.graph.beforeChange();
                if (info.input) {
                    node.removeInput(info.slot);
                } else if (info.output) {
                    node.removeOutput(info.slot);
                }
                node.graph.afterChange();
                return;
            } else if (v.content == "Disconnect Links") {
                info = v.slot;
                node.graph.beforeChange();
                if (info.output) {
                    node.disconnectOutput(info.slot);
                } else if (info.input) {
                    node.disconnectInput(info.slot);
                }
                node.graph.afterChange();
                return;
            } else if (v.content == "Rename Slot") {
                info = v.slot;
                var slot_info = info.input
                    ? node.getInputInfo(info.slot)
                    : node.getOutputInfo(info.slot);
                var dialog = that.createDialog(
                    "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
                    options,
                );
                var input = dialog.querySelector("input");
                if (input && slot_info) {
                    input.value = slot_info.label || "";
                }
                var inner = function() {
                    node.graph.beforeChange();
                    if (input.value) {
                        if (slot_info) {
                            slot_info.label = input.value;
                        }
                        that.setDirty(true);
                    }
                    dialog.close();
                    node.graph.afterChange();
                }
                dialog.querySelector("button").addEventListener("click", inner);
                input.addEventListener("keydown", function(e) {
                    dialog.is_modified = true;
                    if (e.keyCode == 27) {
                        // ESC
                        dialog.close();
                    } else if (e.keyCode == 13) {
                        inner(); // save
                    } else if (e.keyCode != 13 && e.target.localName != "textarea") {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                });
                input.focus();
            }
            // if(v.callback)
            //	return v.callback.call(that, node, options, e, menu, that, event );
        }
    }



    static DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";

    static link_type_colors = {
        "-1": "#A86",
        "number": "#AAA",
        "node": "#DCA",
        "string": "#77F",
        "boolean": "#F77",
    };

    static gradients = {}; // cache of gradients

    static search_limit = -1;

    static node_colors = {
        red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
        brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
        green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
        blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
        pale_blue: { color: "#2a363b", bgcolor: "#3f5159", groupcolor: "#3f789e" },
        cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
        purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
        yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
        black: { color: "#222", bgcolor: "#000", groupcolor: "#444" },
    };

    /**
     * returns ture if low qualty rendering requered at requested scale
     * */
    lowQualityRenderingRequired(activation_scale) {
        if ( this.ds.scale < activation_scale) {
            return this.low_quality_rendering_counter > this.low_quality_rendering_threshold;
        }
        return false;
    }

    /**
     * Changes the background color of the canvas.
     *
     * @method updateBackground
     * @param {image} String
     * @param {clearBackgroundColor} String
     * @
     */
    updateBackground(image, clearBackgroundColor) {
        this._bg_img = new Image();
        this._bg_img.name = image;
        this._bg_img.src = image;
        this._bg_img.onload = () => {
            this.draw(true, true);
        };
        this.background_image = image;
    
        this.clear_background = true;
        this.clear_background_color = clearBackgroundColor;
        this._pattern = null
    }

}

/* LGraphCanvas render */
var temp = new Float32Array(4);
var temp_vec2 = new Float32Array(2);

/**
 * draws the shape of the given node in the canvas
 * @method drawNodeShape
 **/
var tmp_area = new Float32Array(4);
var margin_area = new Float32Array(4);
var link_bounding = new Float32Array(4);
var tempA = new Float32Array(2);
var tempB = new Float32Array(2);

export class LGraphGroup {

    static opts = {
        inclusion_distance: 36 // distance to border to consider included inside the group 
    }

    /**
     * Constructor for the LGraphGroup class.
     * @param {string} [title="Group"] - The title of the group.
     */
    constructor(title = "Group") {
        this.title = title;
        this.font_size = 24;
        this.color = LiteGraph.LGraphCanvas.node_colors.pale_blue?.groupcolor ?? "#AAA";
        this._bounding = new Float32Array([10, 10, 140, 80]);
        this._pos = this._bounding.subarray(0, 2);
        this._size = this._bounding.subarray(2, 4);
        this._nodes = [];
        this._groups = [];
        this.graph = null;
        this.callbackhandler_setup();
    }

    callbackhandler_setup(){
        this.cb_handler = new CallbackHandler(this);
    }

    registerCallbackHandler(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.registerCallbackHandler(...arguments);
    };
    unregisterCallbackHandler(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.unregisterCallbackHandler(...arguments);
    };
    processCallbackHandlers(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.processCallbackHandlers(...arguments);
    };

    set pos(v) {
        if (!v || v.length < 2) {
            return;
        }
        this._pos[0] = v[0];
        this._pos[1] = v[1];
    }
    get pos() {
        return this._pos;
    }

    set size(v) {
        if (!v || v.length < 2) {
            return;
        }
        this._size[0] = Math.max(140, v[0]);
        this._size[1] = Math.max(80, v[1]);
    }
    get size() {
        return this._size;
    }

    /**
     * Updates the properties of the LGraphGroup instance based on the provided configuration object.
     * @param {Object} o - The configuration object with properties to update.
     * @param {string} o.title - The new title for the group.
     * @param {Float32Array} o.bounding - The new bounding box for the group.
     * @param {string} o.color - The new color for the group.
     * @param {number} o.font_size - The new font size for the group.
     */
    configure(o) {
        this.title = o.title;
        // this._bounding.set(o.bounding); // TODO original, will remove this comment: Happens that arrays are sometimes (strangely) exported as object with keyed strings: eg. [v0, v1] to {"0": v0, "1": v1}
        // this._bounding = LiteGraph.parseStringifyObject(o.bounding, this._bounding); // tried specific cleaner implementation, reverted to cloneObject
        this._bounding = LiteGraph.cloneObject(o.bounding, this._bounding);
        this.color = o.color;
        if(o.font_size)
            this.font_size = o.font_size;
    }

    /**
     * Serializes the LGraphGroup instance into a plain JavaScript object.
     * @returns {Object} - The serialized representation of the LGraphGroup instance.
     * - title: string - The title of the group.
     * - bounding: Array<number> - The bounding box coordinates [x, y, width, height].
     * - color: string - The color of the group.
     * - font_size: number - The font size of the group.
     */
    serialize() {
        var b = this._bounding;
        return {
            title: this.title,
            bounding: b.map((value) => Math.round(value)),
            color: this.color,
            font_size: this.font_size,
        };
    }

    /**
     * Moves the LGraphGroup instance by the specified deltas and optionally updates the positions of contained nodes.
     * @param {number} deltax - The amount to move the group along the x-axis.
     * @param {number} deltay - The amount to move the group along the y-axis.
     * @param {boolean} ignore_nodes - Flag to indicate whether to move contained nodes along with the group.
     */
    move(deltax, deltay, ignore_nodes) {
        if(isNaN(deltax))
            console.error?.("LGraphGroup.move() deltax NaN");
        if(isNaN(deltay))
            console.error?.("LGraphGroup.move() deltay NaN");

        this._pos[0] += deltax;
        this._pos[1] += deltay;

        if (ignore_nodes) {
            return;
        }
        this._nodes.forEach((node) => {
            node.pos[0] += deltax;
            node.pos[1] += deltay;
        });
        this._groups.forEach((group) => {
            group.pos[0] += deltax;
            group.pos[1] += deltay;
        });
    }

    /**
     * Recomputes and updates the list of nodes inside the LGraphGroup based on their bounding boxes.
     * This method checks for nodes that overlap with the group's bounding box and updates the internal nodes list accordingly.
     */
    recomputeInsideNodes() {
        this._nodes.length = 0;
        var nodes = this.graph._nodes;
        var node_bounding = new Float32Array(4);

        this._nodes = nodes.filter((node) => {
            node.getBounding(node_bounding);
            return LiteGraph.overlapBounding(this._bounding, node_bounding, -LGraphGroup.opts.inclusion_distance);
        });
        this.recomputeInsideGroups();
    }

    /**
     * Recomputes and updates the list of groups [LGraphGroup] inside this LGraphGroup based on their bounding boxes.
     */
    recomputeInsideGroups() {
        this._groups.length = 0;
        var groups = this.graph._groups;
        var group_bounding = new Float32Array(4);

        this._groups = groups.filter((group) => {
            group.getBounding(group_bounding);
            return LiteGraph.isBoundingInsideRectangle(group_bounding, ...this._bounding)
            // return LiteGraph.overlapBounding(this._bounding, group_bounding, -LGraphGroup.opts.inclusion_distance);
        });
    }

    getBounding = function(){ LiteGraph.LGraphNode.prototype.getBounding.call(this,...arguments); };
    isPointInside = LiteGraph.LGraphNode.prototype.isPointInside;
    setDirtyCanvas = LiteGraph.LGraphNode.prototype.setDirtyCanvas;
}


/*
title: string
pos: [x,y]
size: [x,y]
size_basic: [x,y] minimum size for the node beforeRecalculation

input|output: every connection
    +  { name:string, type:string, pos: [x,y]=Optional, direction: "input"|"output", links: Array });

general properties:
    + clip_area: if you render outside the node, it will be clipped
    + unsafe_execution: not allowed for safe execution
    + skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected
    + resizable: if set to false it wont be resizable with the mouse
    + horizontal: slots are distributed horizontally
    + widgets_start_y: widgets start at y distance from the top of the node

flags object:
    + collapsed: if it is collapsed

supported callbacks:
    + onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)
    + onRemoved: when removed from graph
    + onStart:	when the graph starts playing
    + onStop:	when the graph stops playing
    + onDrawForeground: render the inside widgets inside the node
    + onDrawBackground: render the background area inside the node (only in edit mode)
    + onMouseDown
    + onMouseMove
    + onMouseUp
    + onMouseEnter
    + onMouseLeave
    + onExecute: execute the node
    + onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)
    + onGetInputs: returns an array of possible inputs
    + onGetOutputs: returns an array of possible outputs
    + onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])
    + onDblClick: double clicked in the node
    + onInputDblClick: input slot double clicked (can be used to automatically create a node connected)
    + onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)
    + onConfigure: called after the node has been configured
    + onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)
    + onSelected
    + onDeselected
    + onDropItem : DOM item dropped over the node
    + onDropFile : file dropped over the node
    + onConnectInput : if returns false the incoming connection will be canceled
    + onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )
    + onAction: action slot triggered
    + getExtraMenuOptions: to add option to context menu
*/

/**
 * Base Class for all the node type classes
 * @class LGraphNode
 * @param {String} name a name for the node
 */

export class LGraphNode {

    cb_handler = false;

    // TODO check when is this called: a default node from the ones included will have his constructor
    // should every node extend this istead of 
    constructor(title = "") {
        // a custom registered node will have his custom constructor
        LiteGraph.log_verbose("lgraphNODE", "ORIGINAL constructor",this,title);

        this.title = title;

        this.post_constructor(...arguments);
    }

    post_constructor(){

        this.size ??= LiteGraph.NODE_MIN_SIZE; //this.size ??= [LiteGraph.NODE_WIDTH, 60];
        this.size_basic ??= this.size;
        this.graph ??= null;

        this._pos ??= new Float32Array(10, 10);

        if (LiteGraph.use_uuids) {
            this.id ??= LiteGraph.uuidv4();
        } else {
            this.id ??= -1; // not know till not added
        }
        this.type ??= null;

        // inputs available: array of inputs
        this.inputs ??= [];
        this.outputs ??= [];
        this.connections ??= [];

        // local data
        this.properties ??= {}; // for the values
        this.properties_info ??= []; // for the info

        this.flags ??= {};

        // DBG EXCESS LiteGraph.log_verbose("lgraphNODE", "postconstruct",this,...arguments);
        // register CallbackHandler methods on this
        this.callbackhandler_setup();
        // this cbhandler is probably not registered by a node that does not inherit default contructor, if that has not called callbackhandler_setup yet
        this.processCallbackHandlers("onPostConstruct",{
            def_cb: this.onPostConstruct
        });
        LiteGraph.processCallbackHandlers("on_lgraphnode_construct",{
            def_cb: LiteGraph.on_lgraphnode_construct
        }, this);
    }

    callbackhandler_setup(){
        this.cb_handler = new CallbackHandler(this);
        // register CallbackHandler methods on this // Should move as class standard class methods?
        // this.registerCallbackHandler = function(){ return this.cb_handler.registerCallbackHandler(...arguments); };
        // this.unregisterCallbackHandler = function(){ return this.cb_handler.unregisterCallbackHandler(...arguments); };
        // this.processCallbackHandlers = function(){ return this.cb_handler.processCallbackHandlers(...arguments); };
    }

    registerCallbackHandler(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.registerCallbackHandler(...arguments);
    };
    unregisterCallbackHandler(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.unregisterCallbackHandler(...arguments);
    };
    processCallbackHandlers(){
        if(!this.cb_handler) this.callbackhandler_setup(); // needed if constructor calls callback events
        return this.cb_handler.processCallbackHandlers(...arguments);
    };

    set pos(v) {
        if (!v || v.length < 2) {
            return;
        }
        this._pos ??= new Float32Array(10, 10);
        this._pos[0] = v[0];
        this._pos[1] = v[1];
    }
    get pos() {
        return this._pos;
    }

    /**
     * configure a node from an object containing the serialized info
     * @method configure
     */
    configure(info) {
        
        LiteGraph.log_debug("lgraphnode", "configure",this,info);

       if(this.graph)
           this.graph.onGraphChanged({action: "nodeBeforeConfigure", doSave: false});

        Object.entries(info).forEach(([key, value]) => {
            if (key === "properties") {
                for (var k in value) {
                    this.properties[k] = value[k];
                    this.processCallbackHandlers("onPropertyChanged",{
                        def_cb: this.onPropertyChanged
                    }, k, value[k]);
                }
                return;
            }

            if(LiteGraph.reprocess_slot_while_node_configure){
                // process inputs and outputs, checking for name to handle node changes
                if(key === "inputs" || key === "outputs"){
                    LiteGraph.log_debug("lgraphnode", "syncObjectByProperty", key, info[key], this[key]);
                    const resSync = this.syncObjectByProperty(info[key], this[key], "name");
                    this[key] = resSync.ob_dest;
                    if(resSync.keys_remap && Object.keys(resSync.keys_remap).length){
                        if(this.graph){
                            for(let slotFrom in resSync.keys_remap){
                                let slotTo = resSync.keys_remap[slotFrom];
                                this.graph.updateNodeLinks(this, key==="inputs", slotFrom, slotTo);
                            }
                        }
                    }
                    return;
                }
            }
            if (value === null) {
                // CHECK THIS should copy null value key? probably should
                LiteGraph.log_verbose("lgraphnode", "configure", "should copy null value key? probably should", key, this[key])
                return;
            } else if (typeof value === "object") {
                if (this[key] && typeof(this[key].configure)=="function") {
                    this[key].configure(value);
                    LiteGraph.log_verbose("lgraphnode","configure","use var internal configure method",key,value);
                } else {
                    LiteGraph.log_verbose("lgraphnode","configure","set ob var key",key,value,this[key]);
                    this[key] = LiteGraph.cloneObject(value, this[key]);
                }
            } else {
                LiteGraph.log_verbose("lgraphnode","configure","set node var",key,value);
                this[key] = value;
            }
        });

        if (!info.title) {
            this.title = this.constructor.title;
        }

        this.inputs?.forEach((input, i) => {
            if(!input.link)
                return;
            const link_info = this.graph ? this.graph.links[input.link] : null;
            this.processCallbackHandlers("onConnectionsChange",{
                def_cb: this.onConnectionsChange
            }, LiteGraph.INPUT, i, true, link_info, input);
            this.processCallbackHandlers("onInputAdded",{
                def_cb: this.onInputAdded
            }, input);
        });

        this.outputs?.forEach((output, i) => {
            if (!output.links)
                return;
            output.links.forEach((link, i) => {
                const link_info = this.graph?.links[link] || null; // fixed
                LiteGraph.log_verbose("lgraphnode", "configure","cycle outputlinks",link,i,link_info);
                this.processCallbackHandlers("onConnectionsChange",{
                    def_cb: this.onConnectionsChange
                }, LiteGraph.OUTPUT, i, true, link_info, output);
            });
            this.processCallbackHandlers("onOutputAdded",{
                def_cb: this.onOutputAdded
            }, output);
        });

        if (this.widgets) {
            this.widgets.forEach((w) => {
                if (!w) {
                    return;
                }
                if (w.options && w.options.property && this.properties[w.options.property] !== undefined) {
                    w.value = JSON.parse(JSON.stringify(this.properties[w.options.property]));
                }
            });

            info.widgets_values?.forEach((value, i) => {
                if (this.widgets[i]) {
                    this.widgets[i].value = value;
                }
            });
        }
        this.processCallbackHandlers("onConfigure",{
            def_cb: this.onConfigure
        }, info);
        this.graph?.onGraphChanged({action: "nodeConfigure", doSave: false});
        LiteGraph.log_debug("lgraphnode", "configure complete",this);
    }

    /**
     * serialize the content
     * @method serialize
     */

    serialize() {
        // create serialization object
        var o = {
            id: this.id,
            type: this.type,
            pos: this.pos,
            size: this.size,
            flags: LiteGraph.cloneObject(this.flags),
            order: this.order,
            mode: this.mode,
        };

        // special case for when there were errors
        if (this.constructor === LGraphNode && this.last_serialization) {
            return this.last_serialization;
        }

        if (this.inputs) {
            o.inputs = LiteGraph.cloneObject(this.inputs);
        }

        if (this.outputs) {
            // clear outputs last data (because data in connections is never serialized but stored inside the outputs info)
            this.outputs.forEach((output) => {
                delete output._data;
            });
            o.outputs = LiteGraph.cloneObject(this.outputs);
        }

        if (this.title && this.title != this.constructor.title) {
            o.title = this.title;
        }

        if (this.properties) {
            o.properties = LiteGraph.cloneObject(this.properties);
        }

        if (this.widgets && this.serialize_widgets) {
            o.widgets_values = this.widgets.map((widget) => widget?.value ?? null);
        }

        o.type ??= this.constructor.type;

        if (this.color) {
            o.color = this.color;
        }
        if (this.bgcolor) {
            o.bgcolor = this.bgcolor;
        }
        if (this.boxcolor) {
            o.boxcolor = this.boxcolor;
        }
        if (this.shape) {
            o.shape = this.shape;
        }

        let r = this.processCallbackHandlers("onSerialize",{
            def_cb: this.onSerialize
        }, o);
        // DBG EXCESS LiteGraph.log_verbose("lgraphnode", "serialize", "onSerialize", o, r);

        if(r!==null && (typeof(r)=="object" && r.return_value!==null)){
            LiteGraph.log_warn("lgraphnode", "onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
        }
        return o;
    }

    /* Creates a clone of this node */
    clone() {
        var node = LiteGraph.createNode(this.type);
        if (!node) {
            return null;
        }

        // we clone it because serialize returns shared containers
        var data = LiteGraph.cloneObject(this.serialize());

        // remove links
        data.inputs?.forEach((input) => {
            input.link = null;
        });

        data.outputs?.forEach((output) => {
            if(output.links)
                output.links.length = 0;
        });

        delete data["id"];

        if (LiteGraph.use_uuids) {
            data["id"] = LiteGraph.uuidv4()
        }

        // remove links
        node.configure(data);
        return node;
    }

    /**
     * serialize and stringify
     * @method toString
     */

    toString() {
        return JSON.stringify(this.serialize());
    }

    // LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph

    /**
     * get the title string
     * @method getTitle
     */

    getTitle() {
        return this.title ?? this.constructor.title;
    }

    /**
     * sets the value of a property
     * @method setProperty
     * @param {String} name
     * @param {*} value
     */
    setProperty(name, value) {
        this.properties ||= {};

        // Check if the new value is the same as the current value
        if (value === this.properties[name]) {
            return;
        }

        const prevValue = this.properties[name];
        this.properties[name] = value;

        // Call onPropertyChanged and revert the change if needed
        let r = this.processCallbackHandlers("onPropertyChanged",{
            def_cb: this.onPropertyChanged
        }, name, value, prevValue);
        if(r===false || (r!==null && (typeof(r)=="object" && r.return_value===false))){
            this.properties[name] = prevValue;
            LiteGraph.log_debug("lgraphnode","setProperty","prevent property set by cbHandler",name,value,prevValue,r);
        }

        // Update the widget value associated with the property name
        const widgetToUpdate = this.widgets?.find((widget) => widget && widget.options?.property === name);

        if (widgetToUpdate) {
            widgetToUpdate.value = value;
        }
    }



    // Execution *************************
    /**
     * sets the output data
     * @method setOutputData
     * @param {number|string} slot
     * @param {*} data
     */
    setOutputData(slot, data) {
        if (!this.outputs) {
            return;
        }

        if(slot?.constructor === String) {
            // not a niche case: consider that removable and optional slots will move indexes! just pass int value if preferred
            slot = this.findOutputSlot(slot);
        }
        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }
        slot = this.getOutputSlot(slot);

        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }

        // store data in the output itself in case we want to debug
        output_info._data = data;

        // if there are connections, pass the data to the connections
        this.outputs[slot].links?.forEach((link_id) => {
            const link = this.graph.links[link_id];
            if (link) {
                link.data = data;
            }
        });
    }

    /**
     * sets the output data type, useful when you want to be able to overwrite the data type
     * @method setOutputDataType
     * @param {number|string} slot
     * @param {String} datatype
     */
    setOutputDataType(slot, type) {
        if (!this.outputs) {
            return;
        }
        if(slot?.constructor === String) {
            // not a niche case: consider that removable and optional slots will move indexes! just pass int value if preferred
            slot = this.findOutputSlot(slot);
        }
        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }
        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }
        // store data in the output itself in case we want to debug
        output_info.type = type;

        // if there are connections, pass the data to the connections
        this.outputs[slot]?.links?.forEach((link_id) => {
            if (this.graph.links[link_id]) {
                this.graph.links[link_id].type = type;
            }
        });
    }

    /**
     * Retrieves the input data (data traveling through the connection) from one slot
     * @method getInputData
     * @param {number|string} slot
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns undefined
     */
    getInputData(slot, force_update, refresh_tree) {
        if (!this.inputs) {
            return;
        } // undefined;

        if(slot?.constructor === String) {
            // not a niche case: consider that removable and optional slots will move indexes! just pass int value if preferred
            slot = this.findInputSlot(slot);
        }
        if (slot == -1 || slot >= this.inputs.length) {
            return;
        }

        if(this.inputs[slot].type==LiteGraph.ACTION){
            // DBG EXCESS LiteGraph.log_verbose("lgraphnode", "getInputData", "skip getting data for event type", this.inputs[slot]);
            return;
        }

        let ob_input = this.inputs[slot];
        let link_id = ob_input.link;
        let link = this.graph.links[link_id];
        if (!link) {
            // DBG EXCESS LiteGraph.log_verbose("lgraphnode", "getInputData", "No link", link_id, slot, this);
            return null;
        }

        if (!force_update) {
            return link.data;
        }

        // forcing origin data update
        // will execute the node (eventually after updating ancestors)

        let node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            LiteGraph.log_debug("lgraphnode", "getInputData","No origin node, return the link data", link.data, link, slot, this);
            return link.data;
        }

        // TODO Consider moving this out of here and use a single ancestorsCalculation (for each event?)
        // CHECK THIS : used in logic/while , is ATM necessary? does this solve reading self value while executing loops ?
        if (refresh_tree) {
            LiteGraph.log_warn("CHECK THIS", "lgraphnode", "getInputData","Refreshing ancestors tree by ForcedUpdateSlotData", link, slot, this);
            LiteGraph.log_debug("lgraphnode", "getInputData","Refreshing ancestors tree by ForcedUpdateSlotData", link, slot, this);
            let uIdRand = this.id+"_getInputData_forced_"+LiteGraph.uuidv4();
            let optsAncestors = {action: uIdRand, options: {action_call: uIdRand}};
            this.refreshAncestors(optsAncestors);
        }

        if (node.updateOutputData) { // tag: node event entrypoint
            node.updateOutputData(link.origin_slot);
        } else {
            node.doExecute();
        }

        return link.data;
    }

    /**
     * Retrieves the input data type (in case this supports multiple input types)
     * @method getInputDataType
     * @param {number|string} slot
     * @return {String} datatype in string format
     */
    getInputDataType(slot) {
        if (!this.inputs) {
            return null;
        } // undefined;
        if(slot?.constructor === String) {
            // not a niche case: consider that removable and optional slots will move indexes! just pass int value if preferred
            slot = this.findInputSlot(slot);
        }
        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return null;
        }

        if(this.inputs[slot].type==LiteGraph.ACTION){
            // DBG EXCESS LiteGraph.log_verbose("lgraphnode", "getInputDataType", "skip getting data for event type", this.inputs[slot]);
            return;
        }

        var link_id = this.inputs[slot].link;
        var link = this.graph.links[link_id];
        if (!link) {
            // bug: weird case but it happens sometimes
            LiteGraph.log_warn("lgraphnode", "getInputDataType", "No link", link_id, slot, this);
            return null;
        }
        var node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.type;
        }
        var output_info = node.outputs[link.origin_slot];
        if (output_info) {
            return output_info.type;
        }
        return null;
    }

    /**
     * Retrieves the input data from one slot using its name instead of slot number
     * OLD: IMPLEMENTED in getInputData,use that instead
     * @method getInputDataByName
     * @param {String} slot_name
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns null
     */
    getInputDataByName(slot_name, force_update) {
        var slot = this.findInputSlot(slot_name);
        if (slot == -1) {
            return null;
        }
        return this.getInputData(slot, force_update);
    }

    /**
     * tells you if there is a connection in one input slot
     * @method isInputConnected
     * @param {number} slot
     * @return {boolean}
     */
    isInputConnected(slot) {
        if (!this.inputs) {
            return false;
        }
        return slot < this.inputs.length && this.inputs[slot].link != null;
    }

    /**
     * tells you info about an input connection (which node, type, etc)
     * @method getInputInfo
     * @param {number} slot
     * @return {Object} object or null { link: id, name: string, type: string or 0 }
     */
    getInputInfo(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            return this.inputs[slot];
        }
        return null;
    }

    /**
     * Returns the link info in the connection of an input slot
     * @method getInputLink
     * @param {number} slot
     * @return {LiteGraph.LLink} object or null
     */
    getInputLink(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            var slot_info = this.inputs[slot];
            return this.graph.links[slot_info.link];
        }
        return null;
    }

    /**
     * returns the node connected in the input slot
     * @method getInputNode
     * @param {number} slot
     * @return {LGraphNode} node or null
     */
    getInputNode(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot >= this.inputs.length) {
            return null;
        }
        var input = this.inputs[slot];
        if (!input || input.link === null) {
            return null;
        }
        var link_info = this.graph.links[input.link];
        if (!link_info) {
            return null;
        }
        return this.graph.getNodeById(link_info.origin_id);
    }

    /**
     * returns the value of an input with this name, otherwise checks if there is a property with that name
     * @method getInputOrProperty
     * @param {string} name
     * @return {*} value
     */
    getInputOrProperty(name) {
        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i < l; ++i) {
                var input_info = this.inputs[i];
                if (name == input_info.name && input_info.link != null) {
                    var link = this.graph.links[input_info.link];
                    if (link) {
                        return link.data;
                    }
                }
            }
        }
        return this.properties ? this.properties[name] : null;
    }

    /**
     * tells you the last output data that went in that slot
     * @method getOutputData
     * @param {number} slot
     * @return {Object}  object or null
     */
    getOutputData(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot >= this.outputs.length) {
            return null;
        }

        var info = this.outputs[slot];
        return info._data;
    }

    /**
     * tells you info about an output connection (which node, type, etc)
     * @method getOutputInfo
     * @param {number} slot
     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
     */
    getOutputInfo(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot < this.outputs.length) {
            return this.outputs[slot];
        }
        return null;
    }

    /**
     * tells you if there is a connection in one output slot
     * @method isOutputConnected
     * @param {number} slot
     * @return {boolean}
     */
    isOutputConnected(slot) {
        if (!this.outputs) {
            return false;
        }
        return (
            slot < this.outputs.length &&
            this.outputs[slot].links &&
            this.outputs[slot].links.length
        );
    }

    /**
     * tells you if there is any connection in the output slots
     * @method isAnyOutputConnected
     * @return {boolean}
     */
    isAnyOutputConnected() {
        return this.outputs ? this.outputs.some((output) => output.links && output.links.length) : false;
    }

    /**
     * retrieves all the nodes connected to this output slot
     * @method getOutputNodes
     * @param {number} slot
     * @return {array}
     */
    getOutputNodes(slot) {
        if (!this.outputs || slot >= this.outputs.length) {
            return null;
        }

        const output = this.outputs[slot];
        if (!output.links || output.links.length === 0) {
            return null;
        }

        return output.links
            .map((link_id) => this.graph.links[link_id])
            .filter((link) => link)
            .map((link) => this.graph.getNodeById(link.target_id))
            .filter((target_node) => target_node);
    }

    addOnTriggerInput() {
        var trigS = this.findInputSlot("onTrigger");
        if (trigS == -1) { // !trigS ||
            this.addInput("onTrigger", LiteGraph.EVENT, {removable: true, nameLocked: true});
            return this.findInputSlot("onTrigger");
        }
        return trigS;
    }

    addOnExecutedOutput() {
        var trigS = this.findOutputSlot("onExecuted");
        if (trigS == -1) { // !trigS ||
            this.addOutput("onExecuted", LiteGraph.ACTION, {removable: true, nameLocked: true});
            return this.findOutputSlot("onExecuted");
        }
        return trigS;
    }

    onAfterExecuteNode(param, options) {
        var trigS = this.findOutputSlot("onExecuted");
        if (trigS != -1) {
            LiteGraph.log_verbose("lgraphnode","onAfterExecuteNode",this.id+":"+this.order+" triggering slot onAfterExecute", param, options);
            this.triggerSlot(trigS, param, null, options);
        }
    }

    onAfterActionedNode(param, options) {
        var trigS = this.findOutputSlot("onExecuted");
        if (trigS != -1) {
            LiteGraph.log_verbose("lgraphnode","onAfterActionedNode",this.id+":"+this.order+" triggering slot onAfterActionedNode",this, trigS, param, options);
            this.triggerSlot(trigS, param, null, options);
        }
    }

    // ComfyUI compatiblity
    onResize(size){
        // empty, will eventually implement
    }

    changeMode(modeTo) {
        switch(modeTo) {

            case LiteGraph.ON_TRIGGER:
                this.addOnTriggerInput();
                this.addOnExecutedOutput();
                break;

            case LiteGraph.ON_EVENT:
                // this.addOnExecutedOutput();
                break;
            case LiteGraph.NEVER:
                break;
            case LiteGraph.ALWAYS:
                break;
            case LiteGraph.ON_REQUEST:
                break;

            default:
                return false;
        }
        this.mode = modeTo;
        return true;
    }

    /**
     * Triggers the execution of actions that were deferred when the action was triggered
     * @method executePendingActions
     */
    executePendingActions() {
        if(!this._waiting_actions || !this._waiting_actions.length)
            return;
        this._waiting_actions.forEach((p) => {
            this.onAction(p[0], p[1], p[2], p[3], p[4]);
        });
        this._waiting_actions.length = 0;
    }

    /**
     * Triggers the node code execution, place a boolean/counter to mark the node as being executed
     * @method doExecute
     * @param {*} param
     * @param {*} options
     */
    doExecute(param, options = {}) {

        if (this.mode === LiteGraph.NEVER){
            LiteGraph.log_verbose("lgraphNODE", "doExecute", "prevent execution in mode NEVER", this.id);
            return;
        }

        // enable this to give the event an ID
        options.action_call ??= `${this.id}_exec_${LiteGraph.uuidv4()}`; // TODO replace all ath.floor(Math.random()*9999) by LiteGraph.uuidv4

        if (this.graph.nodes_executing && this.graph.nodes_executing[this.id]) {
            LiteGraph.log_debug("lgraphNODE", "doExecute", "already executing! Prevent! "+this.id+":"+this.order);
            return;
        }
        if (LiteGraph.ensureNodeSingleExecution && this.exec_version && this.exec_version >= this.graph.iteration && this.exec_version !== undefined) {
            LiteGraph.log_debug("lgraphNODE", "doExecute", "!! NODE already EXECUTED THIS STEP !! "+this.exec_version);
            return;
        }
        // LiteGraph.log_debug("Actioned ? "+this.id+":"+this.order+" :: "+this.action_call);
        if (LiteGraph.ensureUniqueExecutionAndActionCall) {
            // if(this.action_call && options && options.action_call && this.action_call == options.action_call){
            if(this.graph.nodes_executedAction[this.id] && options && options.action_call && this.graph.nodes_executedAction[this.id] == options.action_call) {
                LiteGraph.log_debug("lgraphNODE", "doExecute", "!! NODE already ACTION THIS STEP !! "+options.action_call);
                return;
            }
        }

        this.graph.nodes_executing[this.id] = true; // .push(this.id);

        // update binded properties
        if(LiteGraph.properties_allow_input_binding){
            this.doUpdateBindedInputProperties();
        }

        // --- NODE EXECUTION ---
        // this.onExecute(param, options);
        this.processCallbackHandlers("onExecute",{
            def_cb: this.onExecute
        }, param, options);

        this.graph.nodes_executing[this.id] = false; // .pop();

        // save execution/action ref
        this.exec_version = this.graph.iteration;
        if(options && options.action_call) {
            this.action_call = options.action_call; // if (param)
            this.graph.nodes_executedAction[this.id] = options.action_call;
        }

        this.execute_triggered = 2; // helper to draw currently executing, the nFrames it will be used (-- each step), means "how old" is the event
        
        this.processCallbackHandlers("onAfterExecuteNode",{
            def_cb: this.onAfterExecuteNode
        }, param, options);
    }
    /**
     * retrocompatibility :: old doExecute
     * @method doExecute
     * @param {*} param
     * @param {*} options
     */
    execute(param, options = {}) {
        LiteGraph.log_debug("lgraphnode","execute","You should replace .execute with .doExecute, has been renamed");
        return this.doExecute(param, options);
    }

    /**
     * Triggers an action, wrapped by logics to control execution flow
     * @method actionDo
     * @param {String} action name
     * @param {*} param
     */
    actionDo(action, param, options = {}, action_slot) {
        // if (this.onAction) {

            // enable this to give the event an ID
            options.action_call ??= `${this.id}_${action?action:"action"}_${LiteGraph.uuidv4()}`;

            if (LiteGraph.ensureNodeSingleAction) {
                if (this.graph.nodes_actioning && this.graph.nodes_actioning[this.id] == options.action_call) { // == action){
                    LiteGraph.log_debug("lgraphnode", "actionDo", "already actioning! Prevent! "+this.id+":"+this.order+" :: "+options.action_call);
                    return;
                }
            }
            LiteGraph.log_debug("CheckActioned ? "+this.id+":"+this.order+" :: "+this.action_call);
            if (LiteGraph.ensureUniqueExecutionAndActionCall) {
                // if(this.action_call && options && options.action_call && this.action_call == options.action_call){
                if(this.graph.nodes_executedAction[this.id] && options && options.action_call && this.graph.nodes_executedAction[this.id] == options.action_call) {
                    LiteGraph.log_debug("lgraphnode", "actionDo", "!! NODE already ACTION THIS STEP !! "+options.action_call);
                    return;
                }
            }

            this.graph.nodes_actioning[this.id] = (action?action:"actioning"); // .push(this.id);

            // this.onAction(action, param, options, action_slot);
            this.processCallbackHandlers("onAction",{
                def_cb: this.onAction
            }, action, param, options, action_slot);

            this.graph.nodes_actioning[this.id] = false; // .pop();

            // save execution/action ref
            if(options && options.action_call) {
                this.action_call = options.action_call; // if (param)
                this.graph.nodes_executedAction[this.id] = options.action_call;
            }
        // }
        this.action_triggered = 2; // the nFrames it will be used (-- each step), means "how old" is the event
        // callback on after actioned
        // TODO check if should trigger slots like when executing or not
        this.processCallbackHandlers("onAfterActionedNode",{
            def_cb: this.onAfterActionedNode
        }, param, options);
    }

    /**
     * Triggers an event in this node, this will trigger any output with the same name
     * @method trigger
     * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
     * @param {*} param
     */
    trigger(action, param, options) {
        if (!this.outputs || this.outputs.length === 0) {
            return;
        }

        // TODO check this, investigate, _last_trigger_time ? who calls trigger ?
        this.graph && (this.graph._last_trigger_time = LiteGraph.getTime());

        let triggered = 0;
        this.outputs.forEach((output, i) => {
            if (output && output.type === LiteGraph.EVENT && (!action || output.name === action)) {
                // TODO add callback handler onTriggerSlot
                LiteGraph.log_verbose("lgraphnode", "trigger", "triggering slot", i, param, options);
                this.triggerSlot(i, param, null, options);
                triggered++;
            }else{
                LiteGraph.log_verbose("lgraphnode", "trigger", "skip slot", output);
            }
        });
        if(!triggered){
            LiteGraph.log_debug("lgraphnode", "trigger", "nothing found", ...arguments);
        }
    }

    /**
     * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes
     * @method triggerSlot
     * @param {Number|string} slot the output slot
     * @param {*} param
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    triggerSlot(slot, param, link_id, options = {}) {
        if (!this.outputs) {
            return;
        }
        if(slot === null) {
            LiteGraph.log_error("lgraphnode", "triggerSlot","wrong slot",slot);
            return;
        }
        if(slot.constructor !== Number){
            // LiteGraph.log_warn("lgraphnode", "triggerSlot","slot must be a number, use node.trigger('name') if you want to use a string");
            slot = this.getOutputSlot(slot);
        }
        var output = this.outputs[slot];
        if (!output) {
            return;
        }

        var links = output.links;
        if (!links || !links.length) {
            return;
        }

        if (this.mode === LiteGraph.NEVER){
            return;
        }

        // check for ancestors calls
        if (this.graph && this.graph.ancestorsCall) {
            // LiteGraph.log_debug("ancestors call, prevent triggering slot "+slot+" on "+this.id+":"+this.order);
            return;
        }

        if (this.graph) {
            this.graph._last_trigger_time = LiteGraph.getTime();
        }

        // for every link attached here
        for (var k = 0; k < links.length; ++k) {
            var id = links[k];
            if (link_id != null && link_id != id) {
                // to skip links
                continue;
            }
            var link_info = this.graph.links[links[k]];
            if (!link_info) {
                // not connected
                continue;
            }
            link_info._last_time = LiteGraph.getTime();
            var node = this.graph.getNodeById(link_info.target_id);
            if (!node) {
                // node not found?
                continue;
            }
            var target_slot = node.inputs[link_info.target_slot];
            if (node.mode === LiteGraph.ON_TRIGGER || target_slot?.name === "onTrigger") {
                // generate unique trigger ID if not present
                if (!options.action_call)
                    options.action_call = `${this.id}_trigg_${LiteGraph.uuidv4()}`; // TODO replace here and there fakeunique ID with real unique
                if (LiteGraph.refreshAncestorsOnTriggers)
                    node.refreshAncestors({action: "trigger", param: param, options: options});
                if (node.onExecute) {
                    // -- wrapping node.onExecute(param); --
                    node.doExecute(param, options);
                }
            } else if (node.onAction) {
                // generate unique action ID if not present
                if (!options.action_call) options.action_call = `${this.id}_act_${LiteGraph.uuidv4()}`;
                // pass the action name
                let target_connection = node.inputs[link_info.target_slot];
                
                // METHOD 1 ancestors
                if (LiteGraph.refreshAncestorsOnActions)
                    node.refreshAncestors({action: target_connection.name, param: param, options: options});

                // instead of executing them now, it will be executed in the next graph loop, to ensure data flow
                if(LiteGraph.use_deferred_actions && node.onExecute) {
                    node._waiting_actions ??= [];
                    node._waiting_actions.push([target_connection.name, param, options, link_info.target_slot]);
                    LiteGraph.log_debug("lgraphnode", "triggerSlot","push to deferred", target_connection.name, param, options, link_info.target_slot);//+this.id+":"+this.order+" :: "+target_connection.name);
                } else {
                    // wrap node.onAction(target_connection.name, param);
                    LiteGraph.log_debug("lgraphnode", "triggerSlot","call actionDo", node, target_connection.name, param, options, link_info.target_slot);
                    node.actionDo( target_connection.name, param, options, link_info.target_slot );
                }
            } else {
                // TODO CHECK
                LiteGraph.log_debug("lgraphnode", "triggerSlot","not executing node, what to do with this Node Mode on slot triggered?", node.mode, this);
            }
        }
    }

    /**
     * clears the trigger slot animation
     * @method clearTriggeredSlot
     * @param {Number} slot the index of the output slot
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    clearTriggeredSlot(slot, link_id) {
        if (!this.outputs || !this.outputs[slot] || !this.outputs[slot].links) {
            return;
        }

        this.outputs[slot].links.forEach((id) => {
            if (link_id !== null && link_id !== id) {
                // Skip links
                return;
            }

            const link_info = this.graph.links[id];
            if (!link_info) {
                // Not connected
                return;
            }

            link_info._last_time = 0;
        });
    }

    doUpdateBindedInputProperties(){
        let thisNode = this;
        this.inputs.forEach((ob_input) => {
            if(ob_input.param_bind){
                LiteGraph.log_debug("lgraphnode","doUpdateBindedInputProperties","has bind",ob_input,thisNode);
                if(thisNode.properties && typeof(thisNode.properties[ob_input.name])!=="undefined"){
                    let inputData = thisNode.getInputData(ob_input.name);
                    // thisNode.properties[ob_input.name] = link.data;
                    LiteGraph.log_debug("lgraphnode","doUpdateBindedInputProperties","update value",ob_input.name,inputData,thisNode);
                    this.setProperty(ob_input.name, inputData);
                }else{
                    LiteGraph.log_warn("lgraphnode","doUpdateBindedInputProperties","inexisting property",ob_input.name,inputData,thisNode);
                }
            }   
        });
    }

    /**
     * set the node size to auto computed
     * @method autoSize
     */
    autoSize(only_greater_than_current){
        let minSize = this.computeSize();
        let newSize = only_greater_than_current && this.size
                        ? [Math.max(this.size[0], minSize[0]),Math.max(this.size[1], minSize[1])]
                        : minSize;
        this.setSize(newSize);
    }

    /**
     * changes node size and triggers callback
     * @method setSize
     * @param {vec2} size
     */
    setSize(size) {
        this.size = size;
        this.processCallbackHandlers("onResize",{
            def_cb: this.onResize
        }, this.size);
    }

    /**
     * add a new property to this node
     * @method addProperty
     * @param {string} name
     * @param {*} default_value
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
     */
    addProperty(name, default_value, type, extra_info) {
        default_value ??= null;
        type ??= null;
        const o = { name, type, default_value, ...extra_info };
        this.properties_info = this.properties_info ?? [];
        this.properties_info.push(o);

        this.properties = this.properties ?? {};
        this.properties[name] = default_value;

        return o;
    }

    /**
     * Add a new input or output slot to use in this node.
     * @param {string} name - Name of the slot.
     * @param {string} type - Type of the slot ("vec3", "number", etc). For a generic type, use "0".
     * @param {Object} extra_info - Additional information for the slot (e.g., label, color, position).
     * @param {boolean} isInput - Whether the slot being added is an input slot.
     * @returns {Object} The newly added slot (input or output).
     *
     * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,
     * but our goal here is to refactor them so they *aren't* slightly different.
     */
    addInput(name, type, extra_info) {
        return this.addSlot(name, type, extra_info, true);
    }
    addOutput(name, type, extra_info) {
        return this.addSlot(name, type, extra_info, false);
    }
    addSlot(name, type, extra_info, isInput) {
        const slot = isInput ?
            { name, type, link: null, ...extra_info }:
            { name, type, links: null, ...extra_info };
        if (isInput) {
            this.inputs = this.inputs ?? [];
            this.inputs.push(slot);
            this.processCallbackHandlers("onInputAdded",{
                def_cb: this.onInputAdded
            }, slot);
            LiteGraph.registerNodeAndSlotType(this, type);
        } else {
            this.outputs = this.outputs ?? [];
            this.outputs.push(slot);
            this.processCallbackHandlers("onOutputAdded",{
                def_cb: this.onOutputAdded
            }, slot);
            if (LiteGraph.auto_load_slot_types) {
                LiteGraph.registerNodeAndSlotType(this, type, true);
            }
        }

        this.autoSize(true);
        this.setDirtyCanvas(true, true);
        return slot;
    }

    /**
     * Add multiple input or output slots to use in this node.
     * @param {Array} array - Array of triplets like [[name, type, extra_info], [...]].
     * @param {boolean} isInput - Whether the slots being added are input slots.
     *
     * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,
     * but our goal here is to refactor them so they *aren't* slightly different.
     */
    addInputs(array) {
        this.addSlots(array, true);
    }
    addOutputs(array) {
        this.addSlots(array, false);
    }
    addSlots(array, isInput) {
        if(typeof array === 'string')
            array = [array];

        array.forEach((info) => {
            const slot = isInput ? {
                name: info[0],
                type: info[1],
                link: null,
                ...(info[2] ?? {}),
            } : {
                name: info[0],
                type: info[1],
                links: null,
                ...(info[2] ?? {}),
            };

            if (isInput) {
                this.inputs = this.inputs ?? [];
                this.inputs.push(slot);
                this.processCallbackHandlers("onInputAdded",{
                    def_cb: this.onInputAdded
                }, slot);
                LiteGraph.registerNodeAndSlotType(this, info[1]);
            } else {
                this.outputs = this.outputs ?? [];
                this.outputs.push(slot);
                this.processCallbackHandlers("onOutputAdded",{
                    def_cb: this.onOutputAdded
                }, slot);
                if (LiteGraph.auto_load_slot_types) {
                    LiteGraph.registerNodeAndSlotType(this, info[1], true);
                }
            }
        });

        this.autoSize();
        this.setDirtyCanvas(true, true);
    }

    /**
     * remove an existing input slot
     * @method removeInput
     * @param {number} slot
     *
     * @NOTE: These two are different enough yet I can't even mash them together meaningfully.
     */
    removeInput(slot) {
        this.disconnectInput(slot);
        const removedInput = this.inputs.splice(slot, 1)[0];

        this.inputs.slice(slot).filter((input) => !!input).forEach((input) => {
            const link = this.graph.links[input.link];
            link?.target_slot && link.target_slot--;
        });

        this.autoSize();
        this.processCallbackHandlers("onInputRemoved",{
            def_cb: this.onInputRemoved
        }, slot, removedInput);
        this.setDirtyCanvas(true, true);
    }

    /**
     * remove an existing output slot
     * @method removeOutput
     * @param {number} slot
     */
    removeOutput(slot) {
        this.disconnectOutput(slot);
        this.outputs = this.outputs.filter((_, index) => index !== slot);

        this.outputs.slice(slot).forEach((output) => {
            if (!output || !output.links) {
                return;
            }
            output.links.forEach((linkId) => {
                const link = this.graph.links[linkId];
                if (link) {
                    link.origin_slot -= 1;
                }
            });
        });

        this.autoSize();
        this.processCallbackHandlers("onOutputRemoved",{
            def_cb: this.onOutputRemoved
        }, slot);
        this.setDirtyCanvas(true, true);
    }

    /**
     * Add a special connection to this node (used for special kinds of graphs)
     * @method addConnection
     * @param {string} name - The name of the connection
     * @param {string} type - String defining the input type ("vec3", "number", etc.)
     * @param {Float32[]} pos - Position of the connection inside the node as an array [x, y]
     * @param {string} direction - Specifies if it is an input or output connection
     */
    addConnection(name, type, pos, direction) {
        var o = {
            name: name,
            type: type,
            pos: pos,
            direction: direction,
            links: null,
        };
        this.connections.push(o);
        return o;
    }

    getDefaultCanvas(){
        if(!this.graph) return false;
        if(!this.graph.list_of_graphcanvas || !this.graph.list_of_graphcanvas.length) return false;
        return this.graph.list_of_graphcanvas[0];
    }

    /**
     * computes the minimum size of a node according to its inputs and output slots
     * @method computeSize
     * @param {vec2} minHeight
     * @return {vec2} the total size
     */
    computeSize(out) {
        if (this.constructor.size) {
            return this.constructor.size.concat();
        }

        var node = this;
        var size = out || new Float32Array([0, 0]);

        var font_size = LiteGraph.NODE_TEXT_SIZE; // although it should be graphcanvas.inner_text_font size

        // computeWidth
        const get_text_width = (text, isTitle) => {
            if (!text) {
                return 0;
            }
            const lgcanvas = node.getDefaultCanvas();
            if(lgcanvas && lgcanvas.canvas && lgcanvas.ctx){
                if(isTitle){
                    lgcanvas.ctx.font = lgcanvas.title_text_font;
                }else{
                    lgcanvas.ctx.font = lgcanvas.inner_text_font;
                }
                const measuredT = lgcanvas.ctx?.measureText(text);
                if(measuredT){
                    // DBG EXCESS LiteGraph.log_verbose("lgraphnode","computeSize","measured text",text,measuredT,this);
                    return measuredT.width;
                }
            }
            // fallback
            // DBG EXCESS LiteGraph.log_verbose("lgraphnode","computeSize","fallback size",text,font_size * text.length * 0.6,this);
            return font_size * text.length * 0.423; // TODO this is not precise
        };
        var node_title = node.title;
        try{
            node_title = this.getTitle();
        }catch(e){
            // skip :: being in construction properties could not be set yet
        }
        var title_width = 40 + get_text_width(node_title, true); // this.title
        var input_width = 0;
        var output_width = 0;

        if (this.inputs) {
            input_width = this.inputs.reduce((maxWidth, input) => {
                const text = input.label || input.name || "";
                const text_width = get_text_width(text);
                return Math.max(maxWidth, text_width);
            }, 0);
        }
        if (this.outputs) {
            output_width = this.outputs.reduce((maxWidth, output) => {
                const text = output.label || output.name || "";
                const text_width = get_text_width(text);
                return Math.max(maxWidth, text_width);
            }, 0);
        }

        if(this.horizontal){
            // const lastIPos = this.getConnectionPos();
            size[0] = Math.max(size[0], title_width);
            size[1] = this.outputs.length ? Math.max(size[1], LiteGraph.NODE_SLOT_HEIGHT + 10) : size[1];
        }else{
            // basicWidth
            size[0] = Math.max(input_width + output_width + 40 + 10, title_width);
            // basicHeight
            size[1] = this.getSlotsHeight();
        }
        
        // min Width Height
        size[0] = Math.max(size[0], LiteGraph.NODE_MIN_WIDTH);
        size[0] = Math.max(size[0], LiteGraph.NODE_MIN_SIZE[0]);
        size[1] = Math.max(size[1], LiteGraph.NODE_MIN_SIZE[1]);

        // widgets calc
        let widgetsHeight = 0;
        if (this.widgets && this.widgets.length) {
            // width fallback
            size[0] = Math.max(size[0], LiteGraph.NODE_MIN_WIDTH * 1.5);
            // cycle widgets
            for (var i = 0, l = this.widgets.length; i < l; ++i) {
                if (this.widgets[i].computeSize){
                    const wSize = this.widgets[i].computeSize(size[0]);
                    widgetsHeight += wSize[1] + 4;
                    size[0] = Math.max(size[0], wSize[0]);
                }else{
                    widgetsHeight += LiteGraph.NODE_WIDGET_HEIGHT + 4;
                    size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH); // using node width as widget default WIDHT TODO refcator
                }
            }
            widgetsHeight += 8;
        }

        // process height
        if( this.widgets_up ){
            size[1] = Math.max( size[1], widgetsHeight );
        }else if( this.widgets_start_y != null ){
            size[1] = Math.max( size[1], widgetsHeight + this.widgets_start_y );
        }else{
            size[1] += widgetsHeight;
        }
        if (this.constructor.min_height) {
            size[1] = Math.max( size[1], this.constructor.min_height);
        }

        // size[1] += 6; // y margin
        return size;
    }

    getSlotsHeight(){
        // minimum height calculated by slots or 1
        const rowHeight = Math.max(
            this.inputs ? this.inputs.length : 1,
            this.outputs ? this.outputs.length : 1,
            1,
        ) * LiteGraph.NODE_SLOT_HEIGHT + 10;
        // add margin (should this be always?)
        return rowHeight + (this.constructor.slot_start_y || 0);
    }

    /**
     * returns all the info available about a property of this node.
     *
     * @method getPropertyInfo
     * @param {String} property name of the property
     * @return {Object} the object with all the available info
    */
    getPropertyInfo(property) {
        var info = null;

        // there are several ways to define info about a property
        // legacy mode
        if (this.properties_info) {
            for (var i = 0; i < this.properties_info.length; ++i) {
                if (this.properties_info[i].name == property) {
                    info = this.properties_info[i];
                    break;
                }
            }
        }
        // litescene mode using the constructor
        if(this.constructor[`@${property}`]){
            info = this.constructor[`@${property}`];
        }

        if(this.constructor.widgets_info && this.constructor.widgets_info[property]){
            info = this.constructor.widgets_info[property];
        }

        // litescene mode using the constructor
        if (!info) {
            // info = this.onGetPropertyInfo(property);
            let r = this.processCallbackHandlers("onGetPropertyInfo",{
                def_cb: this.onGetPropertyInfo
            }, property);
            if(r!==null && typeof(r)=="object" && r.return_value!==null){
                info = r.return_value;
            }
        }

        // DISABLED: REFACTOR code will use info.type or info. even if not valid
        // if still has no info, that's a "property does not exists and nobody is managing it"
        // if (info === null || typeof(info) == "undefined"){
            // return null;
        // }

        if (!info){
            info = {};
        }
        if(!info.type){
            info.type = typeof this.properties[property];
        }
        /* if(!info.property){
            info.property = property;
        } */
        if(info.widget == "combo"){
            info.type = "enum";
        }

        return info;
    }

    /**
     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
     *
     * @method addWidget
     * @param {String} type the widget type (could be "number","string","combo"
     * @param {String} name the text to show on the widget
     * @param {String} value the default value
     * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
     * @param {Object} options the object that contains special properties of this widget
     * @return {Object} the created widget object
     */
    addWidget(type, name, value, callback, options) {
        this.widgets ??= [];

        if(!options && callback && callback.constructor === Object) {
            options = callback;
            callback = null;
        }

        if(options && options.constructor === String) // options can be the property name
            options = { property: options };

        if(callback && callback.constructor === String) { // callback can be the property name
            options ??= {};
            options.property = callback;
            callback = null;
        }

        if(callback && callback.constructor !== Function) {
            LiteGraph.log_warn("lgraphnode", "addWidget", "callback must be a function", callback);
            callback = null;
        }

        var w = {
            type: type.toLowerCase(),
            name: name,
            value: value,
            callback: callback,
            options: options || {},
        };

        if (w.options.y !== undefined) {
            w.y = w.options.y;
        }

        if (!callback && !w.options.callback && !w.options.property) {
            
        }
        if (type == "combo" && !w.options.values) {
            // throw Error("LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }");
            LiteGraph.log_warn("lgraphnode", "addWidget", "combo requires to pass values in options eg: { values:['red','blue'] }");
            return;
        }
        this.widgets.push(w);
        this.setSize( this.computeSize() );
        return w;
    }

    addCustomWidget(custom_widget) {
        this.widgets ??= [];
        this.widgets.push(custom_widget);
        return custom_widget;
    }

    /**
     * Returns the bounding box of the object, used for rendering purposes
     * @method getBounding
     * @param {Float32[]} [out] - [Optional] A place to store the output to reduce garbage
     * @param {boolean} [compute_outer] - [Optional] Set to true to include the shadow and connection points in the bounding calculation
     * @return {Float32[]} The bounding box in the format of [topLeftCornerX, topLeftCornerY, width, height]
     */
    getBounding(out = new Float32Array(4), compute_outer) {
        const nodePos = this.pos;
        const isCollapsed = this.flags?.collapsed;
        const nodeSize = this.size;

        let left_offset = 0;
        // 1 offset due to how nodes are rendered
        let right_offset = 1 ;
        let top_offset = 0;
        let bottom_offset = 0;

        if (compute_outer) {
            // 4 offset for collapsed node connection points
            left_offset = 4;
            // 6 offset for right shadow and collapsed node connection points
            right_offset = 6 + left_offset;
            // 4 offset for collapsed nodes top connection points
            top_offset = 4;
            // 5 offset for bottom shadow and collapsed node connection points
            bottom_offset = 5 + top_offset;
        }

        out[0] = nodePos[0] - left_offset;
        out[1] = nodePos[1] - LiteGraph.NODE_TITLE_HEIGHT - top_offset;
        out[2] = isCollapsed ?
            (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + right_offset :
            nodeSize[0] + right_offset;
        out[3] = isCollapsed ?
            LiteGraph.NODE_TITLE_HEIGHT + bottom_offset :
            nodeSize[1] + LiteGraph.NODE_TITLE_HEIGHT + bottom_offset;

        this.processCallbackHandlers("onBounding",{
            def_cb: this.onBounding
        }, out)
        // TAG this callback could return behavior
        return out;
    }

    /**
     * checks if a point is inside the shape of a node
     * @method isPointInside
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    isPointInside(x, y, margin = 0, skip_title) {
        var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
        if (skip_title) {
            margin_top = 0;
        }
        if (this.flags && this.flags.collapsed) {
            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] + this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)
            if (
                LiteGraph.isInsideRectangle(
                    x,
                    y,
                    this.pos[0] - margin,
                    this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,
                    (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) +
                        2 * margin,
                    LiteGraph.NODE_TITLE_HEIGHT + 2 * margin,
                )
            ) {
                return true;
            }
        } else if (
            this.pos[0] - 4 - margin < x &&
            this.pos[0] + this.size[0] + 4 + margin > x &&
            this.pos[1] - margin_top - margin < y &&
            this.pos[1] + this.size[1] + margin > y
        ) {
            return true;
        }
        return false;
    }

    /**
     * checks if a point is inside a node slot, and returns info about which slot
     * @method getSlotInPosition
     * @param {number} x
     * @param {number} y
     * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
     */
    getSlotInPosition(x, y) {
        // search for inputs
        var link_pos = new Float32Array(2);
        if (this.inputs) {
            for (let i = 0, l = this.inputs.length; i < l; ++i) {
                let input = this.inputs[i];
                this.getConnectionPos(true, i, link_pos);
                if (
                    LiteGraph.isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10,
                    )
                ) {
                    return { input: input, slot: i, link_pos: link_pos };
                }
            }
        }

        if (this.outputs) {
            for (let i = 0, l = this.outputs.length; i < l; ++i) {
                let output = this.outputs[i];
                this.getConnectionPos(false, i, link_pos);
                if (
                    LiteGraph.isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10,
                    )
                ) {
                    return { output: output, slot: i, link_pos: link_pos };
                }
            }
        }

        return null;
    }

    /**
     * returns the input slot with a given name (used for dynamic slots), -1 if not found
     * @method findInputSlot
     * @param {string} name the name of the slot
     * @param {boolean} returnObj if the obj itself wanted
     * @return {number|object} the slot (-1 if not found)
     */
    findInputSlot(name, returnObj) {
        if (!this.inputs) {
            return -1;
        }
        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            if (name == this.inputs[i].name) {
                return !returnObj ? i : this.inputs[i];
            }
        }
        return -1;
    }

    /**
     * returns the output slot with a given name (used for dynamic slots), -1 if not found
     * @method findOutputSlot
     * @param {string} name the name of the slot
     * @param {boolean} returnObj if the obj itself wanted
     * @return {number|object} the slot (-1 if not found)
     */
    findOutputSlot(name, returnObj = false) {
        if (!this.outputs) {
            return -1;
        }
        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            if (name == this.outputs[i].name) {
                return !returnObj ? i : this.outputs[i];
            }
        }
        return -1;
    }

    /**
     * Get a slot from his index or name
     * @param {boolean} is_input use look for input / output 
     * @param {number|string} slot_index_or_name 
     * @returns 
     */
    getSlot(is_input, slot_index_or_name, returnObj = false){
        if(!is_input || is_input===LiteGraph.OUTPUT){
            if(this.outputs[slot_index_or_name]!=="undefined"){
                return !returnObj ? slot_index_or_name : this.outputs[slot_index_or_name];
            }else{
                return this.findInputSlot(slot_index_or_name, returnObj);
            }
        }else{
            if(this.inputs[slot_index_or_name]!=="undefined"){
                return !returnObj ? slot_index_or_name : this.inputs[slot_index_or_name];
            }else{
                return this.findOutputSlot(slot_index_or_name, returnObj);
            }
        }
    }
    getOutputSlot(index_or_name, returnObj = false){
        return this.getSlot(false, index_or_name, returnObj);
    }
    getInputSlot(index_or_name, returnObj = false){
        return this.getSlot(true, index_or_name, returnObj);
    }

    // TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options

    /**
     * returns the first free input slot, can filter by types
     * @method findInputSlotFree
     * @param {object} options
     * @return {number|object} the slot (-1 if not found)
     */
    findInputSlotFree(optsIn = {}) {
        var optsDef = {
            returnObj: false,
            typesNotAccepted: [],
        };
        var opts = Object.assign(optsDef,optsIn);
        if (!this.inputs) {
            return -1;
        }
        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            if (this.inputs[i].link && this.inputs[i].link != null) {
                continue;
            }
            if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i].type)) {
                continue;
            }
            return !opts.returnObj ? i : this.inputs[i];
        }
        return -1;
    }

    /**
     * returns the first output slot free, can filter by types
     * @method findOutputSlotFree
     * @param {object} options
     * @return {number|object} the slot (-1 if not found)
     */
    findOutputSlotFree(optsIn = {}) {
        var optsDef = {
            returnObj: false,
            typesNotAccepted: [],
        };
        var opts = Object.assign(optsDef,optsIn);
        if (!this.outputs) {
            return -1;
        }
        for (let i = 0, l = this.outputs.length; i < l; ++i) {
            if (this.outputs[i].links && this.outputs[i].links != null) {
                continue;
            }
            if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i].type)) {
                continue;
            }
            return !opts.returnObj ? i : this.outputs[i];
        }
        return -1;
    }

    /**
     * findSlotByType for INPUTS
     */
    findInputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
        return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);
    }

    /**
     * findSlotByType for OUTPUTS
     */
    findOutputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
        return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);
    }

    /**
     * returns the output (or input) slot with a given type, -1 if not found
     * @method findSlotByType
     * @param {boolean} is_input use inputs (true), or outputs (false)
     * @param {string} type the type of the slot to look for (multi type by ,) 
     * @param {boolean} returnObj if the obj itself wanted
     * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)
     * @return {number|object} the slot (-1 if not found)
     */
    findSlotByType(
        is_input = false,
        type,
        returnObj = false,
        preferFreeSlot = false,
        doNotUseOccupied = false,
    ) {
        var aSlots = is_input ? this.inputs : this.outputs;
        if (!aSlots) {
            return -1;
        }
        // !! empty string type is considered 0, * !!
        if (!type || type == "" || type == "*") type = 0;
        // cycle for this slots
        for (let i = 0, l = aSlots.length; i < l; ++i) {
            let aSource = (type+"").toLowerCase().split(",");
            let aDest = aSlots[i].type=="0" || aSlots[i].type=="*"
                            ? 0
                            : aSlots[i].type;
            aDest = (aDest+"").toLowerCase().split(",");
            // cycle for the slot types
            for(let sI=0;sI<aSource.length;sI++) {
                for(let dI=0;dI<aDest.length;dI++) {
                    if (aSource[sI]=="_event_") aSource[sI] = LiteGraph.EVENT;
                    if (aDest[sI]=="_event_") aDest[sI] = LiteGraph.EVENT;
                    if (aSource[sI]=="*") aSource[sI] = 0;
                    if (aDest[sI]=="*") aDest[sI] = 0;
                    if (aSource[sI] == aDest[dI]) {
                        if (preferFreeSlot
                            && (
                                (aSlots[i].link && aSlots[i].link !== null)
                                || (aSlots[i].links && aSlots[i].links !== null)
                            )
                        ){
                            LiteGraph.log_verbose("lgraphnode","findSlotByType","preferFreeSlot but has link",aSource[sI],aDest[dI],"from types",type,"checked types",aSlots[i].type);
                            continue;
                        }
                        LiteGraph.log_verbose("lgraphnode","findSlotByType","found right type",i,aSlots[i],"from types",type,"checked types",aSlots[i].type);
                        return !returnObj ? i : aSlots[i];
                    }else{
                        LiteGraph.log_verbose("lgraphnode","findSlotByType","slot not right type",aSource[sI],aDest[dI],"from types",type,"checked types",aSlots[i].type);
                    }
                }
            }
        }
        // if didnt find some, checking if need to force on already placed ones
        if (preferFreeSlot && !doNotUseOccupied) {
            for (let i = 0, l = aSlots.length; i < l; ++i) {
                let aSource = (type+"").toLowerCase().split(",");
                let aDest = aSlots[i].type=="0"||aSlots[i].type=="*"?"0":aSlots[i].type;
                aDest = (aDest+"").toLowerCase().split(",");
                for(let sI=0;sI<aSource.length;sI++) {
                    for(let dI=0;dI<aDest.length;dI++) {
                        if (aSource[sI]=="*") aSource[sI] = 0;
                        if (aDest[sI]=="*") aDest[sI] = 0;
                        if (aSource[sI] == aDest[dI]) {
                            return !returnObj ? i : aSlots[i];
                        }
                    }
                }
            }
        }
        return -1;
    }

    /**
     * connect this node output to the input of another node BY TYPE
     * @method connectByType
     * @param {number|string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} node the target node
     * @param {string} target_type the input slot type of the target node
     * @return {Object} the link_info is created, otherwise null
     */
    connectByType(slot, target_node, target_slotType = "*", optsIn = {}) {
        var optsDef = {
            createEventInCase: true,
            firstFreeIfOutputGeneralInCase: true,
            generalTypeInCase: true,
            preferFreeSlot: false,
        };
        var opts = Object.assign(optsDef,optsIn);
        if (target_node && target_node.constructor === Number) {
            target_node = this.graph.getNodeById(target_node);
        }
        // look for free slots
        var target_slot = target_node.findInputSlotByType(target_slotType, false, true);
        if (target_slot >= 0 && target_slot !== null) {
            LiteGraph.log_debug("lgraphnode","connectByType","type "+target_slotType+" for "+target_slot)
            return this.connect(slot, target_node, target_slot);
        }else{
            // LiteGraph.log?.("type "+target_slotType+" not found or not free?")
            if (opts.createEventInCase && target_slotType == LiteGraph.EVENT) {
                // WILL CREATE THE onTrigger IN SLOT
                LiteGraph.log_debug("lgraphnode","connectByType","connect WILL CREATE THE onTrigger "+target_slotType+" to "+target_node);
                return this.connect(slot, target_node, -1);
            }
            // connect to the first general output slot if not found a specific type and
            if (opts.generalTypeInCase) {
                target_slot = target_node.findInputSlotByType(0, false, true, true);
                LiteGraph.log_debug("lgraphnode","connectByType","connect TO a general type (*, 0), if not found the specific type ",target_slotType," to ",target_node,"RES_SLOT:",target_slot);
                if (target_slot >= 0) {
                    return this.connect(slot, target_node, target_slot);
                }
            }
            // connect to the first free input slot if not found a specific type and this output is general
            if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == "*" || target_slotType == "")) {
                target_slot = target_node.findInputSlotFree({typesNotAccepted: [LiteGraph.EVENT] });
                LiteGraph.log_debug("lgraphnode","connectByType","connect TO TheFirstFREE ",target_slotType," to ",target_node,"RES_SLOT:",target_slot);
                if (target_slot >= 0) {
                    return this.connect(slot, target_node, target_slot);
                }
            }
            LiteGraph.log_debug("lgraphnode","connectByType","no way to connect type: ",target_slotType," to targetNODE ",target_node);
            // TODO filter

            return null;
        }
    }

    /**
     * connect this node input to the output of another node BY TYPE
     * @method connectByType
     * @param {number|string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} node the target node
     * @param {string} target_type the output slot type of the target node
     * @return {Object} the link_info is created, otherwise null
     */
    connectByTypeOutput(slot, source_node, source_slotType = "*", optsIn = {}) {
        var optsDef = {
            createEventInCase: true,
            firstFreeIfInputGeneralInCase: true,
            generalTypeInCase: true,
        };
        var opts = Object.assign(optsDef,optsIn);
        if (source_node && source_node.constructor === Number) {
            source_node = this.graph.getNodeById(source_node);
        }
        var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);
        if (source_slot >= 0 && source_slot !== null) {
            LiteGraph.log_debug("lgraphnode","connectByTypeOutput","type "+source_slotType+" for "+source_slot)
            return source_node.connect(source_slot, this, slot);
        }else{

            // connect to the first general output slot if not found a specific type and
            if (opts.generalTypeInCase) {
                source_slot = source_node.findOutputSlotByType(0, false, true, true);
                if (source_slot >= 0) {
                    return source_node.connect(source_slot, this, slot);
                }
            }

            if (opts.createEventInCase && source_slotType == LiteGraph.EVENT) {
                // WILL CREATE THE onExecuted OUT SLOT
                if (LiteGraph.do_add_triggers_slots) {
                    source_slot = source_node.addOnExecutedOutput();
                    return source_node.connect(source_slot, this, slot);
                }
            }
            // connect to the first free output slot if not found a specific type and this input is general
            if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == "*" || source_slotType == "" || source_slotType == "undefined")) {
                source_slot = source_node.findOutputSlotFree({typesNotAccepted: [LiteGraph.EVENT] });
                if (source_slot >= 0) {
                    return source_node.connect(source_slot, this, slot);
                }
            }

            LiteGraph.log_debug("lgraphnode","connectByTypeOutput","no way to connect (not found or not free?) byOUT type: ",source_slotType," to sourceNODE ",source_node);
            // TODO filter

            return null;
        }
    }

    /**
     * connect this node output to the input of another node
     * @method connect
     * @param {number|string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} node the target node
     * @param {number|string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
     * @return {Object} the link_info is created, otherwise null
     */
    connect(slot, target_node, target_slot = 0) {
        if (!this.graph) {
            // could be connected before adding it to a graph
            LiteGraph.log_warn("lgraphnode","connect", "Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.", this); // due to link ids being associated with graphs
            return null;
        }

        let r = null;

        // seek for the output slot
        /* if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                LiteGraph.log_warn("lgraphnode","connect", "Error, string slot not found",this,slot);
                return null;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            LiteGraph.log_warn("lgraphnode","connect", "Error, number slot not found",this,slot);
            return null;
        } */
        slot = this.getOutputSlot(slot);
        if(slot == -1){
            LiteGraph.log_warn("lgraphnode","connect", "Slot not found",this,slot);
            return null;
        }

        if (target_node && target_node.constructor === Number) { // check this ? Number constructor falling back to ID ?
            LiteGraph.log_debug("lgraphnode","connect", "Target node constructor is number",target_node);
            target_node = this.graph.getNodeById(target_node);
            LiteGraph.log_debug("lgraphnode","connect", "Target node number constructor, looked for node by ID",target_node);
        }
        if (!target_node) {
            // throw new Error("target node is null");
            LiteGraph.log_warn("lgraphnode","connect", "Target node null",target_node);
            return;
        }

        // avoid loopback
        if (target_node == this) {
            return null;
        }

        if (target_slot === LiteGraph.EVENT) {

            if (LiteGraph.do_add_triggers_slots) {
                // search for first slot with event? :: NO this is done outside
                // LiteGraph.log?.("Connect: Creating triggerEvent");
                // force mode
                target_node.changeMode(LiteGraph.ON_TRIGGER);
                target_slot = target_node.findInputSlot("onTrigger");
                LiteGraph.log_debug("lgraphnode","connect", "Created onTrigger slot",target_slot);
            }else{
                return null; // -- break --
            }

        }else{
            target_slot = target_node.getInputSlot(target_slot);
        }

        // you can specify the slot by name
        /* if (target_slot.constructor === String) {
            target_slot = target_node.findInputSlot(target_slot);
            if (target_slot == -1) {
                LiteGraph.log_warn("lgraphnode","connect", "Target string slot not found",target_slot);
                return null;
            }
        } else */
        
        if (
            !target_node.inputs || target_slot == -1
            // target_slot >= target_node.inputs.length
        ) {
            LiteGraph.log_warn("lgraphnode","connect", "Target slot not found",target_slot,target_node.inputs);
            return null;
        }

        var changed = false;

        var input = target_node.inputs[target_slot];
        var link_info = null;
        var output = this.outputs[slot];

        if (!this.outputs[slot]) {
            LiteGraph.log_warn("lgraphnode","connect", "Invalid processed output slot: ",slot,this.outputs);
            return null;
        }

        // callback ,allow the node to change target slot
        r = target_node.processCallbackHandlers("onBeforeConnectInput",{
            def_cb: target_node.onBeforeConnectInput
        }, target_node);
        if(r!==null && (typeof(r)=="object" && r.return_value!==null)){
            LiteGraph.log_debug("lgraphnode","connect", "Node onBeforeConnectInput changing target_slot",target_slot,r.return_value);
            target_slot = r.return_value;
        }

        // callback, allow the node to stop connection
        r = this.processCallbackHandlers("onConnectOutput",{
            def_cb: this.onConnectOutput
        }, slot, input.type, input, target_node, target_slot);
        if(r!==null && (r===false || (typeof(r)=="object" && r.return_value===false))){
            LiteGraph.log_debug("lgraphnode","connect", "Node onConnectOutput stopping connection",r.return_value);
            return null;
        }

        // check target_slot and check connection types
        if (target_slot===false || target_slot===null || !LiteGraph.isValidConnection(output.type, input.type)) {
            LiteGraph.log_warn("lgraphnode", "connect", "target_slot is NOT valid",target_slot,output.type,input.type);
            this.setDirtyCanvas(false, true);
            if(changed)
                this.graph.connectionChange(this, link_info);
            return null;
        } else {
            LiteGraph.log_debug("lgraphnode", "connect", "target_slot is valid",target_slot);
        }

        // callback, allow the target node to stop connection
        r = target_node.processCallbackHandlers("onConnectInput",{
            def_cb: target_node.onConnectInput
        }, target_slot, output.type, output, this, slot);
        if(r!==null && (r===false || (typeof(r)=="object" && r.return_value===false))){
            LiteGraph.log_debug("lgraphnode","connect", "targetNode onConnectInput stopping connection",r.return_value);
            return null;
        }
        // check :: was already called just few steps here above
        // if ( this.onConnectOutput?.(slot, input.type, input, target_node, target_slot) === false ) {
        //     return null;
        // }

        // if there is something already plugged there, disconnect
        if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {
            this.graph.beforeChange();
            target_node.disconnectInput(target_slot, {doProcessChange: false});
            changed = true;
        }
        if (output.links?.length) {
            switch(output.type) {
                case LiteGraph.EVENT:
                    if (!LiteGraph.allow_multi_output_for_events) {
                        this.graph.beforeChange();
                        this.disconnectOutput(slot, false, {doProcessChange: false}); // Input(target_slot, {doProcessChange: false});
                        changed = true;
                    }
                    break;
                default:
                    break;
            }
        }

        var nextId
        if (LiteGraph.use_uuids)
            nextId = LiteGraph.uuidv4();
        else
            nextId = ++this.graph.last_link_id;

        // create link class
        link_info = new LiteGraph.LLink(
            nextId,
            input.type || output.type,
            this.id,
            slot,
            target_node.id,
            target_slot,
        );

        // add to graph links list
        this.graph.links[link_info.id] = link_info;

        // connect in output
        if (output.links == null) {
            output.links = [];
        }
        output.links.push(link_info.id);
        // connect in input
        if(typeof target_node.inputs[target_slot] == "undefined") {
            LiteGraph.log_warn("lgraphnode", "connect", "FIXME error, target_slot does not exists on target_node",target_node,target_slot);
        }
        target_node.inputs[target_slot].link = link_info.id;

        this.processCallbackHandlers("onConnectionsChange",{
            def_cb: this.onConnectionsChange
        }, LiteGraph.OUTPUT, slot, true, link_info, output,);

        target_node.processCallbackHandlers("onConnectionsChange",{
            def_cb: target_node.onConnectionsChange
        }, LiteGraph.INPUT, target_slot, true, link_info, input,);

        if (this.graph) {

            this.graph.processCallbackHandlers("onNodeConnectionChange",{
                def_cb: this.graph.onNodeConnectionChange
            }, LiteGraph.INPUT, target_node, target_slot, this, slot,);
    
            this.graph.processCallbackHandlers("onNodeConnectionChange",{
                def_cb: this.graph.onNodeConnectionChange
            }, LiteGraph.OUTPUT, this, slot, target_node, target_slot,);

        }

        this.graph.onGraphChanged({action: "connect"});
        this.setDirtyCanvas(false, true);
        this.graph.afterChange();
        this.graph.connectionChange(this, link_info);

        return link_info;
    }

    /**
     * disconnect one output to an specific node
     * @method disconnectOutput
     * @param {number|string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
     * @return {boolean} if it was disconnected successfully
     */
    disconnectOutput(slot, target_node, optsIn = {}) {
        var optsDef = { doProcessChange: true };
        var opts = Object.assign(optsDef,optsIn);

        /* if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                LiteGraph.log_warn("lgraphnode","disconnectOutput","Error, string slot not found",slot);
                return false;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            LiteGraph.log_warn("lgraphnode","disconnectOutput","Error, number slot not found",slot);
            return false;
        } */
        slot = this.getOutputSlot(slot);

        // get output slot
        var output = this.outputs[slot];
        if (!output || !output.links || output.links.length == 0) {
            LiteGraph.log_warn("lgraphnode","disconnectOutput","Error, invalid slot or not linked",slot,output);
            return false;
        }

        // one of the output links in this slot
        if (target_node) {
            if (target_node.constructor === Number) { // check this ? Number constructor falling back to ID ?
                LiteGraph.log_debug("lgraphnode","disconnectOutput", "Target node constructor is number",target_node);
                target_node = this.graph.getNodeById(target_node);
                LiteGraph.log_debug("lgraphnode","disconnectOutput", "Target node number constructor, looked for node by ID",target_node);
            }
            if (!target_node) {
                LiteGraph.log_warn("lgraphnode","disconnectOutput","target node not found",target_node);
                return false;
            }

            for (let i = 0, l = output.links.length; i < l; i++) {
                let link_id = output.links[i];
                let link_info = this.graph.links[link_id];

                // is the link we are searching for...
                if (link_info.target_id == target_node.id) {
                    output.links.splice(i, 1); // remove here
                    var input = target_node.inputs[link_info.target_slot];
                    input.link = null; // remove there
                    delete this.graph.links[link_id]; // remove the link from the links pool
                    this.graph?.onGraphChanged({action: "disconnectOutput", doSave: opts.doProcessChange});
                    
                    // link_info hasn't been modified so its ok
                    
                    target_node.processCallbackHandlers("onConnectionsChange",{
                        def_cb: target_node.onConnectionsChange
                    }, LiteGraph.INPUT, link_info.target_slot, false, link_info, input,);

                    this.processCallbackHandlers("onConnectionsChange",{
                        def_cb: this.onConnectionsChange
                    }, LiteGraph.OUTPUT, slot, false, link_info, output,);
                    
                    if (this.graph) {
                
                        this.graph.processCallbackHandlers("onNodeConnectionChange",{
                            def_cb: this.graph.onNodeConnectionChange
                        }, LiteGraph.OUTPUT, this, slot, target_node, link_info.target_slot,);

                        this.graph.processCallbackHandlers("onNodeConnectionChange",{
                            def_cb: this.graph.onNodeConnectionChange
                        }, LiteGraph.INPUT, target_node, link_info.target_slot, this, slot,);

                    }
                    break;
                }
            }
        } else { // all the links in this output slot
            for (let i = 0, l = output.links.length; i < l; i++) {
                let link_id = output.links[i];
                let link_info = this.graph.links[link_id];
                if (!link_info) {
                    // bug: it happens sometimes
                    LiteGraph.log_warn("lgraphnode", "disconnectOutput", "A link is invalid", link_id, this, output);
                    continue;
                }

                target_node = this.graph.getNodeById(link_info.target_id);
                input = null;
                this.graph?.onGraphChanged({action: "disconnectOutput", doSave: opts.doProcessChange});
                if (target_node) {
                    input = target_node.inputs[link_info.target_slot];
                    input.link = null; // remove other side link
                    
                    target_node.processCallbackHandlers("onConnectionsChange",{
                        def_cb: target_node.onConnectionsChange
                    }, LiteGraph.INPUT, link_info.target_slot, false, link_info, input,);

                    this.graph.processCallbackHandlers("onNodeConnectionChange",{
                        def_cb: this.graph.onNodeConnectionChange
                    }, LiteGraph.INPUT, target_node, link_info.target_slot, this, );
                    
                }

                delete this.graph.links[link_id]; // remove the link from the links pool

                this.processCallbackHandlers("onConnectionsChange",{
                    def_cb: this.onConnectionsChange
                }, LiteGraph.OUTPUT, slot, false, link_info, output,);
                
                this.graph.processCallbackHandlers("onNodeConnectionChange",{
                    def_cb: this.graph.onNodeConnectionChange
                }, LiteGraph.OUTPUT, this, slot, target_node, link_info.target_slot,);

            }
            output.links = null;
        }

        this.setDirtyCanvas(false, true);
        this.graph.connectionChange(this);
        return true;
    }

    /**
     * disconnect one input
     * @method disconnectInput
     * @param {number|string} slot (could be the number of the slot or the string with the name of the slot)
     * @return {boolean} if it was disconnected successfully
     */
    disconnectInput(slot, optsIn = {}) {
        var optsDef = { doProcessChange: true };
        var opts = Object.assign(optsDef,optsIn);

        // seek for the output slot
        /* if (slot.constructor === String) {
            slot = this.findInputSlot(slot);
            if (slot == -1) {
                LiteGraph.log_warn("lgraphnode", "disconnectInput", "Error, string slot not found",slot);
                return false;
            }
        } else if (!this.inputs || slot >= this.inputs.length) {
            LiteGraph.log_warn("lgraphnode", "disconnectInput", "Error, number slot not found",slot);
            return false;
        } */
        slot = this.getInputSlot(slot);

        var input = this.inputs[slot];
        if (!input) {
            return false;
        }

        var link_id = this.inputs[slot].link;
        if(link_id != null) {
            this.inputs[slot].link = null;

            // remove other side
            var link_info = this.graph.links[link_id];
            if (link_info) {
                var target_node = this.graph.getNodeById(link_info.origin_id);
                if (!target_node) {
                    return false;
                }

                var output = target_node.outputs[link_info.origin_slot];
                if (!output || !output.links || output.links.length == 0) {
                    return false;
                }

                // search in the inputs list for this link
                for (var i = 0, l = output.links.length; i < l; i++) {
                    if (output.links[i] == link_id) {
                        output.links.splice(i, 1);
                        break;
                    }
                }

                delete this.graph.links[link_id]; // remove from the pool
                this.graph?.onGraphChanged({action: "disconnectInput", doSave: opts.doProcessChange});

                this.processCallbackHandlers("onConnectionsChange",{
                    def_cb: this.onConnectionsChange
                }, LiteGraph.INPUT, slot, false, link_info, input,);

                target_node.processCallbackHandlers("onConnectionsChange",{
                    def_cb: target_node.onConnectionsChange
                }, LiteGraph.OUTPUT, i, false, link_info, output,);

                if (this.graph) {
                    this.graph.processCallbackHandlers("onNodeConnectionChange",{
                        def_cb: this.graph.onNodeConnectionChange
                    }, LiteGraph.OUTPUT, target_node, i,);
                    this.graph.processCallbackHandlers("onNodeConnectionChange",{
                        def_cb: this.graph.onNodeConnectionChange
                    }, LiteGraph.INPUT, this, slot,);
                }
            }
        } // link != null

        this.setDirtyCanvas(false, true);
        if(this.graph)
            this.graph.connectionChange(this);
        return true;
    }

    /**
     * Returns the center of a connection point in canvas coordinates
     * @method getConnectionPos
     * @param {boolean} is_input - True if it is an input slot, false if it is an output slot
     * @param {number | string} slot - Could be the number of the slot or the string with the name of the slot
     * @param {vec2} [out] - [Optional] A place to store the output to reduce garbage
     * @return {Float32[]} The position as [x, y]
     */
    getConnectionPos(is_input, slot_number, out = new Float32Array(2)) {
        var num_slots = 0;
        if (is_input && this.inputs) {
            num_slots = this.inputs.length;
        }
        if (!is_input && this.outputs) {
            num_slots = this.outputs.length;
        }

        var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;

        if (this.flags.collapsed) {
            var w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
            if (this.horizontal) {
                out[0] = this.pos[0] + w * 0.5;
                if (is_input) {
                    out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
                } else {
                    out[1] = this.pos[1];
                }
            } else {
                if (is_input) {
                    out[0] = this.pos[0];
                } else {
                    out[0] = this.pos[0] + w;
                }
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            }
            return out;
        }

        // if not specifing a slot fallback to title center, similar to collapsed
        if (is_input && slot_number == -1) {
            LiteGraph.log_debug("lgraphnode", "getConnectionPos", "asking for connection slot -1");
            out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            return out;
        }

        // hard-coded pos
        if (
            is_input &&
            num_slots > slot_number &&
            this.inputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
            return out;
        } else if (
            !is_input &&
            num_slots > slot_number &&
            this.outputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
            return out;
        }

        // horizontal distributed slots
        if (this.horizontal) {
            out[0] =
                this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
            if (is_input) {
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
            } else {
                out[1] = this.pos[1] + this.size[1];
            }
            return out;
        }

        // default vertical slots
        if (is_input) {
            out[0] = this.pos[0] + offset;
        } else {
            out[0] = this.pos[0] + this.size[0] + 1 - offset;
        }
        out[1] =
            this.pos[1] +
            (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +
            (this.constructor.slot_start_y || 0);
        return out;
    }

    /* Force align to grid */
    alignToGrid() {
        this.pos[0] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
        this.pos[1] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
    }

    /* Console output */
    trace(msg) {
        if (!this.console) {
            this.console = [];
        }

        this.console.push?.(msg);
        if (this.console.length > LGraphNode.MAX_CONSOLE) {
            this.console.shift?.();
        }

        this.graph.processCallbackHandlers("onNodeTrace",{
            def_cb: this.graph.onNodeTrace
        }, this, msg);
    }

    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
    setDirtyCanvas(dirty_foreground, dirty_background) {
        if (!this.graph) {
            return;
        }
        this.graph.sendActionToCanvas("setDirty", [
            dirty_foreground,
            dirty_background,
        ]);
    }

    loadImage(url) {
        var img = new Image();
        img.src = LiteGraph.node_images_path + url;
        img.ready = false;

        var that = this;
        img.onload = function() {
            this.ready = true;
            that.setDirtyCanvas(true);
        };
        return img;
    }

    // safe LGraphNode action execution (not sure if safe)
    /*
    LGraphNode.prototype.executeAction = function(action)
    {
    if(action == "") return false;

    if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
    {
        this.trace("Error: Action contains unsafe characters");
        return false;
    }

    var tokens = action.split("(");
    var func_name = tokens[0];
    if( typeof(this[func_name]) != "function")
    {
        this.trace("Error: Action not found on node: " + func_name);
        return false;
    }

    var code = action;

    try
    {
        var _foo = eval;
        eval = null;
        (new Function("with(this) { " + code + "}")).call(this);
        eval = _foo;
    }
    catch (err)
    {
        this.trace("Error executing action {" + action + "} :" + err);
        return false;
    }

    return true;
    }
    */

    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
    captureInput(v) {
        if (!this.graph || !this.graph.list_of_graphcanvas) {
            return;
        }

        var list = this.graph.list_of_graphcanvas;

        for (var i = 0; i < list.length; ++i) {
            var c = list[i];
            // releasing somebody elses capture?!
            if (!v && c.node_capturing_input != this) {
                continue;
            }

            // change
            c.node_capturing_input = v ? this : null;
        }
    }

    /**
     * Collapse the node to make it smaller on the canvas
     * @method collapse
     **/
    collapse(force) {
        this.graph.onGraphChanged({action: "collapse"});
        if (this.constructor.collapsable === false && !force) {
            return;
        }
        if (!this.flags.collapsed) {
            this.flags.collapsed = true;
        } else {
            this.flags.collapsed = false;
        }
        this.setDirtyCanvas(true, true);
    }

    /**
     * Forces the node to do not move or realign on Z
     * @method pin
     **/

    pin(v) {
        this.graph.onGraphChanged({action: "pin"});
        if (v === undefined) {
            this.flags.pinned = !this.flags.pinned;
        } else {
            this.flags.pinned = v;
        }
    }

    localToScreen(x, y, graphcanvas) {
        return [
            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],
        ];
    }

    refreshAncestors(optsIn = {}) {
        var optsDef = {
            action: "",
            param: null,
            options: null,
            passParam: true,
        };
        var opts = Object.assign(optsDef,optsIn);

        if (!this.inputs) {
            return;
        }
        if (LiteGraph.preventAncestorRecalculation) {
            if (this.graph.node_ancestorsCalculated && this.graph.node_ancestorsCalculated[this.id]) {
                LiteGraph.log_verbose("lgraphnode", "refreshAncestors", "already calculated subtree! Prevent! "+this.id+":"+this.order, this);
                return;
            }
        }

        if (!opts.action || opts.action == "")
            opts.action = this.id+"_ancestors";
        if (!opts.param || opts.param == "")
            opts.param = this.id+"_ancestors";
        if (!opts.options)
            opts.options = {};
        opts.options = Object.assign({action_call: opts.action},opts.options);

        LiteGraph.log_verbose("lgraphnode", "refreshAncestors", "ancestors processing", this.id+":"+this.order+" "+opts.options.action_call, this);

        this.graph.ancestorsCall = true; // prevent triggering slots

        var optsAncestors = {
            modesSkip: [LiteGraph.NEVER, LiteGraph.ON_EVENT, LiteGraph.ON_TRIGGER],
            modesOnly: [LiteGraph.ALWAYS, LiteGraph.ON_REQUEST],
            typesSkip: [LiteGraph.ACTION],
            typesOnly: [],
        };
        var aAncestors = this.graph.getAncestors(this,optsAncestors);
        for(var iN in aAncestors) {
            LiteGraph.log_verbose("lgraphnode", "refreshAncestors", "doExecute ancestor", iN, aAncestors[iN], opts.param, opts.options);
            aAncestors[iN].doExecute(opts.param, opts.options);
            this.graph.node_ancestorsCalculated[aAncestors[iN].id] = true;
        }

        this.graph.ancestorsCall = false; // restore triggering slots
        this.graph.node_ancestorsCalculated[this.id] = true;

        return true;
    }

    /**
    * syncObjectByProperty will ensure using the right index for node inputs and outputs when onConfigure (de-serializing) 
    * @param {*} ob_from 
    * @param {*} ob_dest 
    * @param {*} property 
    * @param {*} optsIn 
    * @returns {object} return the result object and differences if found
    */
    syncObjectByProperty(ob_from, ob_dest, property, optsIn) {
        var optsDef = {
            only_in_source: "append",
            // only_in_dest: "keep"
            fallback_checks: [
                {name: "type"}
            ]
        };
        var opts = Object.assign({}, optsDef, optsIn);
        
        if (ob_from === null || !ob_from) ob_from = [];
        if (ob_dest === null || !ob_dest) ob_dest = [];
        var new_dest = [];

        let keys_remap = {};

        let only_in_target = ob_dest.filter(input => !ob_from.some(srcInput => srcInput[property] === input[property]));
        /* if (opts.only_in_dest !== "keep") {
            new_dest = ob_dest.filter(input => ob_from.some(srcInput => srcInput[property] === input[property]) || opts.only_in_dest === "keep");
        } */

        let sourceUsedIds = [];
        let aNotFoundInSource = [];
        // cycle dest, for each cycle source for matching
        ob_dest.forEach((destInput, destIndex) => {
            let hasChangedIndex = false;
            let foundInSource = false;
            ob_from.forEach((sourceInput, sourceIndex) => {
                if(foundInSource) return;
                if(sourceUsedIds.includes(sourceIndex)){
                    LiteGraph.log_verbose("syncObjectByProperty", "skip used", sourceInput, sourceIndex);
                }else if(sourceInput[property] === destInput[property]){
                    foundInSource = true;
                    sourceUsedIds.push(sourceIndex);
                    new_dest[destIndex] = LiteGraph.cloneObject(sourceInput);
                    if(destIndex!=sourceIndex){
                        LiteGraph.log_debug("syncObjectByProperty", "push SHIFTED", destInput[property], destInput, sourceIndex, destIndex);
                        hasChangedIndex = true;
                        keys_remap[sourceIndex] = destIndex;
                    }else{
                        LiteGraph.log_verbose("syncObjectByProperty", "found ok, same index", destInput[property], sourceInput, destIndex);
                    }
                }
            });
            if(!foundInSource){ //} && !hasChangedIndex){
                aNotFoundInSource.push({ob: destInput, index: destIndex});
                // TODO: should check link ?!
                // TODO: should try to connect by type before than pushing, check AUDIO example (has invalid link or bad behavior?)
            }
        });
        if(aNotFoundInSource.length){
            if(!opts.fallback_checks.length){
                aNotFoundInSource.forEach((ob, i) => {
                    LiteGraph.log_debug("syncObjectByProperty", "!using fallback checks", "push !foundInSource", ob.ob[property], ob);
                    new_dest[ob.index] = LiteGraph.cloneObject(ob.ob);
                });
            }else{
                aNotFoundInSource.forEach((ob, i) => {
                    let destInput = ob.ob;
                    let destIndex = ob.index;
                    // LiteGraph.log_warn("syncObjectByProperty", "CHECKING", destIndex, destInput);
                    let foundInSource = false;
                    let hasChangedIndex = false;
                    opts.fallback_checks.forEach((checkX, ckI) => {
                        if(foundInSource) return;
                        ob_from.forEach((sourceInput, sourceIndex) => {
                            if(foundInSource) return;
                            if(sourceUsedIds.includes(sourceIndex)){
                                LiteGraph.log_verbose("syncObjectByProperty", "aNotFoundInSource skip used slot", sourceInput, sourceIndex);
                            }else if(
                                sourceInput[checkX.name] === destInput[checkX.name]
                                // && (!checkX.dest_valid || )
                            ){
                                foundInSource = true;
                                sourceUsedIds.push(sourceIndex);
                                new_dest[destIndex] = LiteGraph.cloneObject(sourceInput);
                                LiteGraph.log_debug("syncObjectByProperty", "aNotFoundInSource", checkX, "push SHIFTED", destInput[checkX], destInput, sourceIndex, destIndex);
                                hasChangedIndex = true;
                                keys_remap[sourceIndex] = destIndex;
                            }
                        });
                    });
                    if(!foundInSource){
                        LiteGraph.log_debug("syncObjectByProperty", "aNotFoundInSource, push !foundInSource",ob.ob[property],ob);
                        new_dest[ob.index] = LiteGraph.cloneObject(ob.ob);
                    }
                });
            }
        }

        // check only in source
        /* let only_in_source = ob_from.filter(input => !ob_dest.some(destInput => destInput[property] === input[property]));
        if (opts.only_in_source === "append" && only_in_source.length) {
            LiteGraph.log_debug("syncObjectByProperty", "push only_in_source", only_in_source);
            new_dest.push(...only_in_source);
        } */
        let destUsedIds = [];
        // cycle source, for each cycle dest
        let only_in_source = [];
        ob_from.forEach((sourceInput, sourceIndex) => {
            let foundInDest = false;
            if(sourceUsedIds.includes(sourceIndex)){
                return;
            }
            ob_dest.forEach((destInput, destIndex) => {
                if(foundInDest) return;
                if(destUsedIds.includes(destIndex)){
                    LiteGraph.log_verbose("syncObjectByProperty", "only_in_source", "skip checked slot", sourceInput, sourceIndex);
                }else if(sourceInput[property] === destInput[property]){
                    destUsedIds.push(destIndex);
                    foundInDest = true;
                }
            });
            if(!foundInDest){
                // TODO: should try to connect by type before than pushing, check AUDIO example (has invalid link or bad behavior?)
                LiteGraph.log_debug("syncObjectByProperty", "push only_in_source", sourceInput[property], sourceInput);
                new_dest.push(LiteGraph.cloneObject(sourceInput));
                keys_remap[sourceIndex] = new_dest.length-1;
                only_in_source.push(sourceInput);
            }
        });


        LiteGraph.log_info("lgraphnode", "syncByProperty", {
            only_in_source: only_in_source,
            only_in_target: only_in_target,
            ob_from: ob_from,
            ob_dest: ob_dest,
            new_dest: new_dest,
            keys_remap: keys_remap,
        });

        return {
            ob_dest: new_dest,
            keys_remap: keys_remap,
            only_in_source: only_in_source,
            only_in_target: only_in_target,
        };
    }


}


/**
 * Class representing a link object that stores link information between two nodes.
 */
export class LLink {

    /**
     * Create a link object.
     * @param {string} id - The unique identifier of the link.
     * @param {string} type - The type of the link.
     * @param {string} origin_id - The identifier of the origin node.
     * @param {string} origin_slot - The slot of the origin node the link is connected to.
     * @param {string} target_id - The identifier of the target node.
     * @param {string} target_slot - The slot of the target node the link is connected to.
     */
    constructor(id, type, origin_id, origin_slot, target_id, target_slot) {
        this.id = id;
        this.type = type;
        this.origin_id = origin_id;
        this.origin_slot = origin_slot;
        this.target_id = target_id;
        this.target_slot = target_slot;

        this._data = null;
        this._pos = new Float32Array(2); // center
    }

    /**
     * Configure the link object with new data.
     * @param {Array|Object} o - An array or object containing link data to configure.
     */
    configure(o) {
        if (o.constructor === Array) {
            this.id = o[0];
            this.origin_id = o[1];
            this.origin_slot = o[2];
            this.target_id = o[3];
            this.target_slot = o[4];
            this.type = o[5];
        } else {
            this.id = o.id;
            this.type = o.type;
            this.origin_id = o.origin_id;
            this.origin_slot = o.origin_slot;
            this.target_id = o.target_id;
            this.target_slot = o.target_slot;
        }
    }

    /**
     * Serialize the link object to an array.
     * @returns {Array} An array containing the serialized link data.
     */
    serialize() {
        return [
            this.id,
            this.origin_id,
            this.origin_slot,
            this.target_id,
            this.target_slot,
            this.type,
        ];
    }
}


/**
 * extracted from base nodes
 */

// Subgraph: a node that contains a graph
export class Subgraph {

    static title = "Subgraph";
    static desc = "Graph inside a node";

    constructor() {

        this.size = [140, 80];
        this.properties = { enabled: true };
        this.enabled = true;

        // create inner graph
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;

        this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);

        // nodes input node added inside
        this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
        this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
        this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
        this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);

        this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
        this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
        this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
        this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
    }

    onGetInputs() {
        return [["enabled", "boolean"]];
    }

    /*
    Subgraph.prototype.onDrawTitle = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.fillStyle = "#555";
        var w = LiteGraph.NODE_TITLE_HEIGHT;
        var x = this.size[0] - w;
        ctx.fillRect(x, -w, w, w);
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(x + w * 0.2, -w * 0.6);
        ctx.lineTo(x + w * 0.8, -w * 0.6);
        ctx.lineTo(x + w * 0.5, -w * 0.3);
        ctx.fill();
    };
    */

    onDblClick(e, pos, graphcanvas) {
        var that = this;
        setTimeout(function () {
            graphcanvas.openSubgraph(that.subgraph);
        }, 10);
    }

    /*
    Subgraph.prototype.onMouseDown = function(e, pos, graphcanvas) {
        if (
            !this.flags.collapsed &&
            pos[0] > this.size[0] - LiteGraph.NODE_TITLE_HEIGHT &&
            pos[1] < 0
        ) {
            var that = this;
            setTimeout(function() {
                graphcanvas.openSubgraph(that.subgraph);
            }, 10);
        }
    };
    */

    onAction(action, param) {
        LiteGraph.log_debug("subgraph","onAction",...arguments);
        this.subgraph.onAction(action, param);
    }

    onExecute() {
        this.enabled = this.getInputOrProperty("enabled");
        if (!this.enabled) {
            return;
        }

        // send inputs to subgraph global inputs
        if (this.inputs) {
            for (let i = 0; i < this.inputs.length; i++) {
                let input = this.inputs[i];
                let value = this.getInputData(i);
                this.subgraph.setInputData(input.name, value);
            }
        }

        // execute
        LiteGraph.log_verbose("subgraph","onExecute","subgraph runStep",this.subgraph);
        this.subgraph.runStep();

        // send subgraph global outputs to outputs
        if (this.outputs) {
            for (let i = 0; i < this.outputs.length; i++) {
                let output = this.outputs[i];
                let value = this.subgraph.getOutputData(output.name);
                this.setOutputData(i, value);
            }
        }
    }

    sendEventToAllNodes(eventname, param, mode) {
        if (this.enabled) {
            LiteGraph.log_debug("subgraph","sendEventToAllNodes",...arguments);
            this.subgraph.sendEventToAllNodes(eventname, param, mode);
        }
    }

    onDrawBackground(ctx, graphcanvas, canvas, pos) {
        if (this.flags.collapsed) return;
        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
        // button
        var over = LiteGraph.isInsideRectangle(
            pos[0],
            pos[1],
            this.pos[0],
            this.pos[1] + y,
            this.size[0],
            LiteGraph.NODE_TITLE_HEIGHT,
        );
        let overleft = LiteGraph.isInsideRectangle(
            pos[0],
            pos[1],
            this.pos[0],
            this.pos[1] + y,
            this.size[0] / 2,
            LiteGraph.NODE_TITLE_HEIGHT,
        );
        ctx.fillStyle = over ? "#555" : "#222";
        ctx.beginPath();
        if (this._shape == LiteGraph.BOX_SHAPE) {
            if (overleft) {
                ctx.rect(0, y, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT);
            } else {
                ctx.rect(
                    this.size[0] / 2,
                    y,
                    this.size[0] / 2 + 1,
                    LiteGraph.NODE_TITLE_HEIGHT,
                );
            }
        } else {
            if (overleft) {
                ctx.roundRect(
                    0,
                    y,
                    this.size[0] / 2 + 1,
                    LiteGraph.NODE_TITLE_HEIGHT,
                    [0, 0, 8, 8],
                );
            } else {
                ctx.roundRect(
                    this.size[0] / 2,
                    y,
                    this.size[0] / 2 + 1,
                    LiteGraph.NODE_TITLE_HEIGHT,
                    [0, 0, 8, 8],
                );
            }
        }
        if (over) {
            ctx.fill();
        } else {
            ctx.fillRect(0, y, this.size[0] + 1, LiteGraph.NODE_TITLE_HEIGHT);
        }
        // button
        ctx.textAlign = "center";
        ctx.font = "24px Arial";
        ctx.fillStyle = over ? "#DDD" : "#999";
        ctx.fillText("+", this.size[0] * 0.25, y + 24);
        ctx.fillText("+", this.size[0] * 0.75, y + 24);
    }

    // Subgraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
    // {
    // 	var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
    // 	if(localpos[1] > y)
    // 	{
    // 		graphcanvas.showSubgraphPropertiesDialog(this);
    // 	}
    // }
    onMouseDown(e, localpos, graphcanvas) {
        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
        console.log?.(0);
        if (localpos[1] > y) {
            if (localpos[0] < this.size[0] / 2) {
                console.log?.(1);
                graphcanvas.showSubgraphPropertiesDialog(this);
            } else {
                console.log?.(2);
                graphcanvas.showSubgraphPropertiesDialogRight(this);
            }
        }
    }

    computeSize() {
        var num_inputs = this.inputs ? this.inputs.length : 0;
        var num_outputs = this.outputs ? this.outputs.length : 0;
        return [
            200,
            Math.max(num_inputs, num_outputs) * LiteGraph.NODE_SLOT_HEIGHT +
                LiteGraph.NODE_TITLE_HEIGHT,
        ];
    }

    //* *** INPUTS ***********************************
    onSubgraphTrigger(event) {
        LiteGraph.log_debug("subgraph","onSubgraphTrigger",...arguments);
        var slot = this.findOutputSlot(event);
        if (slot != -1) {
            this.triggerSlot(slot);
        }
    }

    onSubgraphNewInput(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            // add input to the node
            this.addInput(name, type);
        }
    }

    onSubgraphRenamedInput(oldname, name) {
        var slot = this.findInputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.name = name;
    }

    onSubgraphTypeChangeInput(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.type = type;
    }

    onSubgraphRemovedInput(name) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeInput(slot);
    }

    //* *** OUTPUTS ***********************************
    onSubgraphNewOutput(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            this.addOutput(name, type);
        }
    }

    onSubgraphRenamedOutput(oldname, name) {
        var slot = this.findOutputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.name = name;
    }

    onSubgraphTypeChangeOutput(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.type = type;
    }

    onSubgraphRemovedOutput(name) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeOutput(slot);
    }

    getExtraMenuOptions(graphcanvas) {
        var that = this;
        return [
            {
                content: "Open",
                callback: function () {
                    graphcanvas.openSubgraph(that.subgraph);
                },
            },
        ];
    }

    onResize(size) {
        size[1] += 20; // TODO check and verify onResize callback :: using byRef! 
    }

    serialize() {
        var data = LiteGraph.LGraphNode.prototype.serialize.call(this);
        data.subgraph = this.subgraph.serialize();
        return data;
    }

    // no need to define node.configure, the default method detects node.subgraph and passes the object to node.subgraph.configure()
    reassignSubgraphUUIDs(graph) {
        const idMap = { nodeIDs: {}, linkIDs: {} };

        for (const node of graph.nodes) {
            const oldID = node.id;
            const newID = LiteGraph.uuidv4();
            node.id = newID;

            if (idMap.nodeIDs[oldID] || idMap.nodeIDs[newID]) {
                throw new Error(`New/old node UUID wasn't unique in changed map! ${oldID} ${newID}`);
            }

            idMap.nodeIDs[oldID] = newID;
            idMap.nodeIDs[newID] = oldID;
        }

        for (const link of graph.links) {
            const oldID = link[0];
            const newID = LiteGraph.uuidv4();
            link[0] = newID;

            if (idMap.linkIDs[oldID] || idMap.linkIDs[newID]) {
                throw new Error(`New/old link UUID wasn't unique in changed map! ${oldID} ${newID}`);
            }

            idMap.linkIDs[oldID] = newID;
            idMap.linkIDs[newID] = oldID;

            const nodeFrom = link[1];
            const nodeTo = link[3];

            if (!idMap.nodeIDs[nodeFrom]) {
                throw new Error(`Old node UUID not found in mapping! ${nodeFrom}`);
            }

            link[1] = idMap.nodeIDs[nodeFrom];

            if (!idMap.nodeIDs[nodeTo]) {
                throw new Error(`Old node UUID not found in mapping! ${nodeTo}`);
            }

            link[3] = idMap.nodeIDs[nodeTo];
        }

        // Reconnect links
        for (const node of graph.nodes) {
            if (node.inputs) {
                for (const input of node.inputs) {
                    if (input.link) {
                        input.link = idMap.linkIDs[input.link];
                    }
                }
            }
            if (node.outputs) {
                for (const output of node.outputs) {
                    if (output.links) {
                        output.links = output.links.map((l) => idMap.linkIDs[l]);
                    }
                }
            }
        }

        // Recurse!
        for (const node of graph.nodes) {
            if (node.type === "graph/subgraph") {
                const merge = reassignGraphUUIDs(node.subgraph);
                idMap.nodeIDs.assign(merge.nodeIDs);
                idMap.linkIDs.assign(merge.linkIDs);
            }
        }
    }

    clone() {
        var node = LiteGraph.createNode(this.type);
        var data = this.serialize();

        if (LiteGraph.use_uuids) {
            // LiteGraph.LGraph.serialize() seems to reuse objects in the original graph. But we
            // need to change node IDs here, so clone it first.
            const subgraph = LiteGraph.cloneObject(data.subgraph);

            this.reassignSubgraphUUIDs(subgraph);

            data.subgraph = subgraph;
        }

        delete data["id"];
        delete data["inputs"];
        delete data["outputs"];
        node.configure(data);
        return node;
    }

    buildFromNodes(nodes) {
        // clear all?
        // TODO

        // nodes that connect data between parent graph and subgraph

        // mark inner nodes
        var ids = {};
        // TODO: these aren't currently used.  Examine and decide whether to excise.
        //    var min_x = 0;
        //    var max_x = 0;
        for (let i = 0; i < nodes.length; ++i) {
            ids[node.id] = nodes[i];
            //      min_x = Math.min(node.pos[0], min_x);
            //      max_x = Math.max(node.pos[0], min_x);
        }

        for (let i = 0; i < nodes.length; ++i) {
            let node = nodes[i];
            // check inputs
            if (node.inputs)
                for (let j = 0; j < node.inputs.length; ++j) {
                    let input = node.inputs[j];
                    if (!input || !input.link) continue;
                    let link = node.graph.links[input.link];
                    if (!link) continue;
                    if (ids[link.origin_id]) continue;
                    // this.addInput(input.name,link.type);
                    this.subgraph.addInput(input.name, link.type);
                    /*
                    var input_node = LiteGraph.createNode("graph/input");
                    this.subgraph.add( input_node );
                    input_node.pos = [min_x - 200, last_input_y ];
                    last_input_y += 100;
                    */
                }

            // check outputs
            if (node.outputs)
                for (let j = 0; j < node.outputs.length; ++j) {
                    let output = node.outputs[j];
                    if (!output || !output.links || !output.links.length) continue;
                    //    var is_external = false;
                    for (let k = 0; k < output.links.length; ++k) {
                        let link = node.graph.links[output.links[k]];
                        if (!link) continue;
                        if (ids[link.target_id]) continue;
                        //        is_external = true;
                        break;
                    }
                    // if (!is_external) continue;
                    // this.addOutput(output.name,output.type);
                    /*
                    var output_node = LiteGraph.createNode("graph/output");
                    this.subgraph.add( output_node );
                    output_node.pos = [max_x + 50, last_output_y ];
                    last_output_y += 100;
                    */
                }
        }

        // detect inputs and outputs
        // split every connection in two data_connection nodes
        // keep track of internal connections
        // connect external connections

        // clone nodes inside subgraph and try to reconnect them

        // connect edge subgraph nodes to extarnal connections nodes
    }

    static title_color = "#334";
}


export class GraphInput {

    static title = "Input";
    static desc = "Input of the graph";

    constructor() {

        this.addOutput("", "number");

        this.name_in_graph = "";
        this.properties = {
            name: "",
            type: "number",
            value: 0,
        };

        var that = this;

        this.name_widget = this.addWidget(
            "text",
            "Name",
            this.properties.name,
            function (v) {
                if (!v) {
                    return;
                }
                that.setProperty("name", v);
            },
        );
        this.type_widget = this.addWidget(
            "text",
            "Type",
            this.properties.type,
            function (v) {
                that.setProperty("type", v);
            },
        );

        this.value_widget = this.addWidget(
            "number",
            "Value",
            this.properties.value,
            function (v) {
                that.setProperty("value", v);
            },
        );

        this.widgets_up = true;
        this.size = [180, 90];
    }

    onConfigure() {
        this.updateType();
    }

    // ensures the type in the node output and the type in the associated graph input are the same
    updateType() {
        var type = this.properties.type;
        this.type_widget.value = type;

        // update output
        if (type == "action" || type == "event") type = LiteGraph.EVENT;
        if (this.outputs[0].type !== type) {
            if (!LiteGraph.isValidConnection(this.outputs[0].type, type))
                this.disconnectOutput(0);
            this.outputs[0].type = type;
        }
        this.properties.type = type;

        // update widget
        if (type == "number") {
            this.value_widget.type = "number";
            this.value_widget.value = Number(); // 0
        } else if (type == "boolean") {
            this.value_widget.type = "toggle";
            this.value_widget.value = this.value_widget.value&&(this.value_widget.value+"").toLocaleLowerCase()!=="false"&&this.value_widget.value!==""?true:false; // "true"
        } else if (type == "string") {
            this.value_widget.type = "text";
            this.value_widget.value = this.value_widget.value+""; // ""
        } else {
            this.value_widget.type = null;
            // this.value_widget.value = null;
        }
        this.properties.value = this.value_widget.value;

        // update graph
        if (this.graph && this.name_in_graph) {
            this.graph.changeInputType(this.name_in_graph, type);
        }
    }

    // this is executed AFTER the property has changed
    onPropertyChanged(name, v) {
        if (name == "name") {
            if (v == "" || v == this.name_in_graph || v == "enabled") {
                return false;
            }
            if (this.graph) {
                if (this.name_in_graph) {
                    // already added
                    this.graph.renameInput(this.name_in_graph, v);
                } else {
                    this.graph.addInput(v, this.properties.type);
                }
            } // what if not?!
            this.name_widget.value = v;
            this.name_in_graph = v;
        } else if (name == "type") {
            this.updateType();
        }
    }

    getTitle() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    }

    onAction(action, param) {
        if (this.properties.type == LiteGraph.EVENT) {
            LiteGraph.log_debug("GraphInput","onAction","triggering slot", action, param);
            this.triggerSlot(0, param);
        }else{
            LiteGraph.log_debug("GraphInput","onAction","NOT eventAction TYPE", "this", this, "arugments", ...arguments);
        }
    }

    onExecute() {
        var name = this.properties.name;
        // read from global input
        var data = this.graph.inputs[name];
        if (!data) {
            this.setOutputData(0, this.properties.value);
            return;
        }

        this.setOutputData(
            0,
            data.value !== undefined ? data.value : this.properties.value,
        );
    }

    onRemoved() {
        if (this.name_in_graph) {
            this.graph.removeInput(this.name_in_graph);
        }
    }
}


// Output for a subgraph
export class GraphOutput {

    static title = "Output";
    static desc = "Output of the graph";

    constructor() {

        this.addInput("", "");

        this.name_in_graph = "";
        this.properties = { name: "", type: "" };

        // Object.defineProperty(this.properties, "name", {
        //     get: function() {
        //         return that.name_in_graph;
        //     },
        //     set: function(v) {
        //         if (v == "" || v == that.name_in_graph) {
        //             return;
        //         }
        //         if (that.name_in_graph) {
        //             //already added
        //             that.graph.renameOutput(that.name_in_graph, v);
        //         } else {
        //             that.graph.addOutput(v, that.properties.type);
        //         }
        //         that.name_widget.value = v;
        //         that.name_in_graph = v;
        //     },
        //     enumerable: true
        // });

        // Object.defineProperty(this.properties, "type", {
        //     get: function() {
        //         return that.inputs[0].type;
        //     },
        //     set: function(v) {
        //         if (v == "action" || v == "event") {
        //             v = LiteGraph.ACTION;
        //         }
        //         if (!LiteGraph.isValidConnection(that.inputs[0].type,v))
        // 			that.disconnectInput(0);
        //         that.inputs[0].type = v;
        //         if (that.name_in_graph) {
        //             //already added
        //             that.graph.changeOutputType(
        //                 that.name_in_graph,
        //                 that.inputs[0].type
        //             );
        //         }
        //         that.type_widget.value = v || "";
        //     },
        //     enumerable: true
        // });

        this.name_widget = this.addWidget(
            "text",
            "Name",
            this.properties.name,
            "name",
        );
        this.type_widget = this.addWidget(
            "text",
            "Type",
            this.properties.type,
            "type",
        );
        this.widgets_up = true;
        this.size = [180, 60];
    }

    onPropertyChanged(name, v) {
        if (name == "name") {
            if (v == "" || v == this.name_in_graph || v == "enabled") {
                return false;
            }
            if (this.graph) {
                if (this.name_in_graph) {
                    // already added
                    this.graph.renameOutput(this.name_in_graph, v);
                } else {
                    this.graph.addOutput(v, this.properties.type);
                }
            } // what if not?!
            this.name_widget.value = v;
            this.name_in_graph = v;
        } else if (name == "type") {
            this.updateType();
        }
    }

    updateType() {
        var type = this.properties.type;
        if (this.type_widget) this.type_widget.value = type;

        // update output
        if (type == "action" || type == "event") type = LiteGraph.EVENT;
        if (this.inputs[0].type !== type) {
            if (!LiteGraph.isValidConnection(this.inputs[0].type, type))
                this.disconnectInput(0);
            this.inputs[0].type = type;
        }
        this.properties.type = type;

        // TODO CHECK why differente from GraphInput 
        /* // update widget
        if (type == "number") {
            this.value_widget.type = "number";
            this.value_widget.value = Number(); // 0
        } else if (type == "boolean") {
            this.value_widget.type = "toggle";
            this.value_widget.value = this.value_widget.value&&(this.value_widget.value+"").toLocaleLowerCase()!=="false"&&this.value_widget.value!==""?true:false; // "true"
        } else if (type == "string") {
            this.value_widget.type = "text";
            this.value_widget.value = this.value_widget.value+""; // ""
        } else {
            this.value_widget.type = null;
            // this.value_widget.value = null;
        }
        this.properties.value = this.value_widget.value; */

        // update graph
        if (this.graph && this.name_in_graph) {
            this.graph.changeOutputType(this.name_in_graph, type);
        }
    }

    onExecute() {
        this._value = this.getInputData(0);
        this.graph.setOutputData(this.properties.name, this._value);
    }

    onAction(action, param) {
        if (this.properties.type == LiteGraph.ACTION) {
            LiteGraph.log_debug("GraphOutput","onAction", ...arguments);
            LiteGraph.log_debug("GraphOutput","onAction", "graphTrigger", this.properties.name, param);
            // ---> subgraph_node.trigger(this.properties.name, param);
            this.triggerSlot(this.properties.name, param);
            // this.onTrigger(this.properties.name, param);
            this.graph.trigger(this.properties.name, param);
            // node.doExecute?.() !!
        }else{
            LiteGraph.log_debug("GraphOutput","onAction","skipping not ACTION type", this.properties.type, this.properties);
        }
    }

    onRemoved() {
        if (this.name_in_graph) {
            this.graph.removeOutput(this.name_in_graph);
        }
    }

    getTitle() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    }
}

// LiteGraph.registerNodeType("graph/subgraph", Subgraph);
// LiteGraph.registerNodeType("graph/input", GraphInput);
// LiteGraph.registerNodeType("graph/output", GraphOutput);

// this needs to be called after all classes has been included, before registering nodes and creating canvas
// will setup callback handlers and LiteGraph.CLASSES references ( eg. LitegGraph.LGraph, .. )
LiteGraph.initialize();

class Time {

    static title = "Time";
    static desc = "Time";

    constructor() {
        this.addOutput("in ms", "number");
        this.addOutput("in sec", "number");
    }

    onExecute() {
        this.setOutputData(0, this.graph.globaltime * 1000);
        this.setOutputData(1, this.graph.globaltime);
    }
}
LiteGraph.registerNodeType("basic/time", Time);

class Empty {

    static title = "";
    static desc = "Empty node";

    constructor() {
        
    }

    onExecute() {
        
    }
}
LiteGraph.registerNodeType("basic/empty", Empty);

// Constant
class ConstantNumber {

    static title = "Const Number";
    static desc = "Constant number";

    constructor() {
        this.addOutput("value", "number");
        this.addProperty("value", 1.0, "number");
        this.addProperty("precision", 12, "number", {min: 0, max: 12});
        this.addProperty("step", 1, "number");
        this.addProperty("min", 0, "number");
        this.addProperty("max", Number.MAX_SAFE_INTEGER, "number");
        this.widget = this.addWidget("number", "value", 1, "value", { precision: this.properties.precision, step: this.properties.step, min: this.properties.min });
        this.widgets_up = true;
        this.size = [180, 30];
    }

    onPropertyChanged(name, value) {
        if (["precision","step","min"].indexOf(name) !== -1) {
            if(name=="precision"){
                value = Math.max(0,Math.min(value,12));
                return false;
            }
            this.widgets[0].options[name] = value;
        }
    }

    onExecute() {
        this.setOutputData(0, parseFloat(this.properties["value"]));
    }

    getTitle() {
        if (this.flags?.collapsed) {
            return this.properties?.value;
        }
        return this.title;
    }

    setValue(v) {
        this.setProperty("value", v);
    }

    onDrawBackground() {
        // show the current value
        this.outputs[0].label = LiteGraph.formatNumber(this.properties["value"],3);
    }
}
LiteGraph.registerNodeType("basic/const", ConstantNumber);

class ConstantBoolean {

    static title = "Const Boolean";
    static desc = "Constant boolean";

    constructor() {
        this.addOutput("bool", "boolean");
        this.addProperty("value", true);
        this.widget = this.addWidget("toggle", "value", true, "value");
        this.serialize_widgets = true;
        this.widgets_up = true;
        this.size = [140, 30];
    }

    onExecute() {
        this.setOutputData(0, this.properties["value"]);
    }

    onGetInputs() {
        return [["toggle", LiteGraph.ACTION]];
    }

    onAction() {
        this.setValue(!this.properties?.value);
    }
}
ConstantBoolean.prototype.getTitle = ConstantNumber.prototype.getTitle;
ConstantBoolean.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/boolean", ConstantBoolean);


class ConstantString {

    static title = "Const String";
    static desc = "Constant string";

    constructor() {
        this.addOutput("string", "string");
        this.addProperty("value", "");
        this.widget = this.addWidget("text", "value", "", "value"); // link to property value
        this.widgets_up = true;
        this.size = [180, 30];
    }

    onExecute() {
        this.setOutputData(0, this.properties["value"]);
    }

    onDropFile(file) {
        var that = this;
        var reader = new FileReader();
        reader.onload = function (e) {
            that.setProperty("value", e.target.result);
        };
        reader.readAsText(file);
    }
}
ConstantString.prototype.getTitle = ConstantNumber.prototype.getTitle;
ConstantString.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/string", ConstantString);


class ConstantObject {

    static title = "Const Object";
    static desc = "Constant Object";

    constructor() {
        this.addOutput("obj", "object");
        this.size = [120, 30];
        this._object = {};
    }

    onExecute() {
        this.setOutputData(0, this._object);
    }
}
LiteGraph.registerNodeType("basic/object", ConstantObject);


class ConstantFile {

    static title = "Const File";
    static desc = "Fetches a file from an url";

    constructor() {
        this.addInput("url", "string");
        this.addOutput("file", "string");
        this.addProperty("url", "");
        this.addProperty("type", "text");
        this.widget = this.addWidget("text", "url", "", "url");
        this._data = null;
    }

    onPropertyChanged(name, value) {
        if (name == "url") {
            if (value == null || value == "") this._data = null;
            else {
                this.fetchFile(value);
            }
        }
    }

    onExecute() {
        var url = this.getInputData(0) || this.properties.url;
        if (url && (url != this._url || this._type != this.properties?.type))
            this.fetchFile(url);
        this.setOutputData(0, this._data);
    }

    fetchFile(url) {
        var that = this;
        if (!url || url.constructor !== String) {
            that._data = null;
            that.boxcolor = null;
            return;
        }

        this._url = url;
        this._type = this.properties?.type;
        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }
        fetch(url)
            .then(function (response) {
                if (!response.ok) throw new Error("File not found");

                if (that.properties.type == "arraybuffer")
                    return response.arrayBuffer();
                else if (that.properties.type == "text") return response.text();
                else if (that.properties.type == "json") return response.json();
                else if (that.properties.type == "blob") return response.blob();
            })
            .then(function (data) {
                that._data = data;
                that.boxcolor = "#AEA";
            })
            .catch((_error) => {
                that._data = null;
                that.boxcolor = "red";
                console.error?.("error fetching file:", url);
            });
    }

    onDropFile(file) {
        var that = this;
        this._url = file.name;
        this._type = this.properties?.type;
        this.properties.url = file.name;
        var reader = new FileReader();
        reader.onload = function (e) {
            that.boxcolor = "#AEA";
            var v = e.target.result;
            if (that.properties.type == "json") v = JSON.parse(v);
            that._data = v;
        };
        if (that.properties.type == "arraybuffer") reader.readAsArrayBuffer(file);
        else if (that.properties.type == "text" || that.properties.type == "json")
            reader.readAsText(file);
        else if (that.properties.type == "blob")
            return reader.readAsBinaryString(file);
    }

    static "@type" = {
        type: "enum",
        values: ["text", "arraybuffer", "blob", "json"],
    };
}
ConstantFile.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/file", ConstantFile);


// to store json objects
class JSONParse {

    static title = "JSON Parse";
    static desc = "Parses JSON String into object";

    constructor() {
        this.addInput("parse", LiteGraph.ACTION);
        this.addInput("json", "string");
        this.addOutput("done", LiteGraph.EVENT);
        this.addOutput("object", "object");
        this.widget = this.addWidget("button", "parse", "", this.parse.bind(this));
        this._str = null;
        this._obj = null;
    }

    parse() {
        if (!this._str) return;

        try {
            this._str = this.getInputData(1);
            this._obj = JSON.parse(this._str);
            this.boxcolor = "#AEA";
            this.triggerSlot(0);
        } catch (err) {
            this.boxcolor = "red";
        }
    }

    onExecute() {
        this._str = this.getInputData(1);
        this.setOutputData(1, this._obj);
    }

    onAction(name) {
        if (name == "parse") this.parse();
    }
}
LiteGraph.registerNodeType("basic/jsonparse", JSONParse);


// to store json objects
class ConstantData {

    static title = "Const Data";
    static desc = "Constant Data";

    constructor() {
        this.addOutput("data", "object");
        this.addProperty("value", "");
        this.widget = this.addWidget("text", "json", "", "value");
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    onPropertyChanged(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
            this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    }

    onExecute() {
        this.setOutputData(0, this._value);
    }
}
ConstantData.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/data", ConstantData);


// to store json objects
class ConstantArray {

    static title = "Const Array";
    static desc = "Constant Array";

    constructor() {
        this._value = [];
        this.addInput("array", "");
        this.addOutput("arrayOut", "array");
        this.addOutput("length", "number");
        this.addProperty("value", "[]");
        this.addProperty("persistent", false);
        this.widget = this.addWidget(
            "text",
            "array",
            this.properties?.value,
            "value",
        );
        this.addWidget(
            "combo",
            "persistent",
            this.properties?.persistent,
            false,
            {values: [true, false]},
        );
        this.widgets_up = true;
        this.size = [140, 50];
    }

    onPropertyChanged(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
            if (value[0] != "[") this._value = JSON.parse("[" + value + "]");
            else this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    }

    onExecute() {
        var v = this.getInputOrProperty("array"); //getInputData(0);
        this._value = v;
        // clone
        if (!this._value || !this.properties?.persistent || this.properties?.persistent==="false")
            this._value = new Array();
        // this._value.length = v.length;
        // for (var i = 0; i < v.length; ++i)
        //     this._value[i] = v[i];
        // this.changeOutputType("arrayOut", "array");
        // TODO restart here, convert and reprocess ad array
        this.setOutputData(0, this._value);
        this.setOutputData(1, this._value ? this._value.length || 0 : 0);
    }
}
ConstantArray.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/array", ConstantArray);

class ArrayLength {

    static title = "aLength";
    static desc = "Get the length of an array";

    constructor() {
        this.addInput("arr", "array");
        this.addOutput("length", "number");
    }

    onExecute() {
        var arr = this.getInputData(0);
        if(!arr)
            return;
        if(["array","object"].includes(typeof(arr)) && typeof(arr.length)!=="undefined") {
            this.setOutputData(0,arr.length);
        }else{
            console.debug?.("Not an array or object",typeof(arr),arr);
            this.setOutputData(0,null);
        }
    }
}
LiteGraph.registerNodeType("basic/array_length", ArrayLength );


class SetArray {

    static title = "Set Array";
    static desc = "Sets index of array";

    constructor() {
        this.addInput("arr", "array");
        this.addInput("value", "");
        this.addOutput("arr", "array");
        this.properties = { index: 0 };
        this.widget = this.addWidget(
            "number",
            "i",
            this.properties?.index,
            "index",
            { precision: 0, step: 10, min: 0 },
        );
    }

    onExecute() {
        var arr = this.getInputData(0);
        if (!arr) return;
        var v = this.getInputData(1);
        if (v === undefined) return;
        if (this.properties?.index) arr[Math.floor(this.properties?.index)] = v;
        this.setOutputData(0, arr);
    }
}
LiteGraph.registerNodeType("basic/set_array", SetArray);


class ArrayElement {

    static title = "Array[i]";
    static desc = "Returns an element from an array";

    constructor() {
        this.addInput("array", "array,table,string");
        this.addInput("index", "number");
        this.addOutput("value", "");
        this.addProperty("index", 0);
    }

    onExecute() {
        var array = this.getInputData(0);
        var index = this.getInputData(1);
        if (index == null) index = this.properties?.index;
        if (array == null || index == null) return;
        this.setOutputData(0, array[Math.floor(Number(index))]);
    }
}
LiteGraph.registerNodeType("basic/array[]", ArrayElement);

class ArrayAppend {
    static title = "Array Append";
    static desc = "Pushes an element to an array";

    constructor() {
        this.addInput("array", "array");
        this.addInput("element", 0);
        this.addOutput("success", "boolean");
    }

    onExecute() {
        var array = this.getInputData(0);
        var el = this.getInputData(1);
        if(array !== null && array && typeof(array.push) == "function"){
            array.push(el);
            this.setOutputData(0, true);
        }else{
            this.setOutputData(0, false);
        }
    }
}
LiteGraph.registerNodeType("basic/array_append", ArrayAppend);


class TableElement {

    static title = "Table[row][col]";
    static desc = "Returns an element from a table";

    constructor() {
        this.addInput("table", "table");
        this.addInput("row", "number");
        this.addInput("col", "number");
        this.addOutput("value", "");
        this.addProperty("row", 0);
        this.addProperty("column", 0);
    }

    onExecute() {
        var table = this.getInputData(0);
        var row = this.getInputData(1);
        var col = this.getInputData(2);
        if (row == null) row = this.properties?.row;
        if (col == null) col = this.properties?.column;
        if (table == null || row == null || col == null) return;
        row = table[Math.floor(Number(row))];
        if (row) this.setOutputData(0, row[Math.floor(Number(col))]);
        else this.setOutputData(0, null);
    }
}
LiteGraph.registerNodeType("basic/table[][]", TableElement);


// Store as variable
class Variable {

    static title = "Variable";
    static desc = "store/read variable value";

    constructor() {
        this.size = [60, 30];
        this.addInput("in");
        this.addOutput("out");
        this.properties = { varname: "myname", container: Variable.LITEGRAPH };
        this.value = null;
    }

    onExecute() {
        var container = this.getContainer();

        if (this.isInputConnected(0)) {
            this.value = this.getInputData(0);
            container[this.properties?.varname] = this.value;
            this.setOutputData(0, this.value);
            return;
        }

        this.setOutputData(0, container[this.properties?.varname]);
    }

    getContainer() {
        switch (this.properties?.container) {
            case Variable.GRAPH:
                if (this.graph) return this.graph.vars;
                return {};
            case Variable.GLOBALSCOPE:
                return global; // @BUG: not sure what to do with this now
            default:
                return LiteGraph.Globals;
        }
    }

    getTitle() {
        return this.properties?.varname;
    }

}
// @TODO:Enum
Variable.LITEGRAPH = 0; // between all graphs
Variable.GRAPH = 1; // only inside this graph
Variable.GLOBALSCOPE = 2; // attached to Window
Variable["@container"] = {
    type: "enum",
    values: {
        litegraph: Variable.LITEGRAPH,
        graph: Variable.GRAPH,
        global: Variable.GLOBALSCOPE,
    },
};
LiteGraph.registerNodeType("basic/variable", Variable);


function length(v) {
    if (v && v.length != null) return Number(v.length);
    return 0;
}
LiteGraph.wrapFunctionAsNode("basic/length", length, [""], "number");



LiteGraph.wrapFunctionAsNode(
    "basic/not",
    function (a) {
        return !a;
    },
    [""],
    "boolean",
);


class DownloadData {

    static title = "Download";
    static desc = "Download some data";

    constructor() {
        this.size = [60, 30];
        this.addInput("data", 0);
        this.addInput("download", LiteGraph.ACTION);
        this.properties = { filename: "data.json" };
        this.value = null;
        var that = this;
        this.addWidget("button", "Download", "", () => {
            if (!that.value) return;
            that.downloadAsFile();
        });
    }

    downloadAsFile() {
        if (this.value == null) return;

        var str = null;
        if (this.value.constructor === String) str = this.value;
        else str = JSON.stringify(this.value);

        var file = new Blob([str]);
        var url = URL.createObjectURL(file);
        var element = document.createElement("a");
        element.setAttribute("href", url);
        element.setAttribute("download", this.properties?.filename);
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        setTimeout(function () {
            URL.revokeObjectURL(url);
        }, 1000 * 60); // wait one minute to revoke url
    }

    onAction() {
        var that = this;
        setTimeout(function () {
            that.downloadAsFile();
        }, 100); // deferred to avoid blocking the renderer with the popup
    }

    onExecute() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    }

    getTitle() {
        if (this.flags?.collapsed) {
            return this.properties?.filename;
        }
        return this.title;
    }
}
LiteGraph.registerNodeType("basic/download", DownloadData);


// Watch a value in the editor
class Watch {

    static title = "Watch";
    static desc = "Show value of input";

    constructor() {
        this.size = [60, 30];
        this.addInput("value", 0, { label: "" });
        this.value = 0;
    }

    onConnectionChanged(connection, slot, connected, link_info) {
        // only process the inputs
        if (connection != LiteGraph.INPUT) {
            return;
        }
        this.value = this.getInputData(0,true); // force update
    }

    onExecute() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    }

    getTitle() {
        if (this.flags?.collapsed) {
            return this.inputs[0].label;
        }
        return this.title;
    }

    static toString(o) {
        if (o == null) {
            return "null";
        } else if (o.constructor === Number) {
            return o.toFixed(3);
        } else if (o.constructor === Array) {
            var str = "[";
            for (var i = 0; i < o.length; ++i) {
                str += Watch.toString(o[i]) + (i + 1 != o.length ? "," : "");
            }
            str += "]";
            return str;
        } else {
            return String(o);
        }
    }

    onDrawBackground() {
        // show the current value
        this.inputs[0].label = Watch.toString(this.value);
    }
}
LiteGraph.registerNodeType("basic/watch", Watch);


// in case one type doesnt match other type but you want to connect them anyway
class Cast {

    static title = "Cast";
    static desc = "Allows to connect different types";

    constructor() {
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.size = [40, 30];
    }

    onExecute() {
        this.setOutputData(0, this.getInputData(0));
    }
}
LiteGraph.registerNodeType("basic/cast", Cast);


// Show value inside the debug console
class Console {

    static title = "Console";
    static desc = "Show value inside the console";
    // @BUG: Didn't output text to console, either in browser or cmd

    constructor() {
        this.mode = LiteGraph.ON_EVENT;
        this.size = [80, 30];
        this.addProperty("msg", "");
        this.addInput("log", LiteGraph.EVENT);
        this.addInput("msg", 0);
    }

    onAction(action, param, options, slot_index) {
        this.onExecute(action, param, options);
    }

    onExecute(param, options) {
        // param is the action
        const action = param;
        let msg = this.getInputData(1); // getInputDataByName("msg");
        // if (msg == null || typeof msg == "undefined") return;
        if (!msg) msg = this.properties?.msg;
        if (action == "log") {
            console.log(msg,param);
        } else if (action == "warn") {
            console.warn(msg,param);
        } else if (action == "error") {
            console.error(msg,param);
        }else{
            console.info("[ConsoleNode]",msg,param);
            console.verbose("[ConsoleNode]",msg,param,"options:",options);
        }
    }

    onGetInputs() {
        return [
            ["log", LiteGraph.ACTION],
            ["warn", LiteGraph.ACTION],
            ["error", LiteGraph.ACTION],
        ];
    }
}
LiteGraph.registerNodeType("basic/console", Console);


// Show value inside the debug console
class Alert {

    static title = "Alert";
    static desc = "Show an alert window";

    constructor() {
        this.mode = LiteGraph.ON_EVENT;
        this.addProperty("msg", "");
        this.addInput("", LiteGraph.EVENT);

        this.widget = this.addWidget("text", "Text", "", "msg");
        this.widgets_up = true;
        this.size = [200, 30];
    }

    onConfigure(o) {
        this.widget.value = o.properties.msg;
    }

    onAction() {
        var msg = this.properties?.msg;
        setTimeout(function () {
            alert(msg);
        }, 10);
    }

    static color = "#510";
}
LiteGraph.registerNodeType("basic/alert", Alert);


// Executes simple code
class NodeScript {

    static title = "Script";
    static desc = "executes a code (max 256 characters)";

    constructor() {
        this.size = [60, 30];
        this.addProperty("onExecute", "return A;");
        this.addInput("A", 0);
        this.addInput("B", 0);
        this.addOutput("out", 0);

        this._func = null;
        this.data = {};
    }

    onConfigure(o) {
        if (o.properties.onExecute && LiteGraph.allow_scripts)
            this.compileCode(o.properties.onExecute);
        else console.warn?.("Script not compiled, LiteGraph.allow_scripts is false");
    }

    onPropertyChanged(name, value) {
        if (name == "onExecute" && LiteGraph.allow_scripts) this.compileCode(value);
        else console.warn?.("Script not compiled, LiteGraph.allow_scripts is false");
    }

    compileCode(code) {
        this._func = null;
        if (code.length > 256) {
            console.warn?.("Script too long, max 256 chars");
        } else {
            var code_low = code.toLowerCase();
            var forbidden_words = [
                "script",
                "body",
                "document",
                "eval",
                "nodescript",
                "function",
            ]; // bad security solution
            for (var i = 0; i < forbidden_words.length; ++i) {
                if (code_low.indexOf(forbidden_words[i]) != -1) {
                    console.warn?.("invalid script");
                    return;
                }
            }
            try {
                this._func = new Function("A", "B", "C", "DATA", "node", code);
            } catch (err) {
                console.error?.("Error parsing script");
                console.error?.(err);
            }
        }
    }

    onExecute() {
        if (!this._func) {
            return;
        }

        try {
            var A = this.getInputData(0);
            var B = this.getInputData(1);
            var C = this.getInputData(2);
            this.setOutputData(0, this._func(A, B, C, this.data, this));
        } catch (err) {
            console.error?.("Error in script");
            console.error?.(err);
        }
    }

    onGetOutputs() {
        return [["C", ""]];
    }

    static widgets_info = { onExecute: { type: "code" } };
}
LiteGraph.registerNodeType("basic/script", NodeScript);


class GenericCompare {

    static title = "Compare *";
    static desc = "evaluates condition between A and B";

    constructor() {
        this.addInput("A", 0);
        this.addInput("B", 0);
        this.addOutput("true", "boolean");
        this.addOutput("false", "boolean");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", "==", "enum", { values: GenericCompare.values });
        this.addWidget("combo", "Op.", this.properties?.OP, {
            property: "OP",
            values: GenericCompare.values,
        });

        this.size = [80, 60];
    }

    getTitle() {
        return "*A " + this.properties?.OP + " *B";
    }

    onExecute() {
        var A = this.getInputData(0);
        if (A === undefined) {
            A = this.properties?.A;
        } else {
            this.properties.A = A;
        }

        var B = this.getInputData(1);
        if (B === undefined) {
            B = this.properties?.B;
        } else {
            this.properties.B = B;
        }

        var result = false;
        if (typeof A == typeof B) {
            switch (this.properties?.OP) {
                case "==":
                case "!=":
                    // traverse both objects.. consider that this is not a true deep check! consider underscore or other library for thath :: _isEqual()
                    result = true;
                    switch (typeof A) {
                        case "object":
                            var aProps = Object.getOwnPropertyNames(A);
                            var bProps = Object.getOwnPropertyNames(B);
                            if (aProps.length != bProps.length) {
                                result = false;
                                break;
                            }
                            for (var i = 0; i < aProps.length; i++) {
                                var propName = aProps[i];
                                if (A[propName] !== B[propName]) {
                                    result = false;
                                    break;
                                }
                            }
                            break;
                        default:
                            result = A == B;
                    }
                    if (this.properties?.OP == "!=") result = !result;
                    break;
                /* case ">":
                    result = A > B;
                    break;
                case "<":
                    result = A < B;
                    break;
                case "<=":
                    result = A <= B;
                    break;
                case ">=":
                    result = A >= B;
                    break;
                case "||":
                    result = A || B;
                    break;
                case "&&":
                    result = A && B;
                    break;*/
            }
        }
        this.setOutputData(0, result);
        this.setOutputData(1, !result);
    }

    static values = ["==", "!="]; // [">", "<", "==", "!=", "<=", ">=", "||", "&&" ];

    static "@OP" = {
        type: "enum",
        title: "operation",
        values: GenericCompare.values,
    };
}
LiteGraph.registerNodeType("basic/CompareValues", GenericCompare);


// Show value inside the debug console
class LogEvent {

    static title = "Log Event";
    static desc = "Log event in console";

    constructor() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
    }
    onAction(action, param, options, slot_index) {
        console.log("LogNode", action, param, options, slot_index);
    }
}
LiteGraph.registerNodeType("events/log", LogEvent);


// convert to Event if the value is true
class TriggerEvent {

    static title = "TriggerEvent";
    static desc = "Triggers event if input evaluates to true";

    constructor() {
        this.size = [60, 30];
        this.addInput("if", "");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
        this.properties = {
            only_on_change: true,
            tooltip: "Triggers event if input evaluates to true",
        };
        this.prev = 0;
    }

    onExecute(param, options) {
        var v = this.getInputData(0);
        var changed = v != this.prev;
        if (this.prev === 0) changed = false;
        var must_resend =
            (changed && this.properties.only_on_change) ||
            (!changed && !this.properties.only_on_change);
        if (v && must_resend) this.triggerSlot(0, param, null, options);
        if (!v && must_resend) this.triggerSlot(2, param, null, options);
        if (changed) this.triggerSlot(1, param, null, options);
        this.prev = v;
    }
}


LiteGraph.registerNodeType("events/trigger", TriggerEvent);

// Sequence of events
class EvSequence {

    static title = "Sequence";
    static desc = "Triggers a sequence of events when an event arrives";
    // @ BUG: fails to construct Node

    constructor() {
        var that = this;
        this.addInput("", LiteGraph.ACTION, {removable: true, nameLocked: false});
        this.addInput("", LiteGraph.ACTION, {removable: true, nameLocked: false});
        this.addInput("", LiteGraph.ACTION, {removable: true, nameLocked: false});
        this.addOutput("", LiteGraph.EVENT, {removable: true, nameLocked: false});
        this.addOutput("", LiteGraph.EVENT, {removable: true, nameLocked: false});
        this.addOutput("", LiteGraph.EVENT, {removable: true, nameLocked: false});
        this.addWidget("button", "+", null, function () {
            that.addInput("", LiteGraph.ACTION);
            that.addOutput("", LiteGraph.EVENT);
        });
        this.size = [90, 30];
        this.flags = { horizontal: true, render_box: false };
    }

    getTitle() {
        return "";
    }

    onAction(action, param, options) {
        if (this.outputs) {
            options = options || {};
            for (var i = 0; i < this.outputs.length; ++i) {
                // needs more info about this...
                if (options.action_call)
                    // CREATE A NEW ID FOR THE ACTION
                    options.action_call = options.action_call + "_seq_" + i;
                else
                    options.action_call =
                        this.id +
                        "_" +
                        (action ? action : "action") +
                        "_seq_" +
                        i +
                        "_" +
                        Math.floor(Math.random() * 9999);
                this.triggerSlot(i, param, null, options);
            }
        }
    }
}
LiteGraph.registerNodeType("events/sequence", EvSequence);


// Sequence of events
class WaitAll {

    static title = "WaitAll";
    static desc = "Wait until all input events arrive then triggers output";

    constructor() {
        var that = this;
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addOutput("", LiteGraph.EVENT);
        this.addWidget("button", "+", null, function () {
            that.addInput("", LiteGraph.ACTION);
            that.size[0] = 90;
        });
        this.size = [90, 70];
        this.ready = [];
    }

    getTitle() {
        return "";
    }

    onDrawBackground(ctx) {
        if (this.flags?.collapsed) {
            return;
        }
        for (var i = 0; i < this.inputs.length; ++i) {
            var y = i * LiteGraph.NODE_SLOT_HEIGHT + 10;
            ctx.fillStyle = this.ready[i] ? "#AFB" : "#000";
            ctx.fillRect(20, y, 10, 10);
        }
    }

    onAction(action, param, options, slot_index) {
        if (slot_index == null) return;

        // check all
        this.ready.length = this.outputs.length;
        this.ready[slot_index] = true;
        for (var i = 0; i < this.ready.length; ++i)
            if (!this.ready[i])
                return;
        // pass
        this.reset();
        this.triggerSlot(0);
    }

    reset() {
        this.ready.length = 0;
    }
}
LiteGraph.registerNodeType("events/waitAll", WaitAll);


// Sequencer for events
class Stepper {

    static title = "Stepper";
    static desc = "Trigger events sequentially when an tick arrives";

    constructor() {
        var that = this;
        this.properties = { index: 0 };
        this.addInput("index", "number");
        this.addInput("step", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("index", "number");
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT, { removable: true });
        this.addWidget("button", "+", null, function () {
            that.addOutput("", LiteGraph.EVENT, { removable: true });
        });
        this.size = [120, 120];
        this.flags = { render_box: false };
    }

    onDrawBackground(ctx) {
        if (this.flags?.collapsed) {
            return;
        }
        var index = this.properties.index || 0;
        ctx.fillStyle = "#AFB";
        var w = this.size[0];
        var y = (index + 1) * LiteGraph.NODE_SLOT_HEIGHT + 4;
        ctx.beginPath();
        ctx.moveTo(w - 30, y);
        ctx.lineTo(w - 30, y + LiteGraph.NODE_SLOT_HEIGHT);
        ctx.lineTo(w - 15, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);
        ctx.fill();
    }

    onExecute() {
        var index = this.getInputData(0);
        if (index != null) {
            index = Math.floor(index);
            index = LiteGraph.clamp(
                index,
                0,
                this.outputs ? this.outputs.length - 2 : 0,
            );
            if (index != this.properties.index) {
                this.properties.index = index;
                this.triggerSlot(index + 1);
            }
        }

        this.setOutputData(0, this.properties.index);
    }

    onAction(action, param) {
        if (action == "reset") this.properties.index = 0;
        else if (action == "step") {
            this.triggerSlot(this.properties.index + 1, param);
            var n = this.outputs ? this.outputs.length - 1 : 0;
            this.properties.index = (this.properties.index + 1) % n;
        }
    }
}
LiteGraph.registerNodeType("events/stepper", Stepper);

// Filter events
class FilterEvent {

    static title = "Filter Event";
    static desc = "Blocks events that do not match the filter";

    constructor() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("event", LiteGraph.EVENT);
        this.properties = {
            equal_to: "",
            has_property: "",
            property_equal_to: "",
        };
    }

    onAction(action, param, options) {
        if (param == null) {
            return;
        }

        if (this.properties.equal_to && this.properties.equal_to != param) {
            return;
        }

        if (this.properties.has_property) {
            var prop = param[this.properties.has_property];
            if (prop == null) {
                return;
            }

            if (
                this.properties.property_equal_to &&
                this.properties.property_equal_to != prop
            ) {
                return;
            }
        }

        this.triggerSlot(0, param, null, options);
    }
}
LiteGraph.registerNodeType("events/filter", FilterEvent);

class EventBranch {

    static title = "Branch";
    static desc = "If condition is true, outputs triggers true, otherwise false";

    constructor() {
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("cond", "boolean");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
        this.size = [120, 60];
        this._value = false;
    }

    onExecute() {
        this._value = this.getInputData(1);
    }

    onAction(action, param, options) {
        this._value = this.getInputData(1);
        this.triggerSlot(this._value ? 0 : 1, param, null, options);
    }
}
LiteGraph.registerNodeType("events/branch", EventBranch);


// Show value inside the debug console
class EventCounter {

    static title = "Counter";
    static desc = "Counts events";

    constructor() {
        this.addInput("inc", LiteGraph.ACTION);
        this.addInput("dec", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("num", "number");
        this.addProperty(
            "doCountExecution",
            false,
            "boolean",
            { name: "Count Executions" },
        );
        this.addWidget(
            "toggle",
            "Count Exec.",
            this.properties.doCountExecution,
            "doCountExecution",
        );
        this.num = 0;
    }

    getTitle() {
        if (this.flags?.collapsed) {
            return String(this.num);
        }
        return this.title;
    }

    onAction(action) {
        var v = this.num;
        if (action == "inc") {
            this.num += 1;
        } else if (action == "dec") {
            this.num -= 1;
        } else if (action == "reset") {
            this.num = 0;
        }
        this.setOutputData(1, this.num);
        if (this.num != v) {
            this.changed();
        }
    }

    changed(){
        this.trigger("change", this.num);
    }

    onDrawBackground(ctx) {
        if (this.flags?.collapsed) {
            return;
        }
        ctx.fillStyle = "#AAA";
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.num, this.size[0] * 0.5, this.size[1] * 0.5);
    }

    onExecute() {
        if (this.properties.doCountExecution) {
            this.num += 1;
            this.changed();
        }
        this.setOutputData(1, this.num);
    }
}
LiteGraph.registerNodeType("events/counter", EventCounter);


// Show value inside the debug console
class DelayEvent {

    static title = "Delay";
    static desc = "Delays one event";

    constructor() {
        this.size = [60, 30];
        this.addProperty("time_in_ms", 1000);
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("on_time", LiteGraph.EVENT);
        this._pending = [];
    }

    onAction(action, param, options) {
        var time = this.properties.time_in_ms;
        if (time <= 0) {
            this.trigger(null, param, options);
        } else {
            this._pending.push([time, param]);
        }
    }

    onExecute(param, options) {
        var dt = this.graph.elapsed_time * 1000; // in ms

        if (this.isInputConnected(1)) {
            this.properties.time_in_ms = this.getInputData(1);
        }

        for (var i = 0; i < this._pending.length; ++i) {
            var actionPass = this._pending[i];
            actionPass[0] -= dt;
            if (actionPass[0] > 0) {
                continue;
            }

            // remove
            this._pending.splice(i, 1);
            --i;

            // trigger
            this.trigger(null, actionPass[1], options);
        }
    }

    onGetInputs() {
        return [
            ["event", LiteGraph.ACTION],
            ["time_in_ms", "number"],
        ];
    }
}
LiteGraph.registerNodeType("events/delay", DelayEvent);


// Show value inside the debug console
class TimerEvent {

    static title = "Timer";
    static desc = "Sends an event every N milliseconds";

    constructor() {
        this.addProperty("interval", 1000);
        this.addProperty("event", "tick");
        this.addOutput("on_tick", LiteGraph.EVENT);
        this.time = 0;
        this.last_interval = 1000;
        this.triggered = false;
    }

    onStart() {
        this.time = 0;
    }

    getTitle() {
        return "Timer: " + this.last_interval.toString() + "ms";
    }

    onDrawBackground() {
        this.boxcolor = this.triggered ? TimerEvent.on_color : TimerEvent.off_color;
        this.triggered = false;
    }

    onExecute() {
        var dt = this.graph.elapsed_time * 1000; // in ms

        var trigger = this.time == 0;

        this.time += dt;
        this.last_interval = Math.max(1, this.getInputOrProperty("interval") | 0);

        if (
            !trigger &&
            (this.time < this.last_interval || isNaN(this.last_interval))
        ) {
            if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
                this.setOutputData(1, false);
            }
            return;
        }

        this.triggered = true;
        this.time = this.time % this.last_interval;
        this.trigger("on_tick", this.properties.event);
        if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
            this.setOutputData(1, true);
        }
    }

    onGetInputs() {
        return [["interval", "number"]];
    }

    onGetOutputs() {
        return [["tick", "boolean"]];
    }
}
TimerEvent.on_color = "#AAA";
TimerEvent.off_color = "#222";
LiteGraph.registerNodeType("events/timer", TimerEvent);


class SemaphoreEvent {

    static title = "Semaphore Event";
    static desc = "Until both events are not triggered, it doesnt continue.";

    constructor() {
        this.addInput("go", LiteGraph.ACTION);
        this.addInput("green", LiteGraph.ACTION);
        this.addInput("red", LiteGraph.ACTION);
        this.addOutput("continue", LiteGraph.EVENT);
        this.addOutput("blocked", LiteGraph.EVENT);
        this.addOutput("is_green", "boolean");
        this._ready = false;
        this.properties = {};
        var that = this;
        this.addWidget("button", "reset", "", function () {
            that._ready = false;
        });
    }

    onExecute() {
        this.setOutputData(1, this._ready);
        this.boxcolor = this._ready ? "#9F9" : "#FA5";
    }

    onAction(action) {
        if (action == "go") this.triggerSlot(this._ready ? 0 : 1);
        else if (action == "green") this._ready = true;
        else if (action == "red") this._ready = false;
    }
}
LiteGraph.registerNodeType("events/semaphore", SemaphoreEvent);


class OnceEvent {

    static title = "Once";
    static desc = "Only passes an event once, then gets locked";

    constructor() {
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("out", LiteGraph.EVENT);
        this._once = false;
        this.properties = {};
        var that = this;
        this.addWidget("button", "reset", "", function () {
            that._once = false;
        });
    }

    onAction(action, param) {
        if (action == "in" && !this._once) {
            this._once = true;
            this.triggerSlot(0, param);
        } else if (action == "reset") this._once = false;
    }
}
LiteGraph.registerNodeType("events/once", OnceEvent);


class DataStore {

    static title = "Data Store";
    static desc = "Stores data and only changes when event is received";

    constructor() {
        this.addInput("data", 0);
        this.addInput("assign", LiteGraph.ACTION);
        this.addOutput("data", 0);
        this._last_value = null;
        this.properties = { data: null, serialize: true };
        var that = this;
        this.addWidget("button", "store", "", function () {
            that.properties.data = that._last_value;
        });
    }

    onExecute() {
        this._last_value = this.getInputData(0);
        this.setOutputData(0, this.properties.data);
    }

    onAction() {
        this.properties.data = this._last_value;
    }

    onSerialize(o) {
        if (o.data == null) return;
        if (
            !this.properties.serialize ||
            (o.data.constructor !== String &&
                o.data.constructor !== Number &&
                o.data.constructor !== Boolean &&
                o.data.constructor !== Array &&
                o.data.constructor !== Object)
        )
            o.data = null;
    }
}
LiteGraph.registerNodeType("basic/data_store", DataStore);


class WidgetButton {

    static title = "Button";
    static desc = "Triggers an event";

    constructor() {
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", "boolean");
        this.addProperty("text", "DO");
        this.addProperty("font_size", 30);
        this.addProperty("message", "");
        this.size = [84, 84];
        this.clicked = false;
    }

    onDrawForeground(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        var margin = 10;
        ctx.fillStyle = "black";
        ctx.fillRect(
            margin + 1,
            margin + 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2,
        );
        ctx.fillStyle = "#AAF";
        ctx.fillRect(
            margin - 1,
            margin - 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2,
        );
        ctx.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334";
        ctx.fillRect(
            margin,
            margin,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2,
        );

        if (this.properties.text || this.properties.text === 0) {
            var font_size = this.properties.font_size || 30;
            ctx.textAlign = "center";
            ctx.fillStyle = this.clicked ? "black" : "white";
            ctx.font = font_size + "px " + WidgetButton.font;
            ctx.fillText(
                this.properties.text,
                this.size[0] * 0.5,
                this.size[1] * 0.5 + font_size * 0.3,
            );
            ctx.textAlign = "left";
        }
    }

    onMouseDown(e, local_pos) {
        console.warn("DBG","WidgetButton","onMouseDown",this);
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            LiteGraph.log_info("WidgetButton","clicked inside");
            this.clicked = true;
            this.setOutputData(1, this.clicked);
            this.triggerSlot(0, this.properties.message);
            return true;
        }else{
            LiteGraph.log_info("WidgetButton","clicked outside");
        }
    }

    onExecute() {
        this.setOutputData(1, this.clicked);
    }

    onMouseUp(_e) {
        this.clicked = false;
        LiteGraph.log_info("WidgetButton","mouse up");
    }

    static font = "Arial";
}
LiteGraph.registerNodeType("widget/button", WidgetButton);


class WidgetToggle {

    static title = "Toggle";
    static desc = "Toggles between true or false";

    constructor() {
        this.addInput("", "boolean");
        this.addInput("e", LiteGraph.ACTION);
        this.addOutput("v", "boolean");
        this.addOutput("e", LiteGraph.EVENT);
        this.properties = { font: "", value: false };
        this.size = [160, 44];
    }

    onDrawForeground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size[1] * 0.5;
        var margin = 0.25;
        var h = this.size[1] * 0.8;
        ctx.font = this.properties.font || (size * 0.8).toFixed(0) + "px Arial";
        var w = ctx.measureText(this.title).width;
        var x = (this.size[0] - (w + size)) * 0.5;

        ctx.fillStyle = "#AAA";
        ctx.fillRect(x, h - size, size, size);

        ctx.fillStyle = this.properties.value ? "#AEF" : "#000";
        ctx.fillRect(
            x + size * margin,
            h - size + size * margin,
            size * (1 - margin * 2),
            size * (1 - margin * 2),
        );

        ctx.textAlign = "left";
        ctx.fillStyle = "#AAA";
        ctx.fillText(this.title, size * 1.2 + x, h * 0.85);
        ctx.textAlign = "left";
    }

    onAction(_action) {
        this.properties.value = !this.properties.value;
        this.trigger("e", this.properties.value);
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties.value = v;
        }
        this.setOutputData(0, this.properties.value);
    }

    onMouseDown(e, local_pos) {
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            this.properties.value = !this.properties.value;
            this.graph._version++;
            this.trigger("e", this.properties.value);
            return true;
        }
    }
}
LiteGraph.registerNodeType("widget/toggle", WidgetToggle);


class WidgetNumber {

    static title = "Number";
    static desc = "Widget to select number value";

    constructor() {
        this.addOutput("", "number");
        this.size = [80, 60];
        this.properties = { min: -1000, max: 1000, value: 1, step: 1 };
        this.old_y = -1;
        this._remainder = 0;
        this._precision = 0;
        this.mouse_captured = false;
    }

    onDrawForeground(ctx) {
        var x = this.size[0] * 0.5;
        var h = this.size[1];
        if (h > 30) {
            ctx.fillStyle = WidgetNumber.markers_color;
            ctx.beginPath();
            ctx.moveTo(x, h * 0.1);
            ctx.lineTo(x + h * 0.1, h * 0.2);
            ctx.lineTo(x + h * -0.1, h * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x, h * 0.9);
            ctx.lineTo(x + h * 0.1, h * 0.8);
            ctx.lineTo(x + h * -0.1, h * 0.8);
            ctx.fill();
            ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        } else {
            ctx.font = (h * 0.8).toFixed(1) + "px Arial";
        }

        ctx.textAlign = "center";
        ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        ctx.fillStyle = "#EEE";
        ctx.fillText(this.properties.value.toFixed(this._precision), x, h * 0.75);
    }

    onExecute() {
        this.setOutputData(0, this.properties.value);
    }

    onPropertyChanged(_name, _value) {
        var t = (this.properties.step + "").split(".");
        this._precision = t.length > 1 ? t[1].length : 0;
    }

    onMouseDown(e, pos) {
        if (pos[1] < 0) {
            return;
        }

        this.old_y = e.canvasY;
        this.captureInput(true);
        this.mouse_captured = true;

        return true;
    }

    onDblClick(e, pos, canvas){ 
        console.warn("onDblClick", ...arguments);
        // NO, this is for title, etc.: canvas.doShowNodeInfoEditor(this, this.getPropertyInfo("value"), e);
        // NO, this is to open the whole parameter list: doShowMenuNodeProperties
        canvas.showEditPropertyValue(this, "value", { event: e/* position: pos */ });
        this.prevent_up = true;
        e.preventDefault();
        e.stopPropagation();
        return true;
    }

    onMouseMove(e) {
        if (!this.mouse_captured) {
            return;
        }

        var delta = this.old_y - e.canvasY;
        if (e.shiftKey) {
            delta *= 10;
        }
        if (e.metaKey || e.altKey) {
            delta *= 0.1;
        }
        this.old_y = e.canvasY;

        var steps = this._remainder + delta / WidgetNumber.pixels_threshold;
        this._remainder = steps % 1;
        steps = steps | 0;

        var v = LiteGraph.clamp(
            this.properties.value + steps * this.properties.step,
            this.properties.min,
            this.properties.max,
        );
        this.properties.value = v;
        this.graph._version++;
        this.setDirtyCanvas(true);
    }

    onMouseUp(e, pos) {
        if(this.prevent_up){
            this.prevent_up = false;
            return;
        }
        if (e.click_time < 200) {
            var steps = pos[1] > this.size[1] * 0.5 ? -1 : 1;
            // TOOD use setProperty
            this.properties.value = LiteGraph.clamp(
                this.properties.value + steps * this.properties.step,
                this.properties.min,
                this.properties.max,
            );
            this.graph._version++;
            this.setDirtyCanvas(true);
        }

        if (this.mouse_captured) {
            this.mouse_captured = false;
            this.captureInput(false);
        }
    }
    static pixels_threshold = 10;
    static markers_color = "#666";
}
LiteGraph.registerNodeType("widget/number", WidgetNumber);

/* Combo ****************/

class WidgetCombo {

    static title = "Combo";
    static desc = "Widget to select from a list";

    constructor() {
        this.addOutput("", "string");
        this.addOutput("change", LiteGraph.EVENT);
        this.size = [80, 60];
        this.properties = { value: "A", values: "A;B;C" };
        this.old_y = -1;
        this.mouse_captured = false;
        this._values = this.properties.values.split(";");
        var that = this;
        this.widgets_up = true;
        this.widget = this.addWidget(
            "combo",
            "",
            this.properties.value,
            function (v) {
                that.properties.value = v;
                that.triggerSlot(1, v);
            },
            { property: "value", values: this._values },
        );
    }

    onExecute() {
        this.setOutputData(0, this.properties.value);
    }

    onPropertyChanged(name, value) {
        if (name == "values") {
            this._values = value.split(";");
            this.widget.options.values = this._values;
        } else if (name == "value") {
            this.widget.value = value;
        }
    }
}
LiteGraph.registerNodeType("widget/combo", WidgetCombo);


class WidgetKnob {

    static title = "Knob";
    static desc = "Circular controller";
    static size = [80, 100];

    constructor() {
        this.addOutput("", "number");
        this.size = [64, 84];
        this.properties = {
            min: 0,
            max: 1,
            value: 0.5,
            color: "#7AF",
            precision: 2,
        };
        this.value = -1;
    }

    onDrawForeground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        var center_x = this.size[0] * 0.5;
        var center_y = this.size[1] * 0.5;
        var radius = Math.min(this.size[0], this.size[1]) * 0.5 - 5;
        // var w = Math.floor(radius * 0.05); //@BUG: unused variable, test without

        ctx.globalAlpha = 1;
        ctx.save();
        ctx.translate(center_x, center_y);
        ctx.rotate(Math.PI * 0.75);

        // bg
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, 0, Math.PI * 1.5);
        ctx.fill();

        // value
        ctx.strokeStyle = "black";
        ctx.fillStyle = this.properties.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius - 4, 0, Math.PI * 1.5 * Math.max(0.01, this.value));
        ctx.closePath();
        ctx.fill();
        // ctx.stroke();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1;
        ctx.restore();

        // inner
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(center_x, center_y, radius * 0.75, 0, Math.PI * 2, true);
        ctx.fill();

        // miniball
        ctx.fillStyle = this.mouseOver ? "white" : this.properties.color;
        ctx.beginPath();
        var angle = this.value * Math.PI * 1.5 + Math.PI * 0.75;
        ctx.arc(
            center_x + Math.cos(angle) * radius * 0.65,
            center_y + Math.sin(angle) * radius * 0.65,
            radius * 0.05,
            0,
            Math.PI * 2,
            true,
        );
        ctx.fill();

        // text
        ctx.fillStyle = this.mouseOver ? "white" : "#AAA";
        ctx.font = Math.floor(radius * 0.5) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.value.toFixed(this.properties.precision),
            center_x,
            center_y + radius * 0.15,
        );
    }

    onExecute() {
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value,
        ]);
    }

    onMouseDown(e) {
        this.center = [this.size[0] * 0.5, this.size[1] * 0.5 + 20];
        this.radius = this.size[0] * 0.5;
        if (
            e.canvasY - this.pos[1] < 20 ||
            LiteGraph.distance(
                [e.canvasX, e.canvasY],
                [this.pos[0] + this.center[0], this.pos[1] + this.center[1]],
            ) > this.radius
        ) {
            return false;
        }
        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    }

    onMouseMove(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        v -= (m[1] - this.oldmouse[1]) * 0.01;
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }
        this.value = v;
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.oldmouse = m;
        this.setDirtyCanvas(true);
    }

    onMouseUp(_e) {
        if (this.oldmouse) {
            this.oldmouse = null;
            this.captureInput(false);
        }
    }

    onPropertyChanged(name, value) {
        if (name == "min" || name == "max" || name == "value") {
            this.properties[name] = parseFloat(value);
            return true; // block
        }
    }
}
LiteGraph.registerNodeType("widget/knob", WidgetKnob);


// Show value inside the debug console
class WidgetSliderGUI {

    static title = "Inner Slider";

    constructor() {
        this.addOutput("", "number");
        this.properties = {
            value: 0.5,
            min: 0,
            max: 1,
            text: "V",
        };
        var that = this;
        this.size = [140, 40];
        this.slider = this.addWidget(
            "slider",
            "V",
            this.properties.value,
            function (v) {
                that.properties.value = v;
            },
            this.properties,
        );
        this.widgets_up = true;
    }

    onPropertyChanged(name, value) {
        if (name == "value") {
            this.slider.value = value;
        }
    }

    onExecute() {
        this.setOutputData(0, this.properties.value);
    }
}
LiteGraph.registerNodeType("widget/internal_slider", WidgetSliderGUI);


// Widget H SLIDER
class WidgetHSlider {

    static title = "H.Slider";
    static desc = "Linear slider controller";

    constructor() {
        this.size = [160, 26];
        this.addOutput("", "number");
        this.properties = { color: "#7AF", min: 0, max: 1, value: 0.5 };
        this.value = -1;
    }

    onDrawForeground(ctx) {
        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        // border
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.fillStyle = "#000";
        ctx.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);

        ctx.fillStyle = this.properties.color;
        ctx.beginPath();
        ctx.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);
        ctx.fill();
    }

    onExecute() {
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value,
        ]);
    }

    onMouseDown(e) {
        if (e.canvasY - this.pos[1] < 0) {
            return false;
        }

        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    }

    onMouseMove(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        var delta = m[0] - this.oldmouse[0];
        v += delta / this.size[0];
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }

        this.value = v;

        this.oldmouse = m;
        this.setDirtyCanvas(true);
    }

    onMouseUp(_e) {
        this.oldmouse = null;
        this.captureInput(false);
    }
}
LiteGraph.registerNodeType("widget/hslider", WidgetHSlider);


class WidgetProgress {

    static title = "Progress";
    static desc = "Shows data in linear progress";

    constructor() {
        this.size = [160, 26];
        this.addInput("", "number");
        this.properties = { min: 0, max: 1, value: 0, color: "#AAF" };
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v != undefined) {
            this.properties["value"] = v;
        }
    }

    onDrawForeground(ctx) {
        // border
        ctx.lineWidth = 1;
        ctx.fillStyle = this.properties.color;
        var v =
            (this.properties.value - this.properties.min) /
            (this.properties.max - this.properties.min);
        v = Math.min(1, v);
        v = Math.max(0, v);
        ctx.fillRect(2, 2, (this.size[0] - 4) * v, this.size[1] - 4);
    }
}
LiteGraph.registerNodeType("widget/progress", WidgetProgress);


class WidgetText {

    static title = "Text";
    static desc = "Shows the input value";
    // @BUG: Will draw text straight off the node with no wrapping

    constructor() {
        this.addInputs("", 0);
        this.properties = {
            value: "...",
            font: "Arial",
            fontsize: 18,
            color: "#AAA",
            align: "left",
            glowSize: 0,
            decimals: 1,
        };
    }

    onDrawForeground(ctx) {
        // ctx.fillStyle="#000";
        // ctx.fillRect(0,0,100,60);
        ctx.fillStyle = this.properties["color"];
        var v = this.properties["value"];

        if (this.properties["glowSize"]) {
            ctx.shadowColor = this.properties.color;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["glowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        var fontsize = this.properties["fontsize"];

        ctx.textAlign = this.properties["align"];
        ctx.font = fontsize.toString() + "px " + this.properties["font"];
        this.str =
            typeof v == "number" ? v.toFixed(this.properties["decimals"]) : v;

        if (typeof this.str == "string") {
            var lines = this.str.replace(/[\r\n]/g, "\\n").split("\\n");
            for (var i = 0; i < lines.length; i++) {
                ctx.fillText(
                    lines[i],
                    this.properties["align"] == "left" ? 15 : this.size[0] - 15,
                    fontsize * -0.15 + fontsize * (parseInt(i) + 1),
                );
            }
        }

        ctx.shadowColor = "transparent";
        this.last_ctx = ctx;
        ctx.textAlign = "left";
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties["value"] = v;
        }
        // this.setDirtyCanvas(true);
    }

    resize() {
        if (!this.last_ctx) {
            return;
        }

        var lines = this.str.split("\\n");
        this.last_ctx.font =
            this.properties["fontsize"] + "px " + this.properties["font"];
        var max = 0;
        for (var i = 0; i < lines.length; i++) {
            var w = this.last_ctx.measureText(lines[i]).width;
            if (max < w) {
                max = w;
            }
        }
        this.size[0] = max + 20;
        this.size[1] = 4 + lines.length * this.properties["fontsize"];

        this.setDirtyCanvas(true);
    }

    onPropertyChanged(name, value) {
        this.properties[name] = value;
        this.str = typeof value == "number" ? value.toFixed(3) : value;
        // this.resize();
        return true;
    }

    static widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "led_text", text: "LED", type: "minibutton" },
        { name: "normal_text", text: "Normal", type: "minibutton" },
    ];
}
LiteGraph.registerNodeType("widget/text", WidgetText);


class WidgetPanel {

    static title = "Panel";
    static desc = "Non interactive panel";

    constructor() {
        this.size = [200, 100];
        this.properties = {
            borderColor: "#ffffff",
            bgcolorTop: "#f0f0f0",
            bgcolorBottom: "#e0e0e0",
            shadowSize: 2,
            borderRadius: 3,
        };
    }

    createGradient(ctx) {
        if (
            this.properties["bgcolorTop"] == "" ||
            this.properties["bgcolorBottom"] == ""
        ) {
            this.lineargradient = 0;
            return;
        }

        this.lineargradient = ctx.createLinearGradient(0, 0, 0, this.size[1]);
        this.lineargradient.addColorStop(0, this.properties["bgcolorTop"]);
        this.lineargradient.addColorStop(1, this.properties["bgcolorBottom"]);
    }

    onDrawForeground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.lineargradient == null) {
            this.createGradient(ctx);
        }

        if (!this.lineargradient) {
            return;
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = this.properties["borderColor"];
        // ctx.fillStyle = "#ebebeb";
        ctx.fillStyle = this.lineargradient;

        if (this.properties["shadowSize"]) {
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["shadowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        ctx.roundRect(
            0,
            0,
            this.size[0] - 1,
            this.size[1] - 1,
            this.properties["shadowSize"],
        );
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.stroke();
    }
    widgets = [{ name: "update", text: "Update", type: "button" }];
}
LiteGraph.registerNodeType("widget/panel", WidgetPanel);


class GamepadInput {

    static title = "Gamepad";
    static desc = "gets the input of the gamepad";

    constructor() {
        this.addOutput("left_x_axis", "number");
        this.addOutput("left_y_axis", "number");
        this.addOutput("button_pressed", LiteGraph.EVENT);
        this.properties = { gamepad_index: 0, threshold: 0.1 };

        this._left_axis = new Float32Array(2);
        this._right_axis = new Float32Array(2);
        this._triggers = new Float32Array(2);
        this._previous_buttons = new Uint8Array(17);
        this._current_buttons = new Uint8Array(17);
    }

    onExecute() {
        // get gamepad
        var gamepad = this.getGamepad();
        var threshold = this.properties.threshold || 0.0;

        if (gamepad) {
            this._left_axis[0] =
                Math.abs(gamepad.xbox.axes["lx"]) > threshold
                    ? gamepad.xbox.axes["lx"]
                    : 0;
            this._left_axis[1] =
                Math.abs(gamepad.xbox.axes["ly"]) > threshold
                    ? gamepad.xbox.axes["ly"]
                    : 0;
            this._right_axis[0] =
                Math.abs(gamepad.xbox.axes["rx"]) > threshold
                    ? gamepad.xbox.axes["rx"]
                    : 0;
            this._right_axis[1] =
                Math.abs(gamepad.xbox.axes["ry"]) > threshold
                    ? gamepad.xbox.axes["ry"]
                    : 0;
            this._triggers[0] =
                Math.abs(gamepad.xbox.axes["ltrigger"]) > threshold
                    ? gamepad.xbox.axes["ltrigger"]
                    : 0;
            this._triggers[1] =
                Math.abs(gamepad.xbox.axes["rtrigger"]) > threshold
                    ? gamepad.xbox.axes["rtrigger"]
                    : 0;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }
                var v = null;

                if (gamepad) {
                    switch (output.name) {
                        case "left_axis":
                            v = this._left_axis;
                            break;
                        case "right_axis":
                            v = this._right_axis;
                            break;
                        case "left_x_axis":
                            v = this._left_axis[0];
                            break;
                        case "left_y_axis":
                            v = this._left_axis[1];
                            break;
                        case "right_x_axis":
                            v = this._right_axis[0];
                            break;
                        case "right_y_axis":
                            v = this._right_axis[1];
                            break;
                        case "trigger_left":
                            v = this._triggers[0];
                            break;
                        case "trigger_right":
                            v = this._triggers[1];
                            break;
                        case "a_button":
                            v = gamepad.xbox.buttons["a"] ? 1 : 0;
                            break;
                        case "b_button":
                            v = gamepad.xbox.buttons["b"] ? 1 : 0;
                            break;
                        case "x_button":
                            v = gamepad.xbox.buttons["x"] ? 1 : 0;
                            break;
                        case "y_button":
                            v = gamepad.xbox.buttons["y"] ? 1 : 0;
                            break;
                        case "lb_button":
                            v = gamepad.xbox.buttons["lb"] ? 1 : 0;
                            break;
                        case "rb_button":
                            v = gamepad.xbox.buttons["rb"] ? 1 : 0;
                            break;
                        case "ls_button":
                            v = gamepad.xbox.buttons["ls"] ? 1 : 0;
                            break;
                        case "rs_button":
                            v = gamepad.xbox.buttons["rs"] ? 1 : 0;
                            break;
                        case "hat_left":
                            v = gamepad.xbox.hatmap & GamepadInput.LEFT;
                            break;
                        case "hat_right":
                            v = gamepad.xbox.hatmap & GamepadInput.RIGHT;
                            break;
                        case "hat_up":
                            v = gamepad.xbox.hatmap & GamepadInput.UP;
                            break;
                        case "hat_down":
                            v = gamepad.xbox.hatmap & GamepadInput.DOWN;
                            break;
                        case "hat":
                            v = gamepad.xbox.hatmap;
                            break;
                        case "start_button":
                            v = gamepad.xbox.buttons["start"] ? 1 : 0;
                            break;
                        case "back_button":
                            v = gamepad.xbox.buttons["back"] ? 1 : 0;
                            break;
                        case "button_pressed":
                            for (var j = 0; j < this._current_buttons.length; ++j) {
                                if (
                                    this._current_buttons[j] &&
                                    !this._previous_buttons[j]
                                ) {
                                    this.triggerSlot(i, GamepadInput.buttons[j]);
                                }
                            }
                            break;
                        default:
                            break;
                    }
                } else {
                    // if no gamepad is connected, output 0
                    switch (output.name) {
                        case "button_pressed":
                            break;
                        case "left_axis":
                        case "right_axis":
                            v = GamepadInput.zero;
                            break;
                        default:
                            v = 0;
                    }
                }
                this.setOutputData(i, v);
            }
        }
    }

    getGamepad() {
        var getGamepads =
            navigator.getGamepads ||
            navigator.webkitGetGamepads ||
            navigator.mozGetGamepads;
        if (!getGamepads) {
            return null;
        }
        var gamepads = getGamepads.call(navigator);
        var gamepad = null;

        this._previous_buttons.set(this._current_buttons);

        // pick the first connected
        for (var i = this.properties.gamepad_index; i < 4; i++) {
            if (!gamepads[i]) {
                continue;
            }
            gamepad = gamepads[i];

            // xbox controller mapping
            var xbox = this.xbox_mapping;
            if (!xbox) {
                xbox = this.xbox_mapping = {
                    axes: [],
                    buttons: {},
                    hat: "",
                    hatmap: GamepadInput.CENTER,
                };
            }

            xbox.axes["lx"] = gamepad.axes[0];
            xbox.axes["ly"] = gamepad.axes[1];
            xbox.axes["rx"] = gamepad.axes[2];
            xbox.axes["ry"] = gamepad.axes[3];
            xbox.axes["ltrigger"] = gamepad.buttons[6].value;
            xbox.axes["rtrigger"] = gamepad.buttons[7].value;
            xbox.hat = "";
            xbox.hatmap = GamepadInput.CENTER;

            for (var j = 0; j < gamepad.buttons.length; j++) {
                this._current_buttons[j] = gamepad.buttons[j].pressed;

                if (j < 12) {
                    xbox.buttons[GamepadInput.mapping_array[j]] =
                        gamepad.buttons[j].pressed;
                    if (gamepad.buttons[j].was_pressed)
                        this.trigger(GamepadInput.mapping_array[j] + "_button_event");
                } else { // mapping of XBOX
                    switch (
                        j // I use a switch to ensure that a player with another gamepad could play
                    ) {
                        case 12:
                            if (gamepad.buttons[j].pressed) {
                                xbox.hat += "up";
                                xbox.hatmap |= GamepadInput.UP;
                            }
                            break;
                        case 13:
                            if (gamepad.buttons[j].pressed) {
                                xbox.hat += "down";
                                xbox.hatmap |= GamepadInput.DOWN;
                            }
                            break;
                        case 14:
                            if (gamepad.buttons[j].pressed) {
                                xbox.hat += "left";
                                xbox.hatmap |= GamepadInput.LEFT;
                            }
                            break;
                        case 15:
                            if (gamepad.buttons[j].pressed) {
                                xbox.hat += "right";
                                xbox.hatmap |= GamepadInput.RIGHT;
                            }
                            break;
                        case 16:
                            xbox.buttons["home"] = gamepad.buttons[j].pressed;
                            break;
                        default:
                    }
                }
            }
            gamepad.xbox = xbox;
            return gamepad;
        }
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        // render gamepad state?
        var la = this._left_axis;
        var ra = this._right_axis;
        ctx.strokeStyle = "#88A";
        ctx.strokeRect(
            (la[0] + 1) * 0.5 * this.size[0] - 4,
            (la[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8,
        );
        ctx.strokeStyle = "#8A8";
        ctx.strokeRect(
            (ra[0] + 1) * 0.5 * this.size[0] - 4,
            (ra[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8,
        );
        var h = this.size[1] / this._current_buttons.length;
        ctx.fillStyle = "#AEB";
        for (var i = 0; i < this._current_buttons.length; ++i) {
            if (this._current_buttons[i]) {
                ctx.fillRect(0, h * i, 6, h);
            }
        }
    }

    onGetOutputs() {
        return [
            ["left_axis", "vec2"],
            ["right_axis", "vec2"],
            ["left_x_axis", "number"],
            ["left_y_axis", "number"],
            ["right_x_axis", "number"],
            ["right_y_axis", "number"],
            ["trigger_left", "number"],
            ["trigger_right", "number"],
            ["a_button", "number"],
            ["b_button", "number"],
            ["x_button", "number"],
            ["y_button", "number"],
            ["lb_button", "number"],
            ["rb_button", "number"],
            ["ls_button", "number"],
            ["rs_button", "number"],
            ["start_button", "number"],
            ["back_button", "number"],
            ["a_button_event", LiteGraph.EVENT],
            ["b_button_event", LiteGraph.EVENT],
            ["x_button_event", LiteGraph.EVENT],
            ["y_button_event", LiteGraph.EVENT],
            ["lb_button_event", LiteGraph.EVENT],
            ["rb_button_event", LiteGraph.EVENT],
            ["ls_button_event", LiteGraph.EVENT],
            ["rs_button_event", LiteGraph.EVENT],
            ["start_button_event", LiteGraph.EVENT],
            ["back_button_event", LiteGraph.EVENT],
            ["hat_left", "number"],
            ["hat_right", "number"],
            ["hat_up", "number"],
            ["hat_down", "number"],
            ["hat", "number"],
            ["button_pressed", LiteGraph.EVENT],
        ];
    }

    static zero = new Float32Array(2);
    static buttons = [
        "a",
        "b",
        "x",
        "y",
        "lb",
        "rb",
        "lt",
        "rt",
        "back",
        "start",
        "ls",
        "rs",
        "home",
    ];

    static mapping = {
        a: 0,
        b: 1,
        x: 2,
        y: 3,
        lb: 4,
        rb: 5,
        lt: 6,
        rt: 7,
        back: 8,
        start: 9,
        ls: 10,
        rs: 11,
    };

    static mapping_array = [
        "a",
        "b",
        "x",
        "y",
        "lb",
        "rb",
        "lt",
        "rt",
        "back",
        "start",
        "ls",
        "rs",
    ];
}

// @TODO: Enums
GamepadInput.CENTER = 0;
GamepadInput.LEFT = 1;
GamepadInput.RIGHT = 2;
GamepadInput.UP = 4;
GamepadInput.DOWN = 8;

LiteGraph.registerNodeType("input/gamepad", GamepadInput);


// Converter
class Converter {

    static title = "Converter";
    static desc = "type A to type B";

    constructor() {
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.size = [80, 30];
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }

                var result = null;
                switch (output.name) {
                    case "number":
                        result = v.length ? v[0] : parseFloat(v);
                        break;
                    case "vec2":
                    case "vec3":
                    case "vec4":
                        result = null;
                        var count = 1;
                        switch (output.name) {
                            case "vec2":
                                count = 2;
                                break;
                            case "vec3":
                                count = 3;
                                break;
                            case "vec4":
                                count = 4;
                                break;
                        }

                        result = new Float32Array(count);
                        if (v.length) {
                            for (
                                var j = 0;
                                j < v.length && j < result.length;
                                j++
                            ) {
                                result[j] = v[j];
                            }
                        } else {
                            result[0] = parseFloat(v);
                        }
                        break;
                }
                this.setOutputData(i, result);
            }
        }
    }

    onGetOutputs() {
        return [
            ["number", "number"],
            ["vec2", "vec2"],
            ["vec3", "vec3"],
            ["vec4", "vec4"],
        ];
    }
}
LiteGraph.registerNodeType("math/converter", Converter);


// Bypass
class Bypass {

    static title = "Bypass";
    static desc = "removes the type";

    constructor() {
        this.addInput("in");
        this.addOutput("out");
        this.size = [80, 30];
    }

    onExecute() {
        var v = this.getInputData(0);
        this.setOutputData(0, v);
    }
}
LiteGraph.registerNodeType("math/bypass", Bypass);


class ToNumber {

    static title = "to Number";
    static desc = "Cast to number";

    constructor() {
        this.addInput("in");
        this.addOutput("out");
    }

    onExecute() {
        var v = this.getInputData(0);
        this.setOutputData(0, Number(v));
    }
}
LiteGraph.registerNodeType("math/to_number", ToNumber);


class MathRange {

    static title = "Range";
    static desc = "Convert a number from one range to another";

    constructor() {
        this.addInput("in", "number", { locked: true });
        this.addOutput("out", "number", { locked: true });
        this.addOutput("clamped", "number", { locked: true });

        this.addProperty("in", 0);
        this.addProperty("in_min", 0);
        this.addProperty("in_max", 1);
        this.addProperty("out_min", 0);
        this.addProperty("out_max", 1);

        this.size = [120, 50];
    }

    getTitle() {
        if (this.flags?.collapsed) {
            return (this._last_v || 0).toFixed(2);
        }
        return this.title;
    }

    onExecute() {
        let v;
        if (this.inputs) {
            for (let i = 0; i < this.inputs.length; i++) {
                let input = this.inputs[i];
                v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        v = this.properties["in"];
        if (v === undefined || v === null || v.constructor !== Number) {
            v = 0;
        }

        var in_min = this.properties.in_min;
        var in_max = this.properties.in_max;
        var out_min = this.properties.out_min;
        var out_max = this.properties.out_max;
        /*
        if( in_min > in_max )
        {
            in_min = in_max;
            in_max = this.properties.in_min;
        }
        if( out_min > out_max )
        {
            out_min = out_max;
            out_max = this.properties.out_min;
        }
        */

        this._last_v =
            ((v - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;
        this.setOutputData(0, this._last_v);
        this.setOutputData(1, LiteGraph.clamp(this._last_v, out_min, out_max));
    }

    onDrawBackground(_ctx) {
        // show the current value
        if (this._last_v) {
            this.outputs[0].label = this._last_v.toFixed(3);
        } else {
            this.outputs[0].label = "?";
        }
    }

    onGetInputs() {
        return [
            ["in_min", "number"],
            ["in_max", "number"],
            ["out_min", "number"],
            ["out_max", "number"],
        ];
    }
}
LiteGraph.registerNodeType("math/range", MathRange);


class MathRand {

    static title = "Rand";
    static desc = "Random number";

    constructor() {
        this.addOutput("value", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.size = [80, 30];
    }

    onExecute() {
        
        // CHECK THIS, simple mixed inputOrProperty
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = Math.random() * (max - min) + min;
        this.setOutputData(0, this._last_v);
    }

    onDrawBackground(_ctx) {
        // show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    }

    onGetInputs() {
        return [
            ["min", "number"],
            ["max", "number"],
        ];
    }
}
LiteGraph.registerNodeType("math/rand", MathRand);


// basic continuous noise
class MathNoise {

    static title = "Noise";
    static desc = "Random number with temporal continuity";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.addProperty("smooth", true);
        this.addProperty("seed", 0);
        this.addProperty("octaves", 1);
        this.addProperty("persistence", 0.8);
        this.addProperty("speed", 1);
        this.size = [90, 30];
    }

    static getValue(f, smooth) {
        if (!MathNoise.data) {
            MathNoise.data = new Float32Array(1024);
            for (var i = 0; i < MathNoise.data.length; ++i) {
                MathNoise.data[i] = Math.random();
            }
        }
        f = f % 1024;
        if (f < 0) {
            f += 1024;
        }
        var f_min = Math.floor(f);
        f -= f_min;
        var r1 = MathNoise.data[f_min];
        var r2 = MathNoise.data[f_min == 1023 ? 0 : f_min + 1];
        if (smooth) {
            f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        }
        return r1 * (1 - f) + r2 * f;
    }

    onExecute() {
        var f = this.getInputData(0) || 0;
        var iterations = this.properties.octaves || 1;
        var r = 0;
        var amp = 1;
        var seed = this.properties.seed || 0;
        f += seed;
        var speed = this.properties.speed || 1;
        var total_amp = 0;
        for (var i = 0; i < iterations; ++i) {
            r +=
                MathNoise.getValue(f * (1 + i) * speed, this.properties.smooth) *
                amp;
            total_amp += amp;
            amp *= this.properties.persistence;
            if (amp < 0.001) break;
        }
        r /= total_amp;
        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = r * (max - min) + min;
        this.setOutputData(0, this._last_v);
    }

    onDrawBackground(_ctx) {
        // show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    }

    static data = null;
}
LiteGraph.registerNodeType("math/noise", MathNoise);


// generates spikes every random time
class MathSpikes {
    constructor() {
        this.addOutput("out", "number");
        this.addProperty("min_time", 1);
        this.addProperty("max_time", 2);
        this.addProperty("duration", 0.2);
        this.size = [90, 30];
        this._remaining_time = 0;
        this._blink_time = 0;
    }

    onExecute() {
        var dt = this.graph.elapsed_time; // in secs

        this._remaining_time -= dt;
        this._blink_time -= dt;

        var v = 0;
        if (this._blink_time > 0) {
            var f = this._blink_time / this.properties.duration;
            v = 1 / (Math.pow(f * 8 - 4, 4) + 1);
        }

        if (this._remaining_time < 0) {
            this._remaining_time =
                Math.random() *
                    (this.properties.max_time - this.properties.min_time) +
                this.properties.min_time;
            this._blink_time = this.properties.duration;
            this.boxcolor = "#FFF";
        } else {
            this.boxcolor = "#000";
        }
        this.setOutputData(0, v);
    }
}
LiteGraph.registerNodeType("math/spikes", MathSpikes);


// Math clamp
class MathClamp {

    static title = "Clamp";
    static desc = "Clamp number between min and max";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("min", 0);
        this.addProperty("max", 1);
    }

    // MathClamp.filter = "shader";

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        v = Math.max(this.properties.min, v);
        v = Math.min(this.properties.max, v);
        this.setOutputData(0, v);
    }

    getCode() {
        var code = "";
        if (this.isInputConnected(0)) {
            code +=
                "clamp({{0}}," +
                this.properties.min +
                "," +
                this.properties.max +
                ")";
        }
        return code;
    }
}
LiteGraph.registerNodeType("math/clamp", MathClamp);


class MathLerp {

    static title = "Lerp";
    static desc = "Linear Interpolation";

    constructor() {
        this.properties = { f: 0.5 };
        this.addInput("A", "number");
        this.addInput("B", "number");

        this.addOutput("out", "number");
    }

    onExecute() {
        var v1 = this.getInputData(0);
        if (v1 == null) {
            v1 = 0;
        }
        var v2 = this.getInputData(1);
        if (v2 == null) {
            v2 = 0;
        }

        var f = this.properties.f;

        var _f = this.getInputData(2);
        if (_f !== undefined) {
            f = _f;
        }

        this.setOutputData(0, v1 * (1 - f) + v2 * f);
    }

    onGetInputs() {
        return [["f", "number"]];
    }
}
LiteGraph.registerNodeType("math/lerp", MathLerp);


class MathAbs {

    static title = "Abs";
    static desc = "Absolute";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.abs(v));
    }
}
LiteGraph.registerNodeType("math/abs", MathAbs);


class MathFloor {

    static title = "Floor";
    static desc = "Floor number to remove fractional part";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.floor(v));
    }
}
LiteGraph.registerNodeType("math/floor", MathFloor);


// Math frac
class MathFrac {

    static title = "Frac";
    static desc = "Returns fractional part";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, v % 1);
    }
}
LiteGraph.registerNodeType("math/frac", MathFrac);


class MathSmoothStep {

    static title = "Smoothstep";
    static desc = "Smoothstep";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.properties = { A: 0, B: 1 };
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v === undefined) {
            return;
        }

        var edge0 = this.properties.A;
        var edge1 = this.properties.B;

        // Scale, bias and saturate x to 0..1 range
        v = LiteGraph.clamp((v - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        v = v * v * (3 - 2 * v);

        this.setOutputData(0, v);
    }
}
LiteGraph.registerNodeType("math/smoothstep", MathSmoothStep);


class MathScale {

    static title = "Scale";
    static desc = "v * factor";

    constructor() {
        this.addInput("in", "number", { label: "" });
        this.addOutput("out", "number", { label: "" });
        this.size = [80, 30];
        this.addProperty("factor", 1);
    }

    onExecute() {
        var value = this.getInputData(0);
        if (value != null) {
            this.setOutputData(0, value * this.properties.factor);
        }
    }
}
LiteGraph.registerNodeType("math/scale", MathScale);


class Gate {

    static title = "Gate";
    static desc = "if v is true, then outputs A, otherwise B";

    constructor() {
        this.addInput("v", "boolean");
        this.addInput("A");
        this.addInput("B");
        this.addOutput("out");
    }

    onExecute() {
        var v = this.getInputData(0);
        this.setOutputData(0, this.getInputData(v ? 1 : 2));
    }
}
LiteGraph.registerNodeType("math/gate", Gate);


class MathAverageFilter {

    static title = "Average";
    static desc = "Average Filter";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("samples", 10);
        this._values = new Float32Array(10);
        this._current = 0;
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }

        var num_samples = this._values.length;

        this._values[this._current % num_samples] = v;
        this._current += 1;
        if (this._current > num_samples) {
            this._current = 0;
        }

        var avr = 0;
        for (var i = 0; i < num_samples; ++i) {
            avr += this._values[i];
        }

        this.setOutputData(0, avr / num_samples);
    }

    onPropertyChanged(name, value) {
        if (value < 1) {
            value = 1;
        }
        if (name == "formula") {
            this.code_widget.value = value;
        }
        this.properties.samples = Math.round(value);
        var old = this._values;

        this._values = new Float32Array(this.properties.samples);
        if (old.length <= this._values.length) {
            this._values.set(old);
        } else {
            this._values.set(old.subarray(0, this._values.length));
        }
    }

}
LiteGraph.registerNodeType("math/average", MathAverageFilter);


class MathTendTo {

    static title = "TendTo";
    static desc = "moves the output value always closer to the input";

    constructor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("factor", 0.1);
        this.size = [80, 30];
        this._value = null;
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var f = this.properties.factor;
        if (this._value == null) {
            this._value = v;
        } else {
            this._value = this._value * (1 - f) + v * f;
        }
        this.setOutputData(0, this._value);
    }
}
LiteGraph.registerNodeType("math/tendTo", MathTendTo);


class MathOperation {

    static title = "Operation";
    static desc = "Easy math operators";

    constructor() {
        this.addInput("A", "number,array,object");
        this.addInput("B", "number");
        this.addOutput("=", "number");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", "+", "enum", { values: MathOperation.values });
        this._func = MathOperation.funcs[this.properties.OP];
        this._result = []; // only used for arrays
    }

    getTitle() {
        if (this.properties.OP == "max" || this.properties.OP == "min")
            return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    }

    setValue(v) {
        if (typeof v == "string") {
            v = parseFloat(v);
        }
        this.properties["value"] = v;
    }

    onPropertyChanged(name, _value) {
        if (name != "OP") return;
        this._func = MathOperation.funcs[this.properties.OP];
        if (!this._func) {
            console.warn?.("Unknown operation: " + this.properties.OP);
            this._func = function (A) {
                return A;
            };
        }
    }

    onExecute() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if (A != null) {
            if (A.constructor === Number) this.properties["A"] = A;
        } else {
            A = this.properties["A"];
        }

        if (B != null) {
            this.properties["B"] = B;
        } else {
            B = this.properties["B"];
        }

        var func = MathOperation.funcs[this.properties.OP];

        var result;
        if (A.constructor === Number) {
            result = 0;
            result = func(A, B);
        } else if (A.constructor === Array) {
            result = this._result;
            result.length = A.length;
            for (let i = 0; i < A.length; ++i)
                result[i] = func(A[i], B);
        } else {
            result = {};
            for (let i in A)
                result[i] = func(A[i], B);
        }
        this.setOutputData(0, result);
    }

    onDrawBackground(ctx) {
        if (this.flags?.collapsed) {
            return;
        }

        ctx.font = "36px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5,
        );
        ctx.textAlign = "left";
    }

    static values = ["+", "-", "*", "/", "%", "^", "max", "min"];

    static funcs = {
        "+": function (A, B) {
            return A + B;
        },
        "-": function (A, B) {
            return A - B;
        },
        x: function (A, B) {
            return A * B;
        },
        X: function (A, B) {
            return A * B;
        },
        "*": function (A, B) {
            return A * B;
        },
        "/": function (A, B) {
            return A / B;
        },
        "%": function (A, B) {
            return A % B;
        },
        "^": function (A, B) {
            return Math.pow(A, B);
        },
        max: function (A, B) {
            return Math.max(A, B);
        },
        min: function (A, B) {
            return Math.min(A, B);
        },
    };

    static "@OP" = {
        type: "enum",
        title: "operation",
        values: MathOperation.values,
    };

    // static size = [100, 60];
}
LiteGraph.registerNodeType("math/operation", MathOperation);
LiteGraph.registerSearchboxExtra("math/operation", "MAX", {
    properties: { OP: "max" },
    title: "MAX()",
});
LiteGraph.registerSearchboxExtra("math/operation", "MIN", {
    properties: { OP: "min" },
    title: "MIN()",
});


class MathCompare {

    static title = "Compare";
    static desc = "compares between two values";

    constructor() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("A==B", "boolean");
        this.addOutput("A!=B", "boolean");
        this.addProperty("A", 0);
        this.addProperty("B", 0);
    }

    onExecute() {
        var A = Number(this.getInputOrProperty("A"));
        var B = Number(this.getInputOrProperty("B"));
        this.setProperty("A",A);
        this.setProperty("B",B);
        
        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            if (!output.links || !output.links.length) {
                continue;
            }
            var value;
            switch (output.name) {
                case "A==B":
                    value = A == B;
                    break;
                case "A!=B":
                    value = A != B;
                    break;
                case "A>B":
                    value = A > B;
                    break;
                case "A<B":
                    value = A < B;
                    break;
                case "A<=B":
                    value = A <= B;
                    break;
                case "A>=B":
                    value = A >= B;
                    break;
            }
            this.setOutputData(i, value);
        }
    }

    onGetOutputs() {
        return [
            ["A==B", "boolean"],
            ["A!=B", "boolean"],
            ["A>B", "boolean"],
            ["A<B", "boolean"],
            ["A>=B", "boolean"],
            ["A<=B", "boolean"],
        ];
    }
}
LiteGraph.registerNodeType("math/compare", MathCompare);
LiteGraph.registerSearchboxExtra("math/compare", "==", {
    outputs: [["A==B", "boolean"]],
    title: "A==B",
});
LiteGraph.registerSearchboxExtra("math/compare", "!=", {
    outputs: [["A!=B", "boolean"]],
    title: "A!=B",
});
LiteGraph.registerSearchboxExtra("math/compare", ">", {
    outputs: [["A>B", "boolean"]],
    title: "A>B",
});
LiteGraph.registerSearchboxExtra("math/compare", "<", {
    outputs: [["A<B", "boolean"]],
    title: "A<B",
});
LiteGraph.registerSearchboxExtra("math/compare", ">=", {
    outputs: [["A>=B", "boolean"]],
    title: "A>=B",
});
LiteGraph.registerSearchboxExtra("math/compare", "<=", {
    outputs: [["A<=B", "boolean"]],
    title: "A<=B",
});


class MathCondition {

    static title = "Condition";
    static desc = "evaluates condition between A and B";

    constructor() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("true", "boolean");
        this.addOutput("false", "boolean");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", ">", "enum", { values: MathCondition.values });
        this.addWidget("combo", "Cond.", this.properties.OP, {
            property: "OP",
            values: MathCondition.values,
        });

        this.size = [80, 60];
    }

    getTitle() {
        return "A " + this.properties.OP + " B";
    }

    onExecute() {
        var A = this.getInputData(0);
        if (A === undefined) {
            A = this.properties.A;
        } else {
            this.properties.A = A;
        }

        var B = this.getInputData(1);
        if (B === undefined) {
            B = this.properties.B;
        } else {
            this.properties.B = B;
        }

        var result = true;
        switch (this.properties.OP) {
            case ">":
                result = A > B;
                break;
            case "<":
                result = A < B;
                break;
            case "==":
                result = A == B;
                break;
            case "!=":
                result = A != B;
                break;
            case "<=":
                result = A <= B;
                break;
            case ">=":
                result = A >= B;
                break;
            case "||":
                result = A || B;
                break;
            case "&&":
                result = A && B;
                break;
        }

        this.setOutputData(0, result);
        this.setOutputData(1, !result);
    }

    static values = [">", "<", "==", "!=", "<=", ">=", "||", "&&"];

    static "@OP" = {
        type: "enum",
        title: "operation",
        values: MathCondition.values,
    };
}
LiteGraph.registerNodeType("math/condition", MathCondition);


class MathBranch {
    static title = "Branch";
    static desc = "If condition is true, outputs IN in true, otherwise in false";
    constructor() {
        this.addInput("in", 0);
        this.addInput("cond", "boolean");
        this.addOutput("true", 0);
        this.addOutput("false", 0);
        this.size = [80, 60];
    }

    onExecute() {
        var V = this.getInputData(0);
        var cond = this.getInputData(1);

        if (cond) {
            this.setOutputData(0, V);
            this.setOutputData(1, null);
        } else {
            this.setOutputData(0, null);
            this.setOutputData(1, V);
        }
    }
}
LiteGraph.registerNodeType("math/branch", MathBranch);


class MathAccumulate {

    static title = "Accumulate";
    static desc = "Increments a value every time";

    constructor() {
        this.addInput("inc", "number");
        this.addOutput("total", "number");
        this.addProperty("increment", 1);
        this.addProperty("value", 0);
    }

    onExecute() {
        if (this.properties.value === null) {
            this.properties.value = 0;
        }

        var inc = this.getInputData(0);
        if (inc !== null) {
            this.properties.value += inc;
        } else {
            this.properties.value += this.properties.increment;
        }
        this.setOutputData(0, this.properties.value);
    }
}
LiteGraph.registerNodeType("math/accumulate", MathAccumulate);


class MathTrigonometry {

    static title = "Trigonometry";
    static desc = "Sin Cos Tan";

    constructor() {
        this.addInput("v", "number");
        this.addOutput("sin", "number");

        this.addProperty("amplitude", 1);
        this.addProperty("offset", 0);
        this.bgImageUrl = "nodes/imgs/icon-sin.png";
    }

    // MathTrigonometry.filter = "shader";

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var amplitude = this.properties["amplitude"];
        var slot = this.findInputSlot("amplitude");
        if (slot != -1) {
            amplitude = this.getInputData(slot);
        }
        var offset = this.properties["offset"];
        slot = this.findInputSlot("offset");
        if (slot != -1) {
            offset = this.getInputData(slot);
        }

        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            var value;
            switch (output.name) {
                case "sin":
                    value = Math.sin(v);
                    break;
                case "cos":
                    value = Math.cos(v);
                    break;
                case "tan":
                    value = Math.tan(v);
                    break;
                case "asin":
                    value = Math.asin(v);
                    break;
                case "acos":
                    value = Math.acos(v);
                    break;
                case "atan":
                    value = Math.atan(v);
                    break;
            }
            this.setOutputData(i, amplitude * value + offset);
        }
    }

    onGetInputs() {
        return [
            ["v", "number"],
            ["amplitude", "number"],
            ["offset", "number"],
        ];
    }

    onGetOutputs() {
        return [
            ["sin", "number"],
            ["cos", "number"],
            ["tan", "number"],
            ["asin", "number"],
            ["acos", "number"],
            ["atan", "number"],
        ];
    }
}
LiteGraph.registerNodeType("math/trigonometry", MathTrigonometry);
LiteGraph.registerSearchboxExtra("math/trigonometry", "SIN()", {
    outputs: [["sin", "number"]],
    title: "SIN()",
});
LiteGraph.registerSearchboxExtra("math/trigonometry", "COS()", {
    outputs: [["cos", "number"]],
    title: "COS()",
});
LiteGraph.registerSearchboxExtra("math/trigonometry", "TAN()", {
    outputs: [["tan", "number"]],
    title: "TAN()",
});


// math library for safe math operations without eval
class MathFormula {

    static title = "Formula";
    static desc = "Compute formula";

    constructor() {
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addOutput("", "number");
        this.properties = { x: 1.0, y: 1.0, formula: "x+y" };
        this.code_widget = this.addWidget(
            "text",
            "F(x,y)",
            this.properties.formula,
            function (v, canvas, node) {
                node.properties.formula = v;
            },
        );
        this.addWidget("toggle", "allow", LiteGraph.allow_scripts, function (v) {
            LiteGraph.allow_scripts = v;
        });
        this._func = null;
    }

    onExecute() {
        if (!LiteGraph.allow_scripts) {
            return;
        }

        var x = this.getInputData(0);
        var y = this.getInputData(1);
        if (x != null) {
            this.properties["x"] = x;
        } else {
            x = this.properties["x"];
        }

        if (y != null) {
            this.properties["y"] = y;
        } else {
            y = this.properties["y"];
        }

        var value;
        try {
            if (!this._func || this._func_code != this.properties.formula) {
                this._func = new Function(
                    "x",
                    "y",
                    "TIME",
                    "return " + this.properties.formula,
                );
                this._func_code = this.properties.formula;
            }
            value = this._func(x, y, this.graph.globaltime);
            this.boxcolor = null;
        } catch (err) {
            this.boxcolor = "red";
        }
        this.setOutputData(0, value);
    }

    getTitle() {
        return this._func_code || "Formula";
    }

    onDrawBackground() {
        var f = this.properties["formula"];
        if (this.outputs && this.outputs.length) {
            this.outputs[0].label = f;
        }
    }

    static size = [160, 100];
}
LiteGraph.registerNodeType("math/formula", MathFormula);


class Math3DVec2ToXY {

    static title = "Vec2->XY";
    static desc = "vector 2 to components";

    constructor() {
        this.addInput("vec2", "vec2");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
    }
}
LiteGraph.registerNodeType("math3d/vec2-to-xy", Math3DVec2ToXY);


class Math3DXYToVec2 {

    static title = "XY->Vec2";
    static desc = "components to vector2";

    constructor() {
        this.addInputs([
            ["x", "number"],
            ["y", "number"],
        ]);
        this.addOutput("vec2", "vec2");
        this.properties = { x: 0, y: 0 };
        this._data = new Float32Array(2);
    }

    onExecute() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;

        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/xy-to-vec2", Math3DXYToVec2);


class Math3DVec3ToXYZ {

    static title = "Vec3->XYZ";
    static desc = "vector 3 to components";

    constructor() {
        this.addInput("vec3", "vec3");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
    }
}
LiteGraph.registerNodeType("math3d/vec3-to-xyz", Math3DVec3ToXYZ);


class Math3DXYZToVec3 {

    static title = "XYZ->Vec3";
    static desc = "components to vector3";

    constructor() {
        this.addInputs([
            ["x", "number"],
            ["y", "number"],
            ["z", "number"],
        ]);
        this.addOutput("vec3", "vec3");
        this.properties = { x: 0, y: 0, z: 0 };
        this._data = new Float32Array(3);
    }

    onExecute() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;

        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/xyz-to-vec3", Math3DXYZToVec3);


class Math3DVec4ToXYZW {

    static title = "Vec4->XYZW";
    static desc = "vector 4 to components";

    constructor() {
        this.addInput("vec4", "vec4");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
        this.addOutput("w", "number");
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
        this.setOutputData(3, v[3]);
    }
}
LiteGraph.registerNodeType("math3d/vec4-to-xyzw", Math3DVec4ToXYZW);


class Math3DXYZWToVec4 {

    static title = "XYZW->Vec4";
    static desc = "components to vector4";

    constructor() {
        this.addInputs([
            ["x", "number"],
            ["y", "number"],
            ["z", "number"],
            ["w", "number"],
        ]);
        this.addOutput("vec4", "vec4");
        this.properties = { x: 0, y: 0, z: 0, w: 0 };
        this._data = new Float32Array(4);
    }

    onExecute() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }
        var w = this.getInputData(3);
        if (w == null) {
            w = this.properties.w;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;
        data[3] = w;

        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/xyzw-to-vec4", Math3DXYZWToVec4);


class Math3DMat4 {

    static title = "mat4";

    DEG2RAD = 0.0174532925;

    constructor() {
        this.addInput("T", "vec3");
        this.addInput("R", "vec3");
        this.addInput("S", "vec3");
        this.addOutput("mat4", "mat4");
        this.properties = {
            T: [0, 0, 0],
            R: [0, 0, 0],
            S: [1, 1, 1],
            R_in_degrees: true,
        };
        this._result = mat4.create();
        this._must_update = true;
    }

    onPropertyChanged(_name, _value) {
        this._must_update = true;
    }

    onExecute() {
        var M = this._result;
        var Q = Math3DMat4.temp_quat;
        var temp_mat4 = Math3DMat4.temp_mat4;
        var temp_vec3 = Math3DMat4.temp_vec3;

        var T = this.getInputData(0);
        var R = this.getInputData(1);
        var S = this.getInputData(2);

        if (this._must_update || T || R || S) {
            T = T || this.properties.T;
            R = R || this.properties.R;
            S = S || this.properties.S;
            mat4.identity(M);
            mat4.translate(M, M, T);
            if (this.properties.R_in_degrees) {
                temp_vec3.set(R);
                vec3.scale(temp_vec3, temp_vec3, this.DEG2RAD);
                quat.fromEuler(Q, temp_vec3);
            } else quat.fromEuler(Q, R);
            mat4.fromQuat(temp_mat4, Q);
            mat4.multiply(M, M, temp_mat4);
            mat4.scale(M, M, S);
        }

        this.setOutputData(0, M);
    }

    static temp_quat = new Float32Array([0, 0, 0, 1]);
    static temp_mat4 = new Float32Array(16);
    static temp_vec3 = new Float32Array(3);
}
LiteGraph.registerNodeType("math3d/mat4", Math3DMat4);


// Math 3D operation
class Math3DOperation {

    static title = "Operation";
    static desc = "Easy math 3D operators";

    constructor() {
        this.addInput("A", "number,vec3");
        this.addInput("B", "number,vec3");
        this.addOutput("=", "number,vec3");
        this.addProperty("OP", "+", "enum", { values: Math3DOperation.values });
        this._result = vec3.create();
    }

    getTitle() {
        if (this.properties.OP == "max" || this.properties.OP == "min")
            return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    }

    onExecute() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if (A == null || B == null) return;
        if (A.constructor === Number) A = [A, A, A];
        if (B.constructor === Number) B = [B, B, B];

        var result = this._result;
        switch (this.properties.OP) {
            case "+":
                result = vec3.add(result, A, B);
                break;
            case "-":
                result = vec3.sub(result, A, B);
                break;
            case "x":
            case "X":
            case "*":
                result = vec3.mul(result, A, B);
                break;
            case "/":
                result = vec3.div(result, A, B);
                break;
            case "%":
                result[0] = A[0] % B[0];
                result[1] = A[1] % B[1];
                result[2] = A[2] % B[2];
                break;
            case "^":
                result[0] = Math.pow(A[0], B[0]);
                result[1] = Math.pow(A[1], B[1]);
                result[2] = Math.pow(A[2], B[2]);
                break;
            case "max":
                result[0] = Math.max(A[0], B[0]);
                result[1] = Math.max(A[1], B[1]);
                result[2] = Math.max(A[2], B[2]);
                break;
            case "min":
                result[0] = Math.min(A[0], B[0]);
                result[1] = Math.min(A[1], B[1]);
                result[2] = Math.min(A[2], B[2]);
                break;
            case "dot":
                result = vec3.dot(A, B);
                break;
            case "cross":
                vec3.cross(result, A, B);
                break;
            default:
                console.warn?.("Unknown operation: " + this.properties.OP);
        }
        this.setOutputData(0, result);
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.font = "40px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5,
        );
        ctx.textAlign = "left";
    }

    static values = [
        "+",
        "-",
        "*",
        "/",
        "%",
        "^",
        "max",
        "min",
        "dot",
        "cross",
    ];

    static "@OP" = {
        type: "enum",
        title: "operation",
        values: Math3DOperation.values,
    };

    static size = [100, 60];
}
LiteGraph.registerSearchboxExtra("math3d/operation", "CROSS()", {
    properties: { OP: "cross" },
    title: "CROSS()",
});
LiteGraph.registerSearchboxExtra("math3d/operation", "DOT()", {
    properties: { OP: "dot" },
    title: "DOT()",
});
LiteGraph.registerNodeType("math3d/operation", Math3DOperation);


class Math3DVec3Scale {

    static title = "vec3_scale";
    static desc = "scales the components of a vec3";

    constructor() {
        this.addInput("in", "vec3");
        this.addInput("f", "number");
        this.addOutput("out", "vec3");
        this.properties = { f: 1 };
        this._data = new Float32Array(3);
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var f = this.getInputData(1);
        if (f == null) {
            f = this.properties.f;
        }

        var data = this._data;
        data[0] = v[0] * f;
        data[1] = v[1] * f;
        data[2] = v[2] * f;
        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/vec3-scale", Math3DVec3Scale);


class Math3DVec3Length {

    static title = "vec3_length";
    static desc = "returns the module of a vector";

    constructor() {
        this.addInput("in", "vec3");
        this.addOutput("out", "number");
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        this.setOutputData(0, dist);
    }
}
LiteGraph.registerNodeType("math3d/vec3-length", Math3DVec3Length);


class Math3DVec3Normalize {

    static title = "vec3_normalize";
    static desc = "returns the vector normalized";

    constructor() {
        this.addInput("in", "vec3");
        this.addOutput("out", "vec3");
        this._data = new Float32Array(3);
    }

    onExecute() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        var data = this._data;
        data[0] = v[0] / dist;
        data[1] = v[1] / dist;
        data[2] = v[2] / dist;

        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/vec3-normalize", Math3DVec3Normalize);


class Math3DVec3Lerp {

    static title = "vec3_lerp";
    static desc = "returns the interpolated vector";

    constructor() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addInput("f", "vec3");
        this.addOutput("out", "vec3");
        this.properties = { f: 0.5 };
        this._data = new Float32Array(3);
    }

    onExecute() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }
        var f = this.getInputOrProperty("f");

        var data = this._data;
        data[0] = A[0] * (1 - f) + B[0] * f;
        data[1] = A[1] * (1 - f) + B[1] * f;
        data[2] = A[2] * (1 - f) + B[2] * f;

        this.setOutputData(0, data);
    }
}
LiteGraph.registerNodeType("math3d/vec3-lerp", Math3DVec3Lerp);


class Math3DVec3Dot {

    static title = "vec3_dot";
    static desc = "returns the dot product";

    constructor() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addOutput("out", "number");
    }

    onExecute() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }

        var dot = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];
        this.setOutputData(0, dot);
    }
}
LiteGraph.registerNodeType("math3d/vec3-dot", Math3DVec3Dot);


// if glMatrix is installed...
if (typeof(glMatrix)!=="undefined") {
    class Math3DQuaternion {

        static title = "Quaternion";
        static desc = "quaternion";

        constructor() {
            this.addOutput("quat", "quat");
            this.properties = { x: 0, y: 0, z: 0, w: 1, normalize: false };
            this._value = quat.create();
        }

        onExecute() {
            this._value[0] = this.getInputOrProperty("x");
            this._value[1] = this.getInputOrProperty("y");
            this._value[2] = this.getInputOrProperty("z");
            this._value[3] = this.getInputOrProperty("w");
            if (this.properties.normalize) {
                quat.normalize(this._value, this._value);
            }
            this.setOutputData(0, this._value);
        }

        onGetInputs() {
            return [
                ["x", "number"],
                ["y", "number"],
                ["z", "number"],
                ["w", "number"],
            ];
        }
    }
    LiteGraph.registerNodeType("math3d/quaternion", Math3DQuaternion);


    class Math3DRotation {

        static title = "Rotation";
        static desc = "quaternion rotation";

        constructor() {
            this.addInputs([
                ["degrees", "number"],
                ["axis", "vec3"],
            ]);
            this.addOutput("quat", "quat");
            this.properties = { angle: 90.0, axis: vec3.fromValues(0, 1, 0) };

            this._value = quat.create();
        }

        onExecute() {
            var angle = this.getInputData(0);
            if (angle == null) {
                angle = this.properties.angle;
            }
            var axis = this.getInputData(1);
            if (axis == null) {
                axis = this.properties.axis;
            }

            var R = quat.setAxisAngle(this._value, axis, angle * 0.0174532925);
            this.setOutputData(0, R);
        }
    }
    LiteGraph.registerNodeType("math3d/rotation", Math3DRotation);


    class MathEulerToQuat {

        static title = "Euler->Quat";
        static desc = "Converts euler angles (in degrees) to quaternion";

        constructor() {
            this.addInput("euler", "vec3");
            this.addOutput("quat", "quat");
            this.properties = { euler: [0, 0, 0], use_yaw_pitch_roll: false };
            this._degs = vec3.create();
            this._value = quat.create();
        }

        onExecute() {
            var euler = this.getInputData(0);
            if (euler == null) {
                euler = this.properties.euler;
            }
            vec3.scale(this._degs, euler, this.DEG2RAD);
            if (this.properties.use_yaw_pitch_roll)
                this._degs = [this._degs[2], this._degs[0], this._degs[1]];
            var R = quat.fromEuler(this._value, this._degs);
            this.setOutputData(0, R);
        }
    }
    LiteGraph.registerNodeType("math3d/euler_to_quat", MathEulerToQuat);


    class MathQuatToEuler {

        static title = "Euler->Quat";
        static desc = "Converts rotX,rotY,rotZ in degrees to quat";

        constructor() {
            this.addInput(["quat", "quat"]);
            this.addOutput("euler", "vec3");
            this._value = vec3.create();
        }

        onExecute() {
            var q = this.getInputData(0);
            if (!q) return;
            // @BUG: R is unused, but I don't know where it *should* be used because I don't know this math off the top
            // It *probably* goes in one of the next two lines
            var R = quat.toEuler(this._value, q);
            vec3.scale(this._value, this._value, this.DEG2RAD);
            this.setOutputData(0, this._value);
        }
    }
    LiteGraph.registerNodeType("math3d/quat_to_euler", MathQuatToEuler);


    // Math3D rotate vec3
    class Math3DRotateVec3 {

        static title = "Rot. Vec3";
        static desc = "rotate a point";

        constructor() {
            this.addInputs([
                ["vec3", "vec3"],
                ["quat", "quat"],
            ]);
            this.addOutput("result", "vec3");
            this.properties = { vec: [0, 0, 1] };
        }

        onExecute() {
            var vec = this.getInputData(0);
            if (vec == null) {
                vec = this.properties.vec;
            }
            var quat = this.getInputData(1);
            if (quat == null) {
                this.setOutputData(vec);
            } else {
                this.setOutputData(0, vec3.transformQuat(vec3.create(), vec, quat));
            }
        }
    }
    LiteGraph.registerNodeType("math3d/rotate_vec3", Math3DRotateVec3);


    class Math3DMultQuat {

        static title = "Mult. Quat";
        static desc = "rotate quaternion";

        constructor() {
            this.addInputs([
                ["A", "quat"],
                ["B", "quat"],
            ]);
            this.addOutput("A*B", "quat");

            this._value = quat.create();
        }

        onExecute() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }

            var R = quat.multiply(this._value, A, B);
            this.setOutputData(0, R);
        }
    }
    LiteGraph.registerNodeType("math3d/mult-quat", Math3DMultQuat);


    class Math3DQuatSlerp {

        static title = "Quat Slerp";
        static desc = "quaternion spherical interpolation";

        constructor() {
            this.addInputs([
                ["A", "quat"],
                ["B", "quat"],
                ["factor", "number"],
            ]);
            this.addOutput("slerp", "quat");
            this.addProperty("factor", 0.5);

            this._value = quat.create();
        }

        onExecute() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }
            var factor = this.properties.factor;
            if (this.getInputData(2) != null) {
                factor = this.getInputData(2);
            }

            var R = quat.slerp(this._value, A, B, factor);
            this.setOutputData(0, R);
        }
    }
    LiteGraph.registerNodeType("math3d/quat-slerp", Math3DQuatSlerp);


    class Math3DRemapRange {

        static title = "Remap Range";
        static desc = "remap a 3D range";

        constructor() {
            this.addInput("vec3", "vec3");
            this.addOutput("remap", "vec3");
            this.addOutput("clamped", "vec3");
            this.properties = {
                clamp: true,
                range_min: [-1, -1, 0],
                range_max: [1, 1, 0],
                target_min: [-1, -1, 0],
                target_max: [1, 1, 0],
            };
            this._value = vec3.create();
            this._clamped = vec3.create();
        }

        onExecute() {
            var vec = this.getInputData(0);
            if (vec) this._value.set(vec);
            var range_min = this.properties.range_min;
            var range_max = this.properties.range_max;
            var target_min = this.properties.target_min;
            var target_max = this.properties.target_max;

            // swap to avoid errors
            /*
            if(range_min > range_max)
            {
                range_min = range_max;
                range_max = this.properties.range_min;
            }

            if(target_min > target_max)
            {
                target_min = target_max;
                target_max = this.properties.target_min;
            }
            */

            for (var i = 0; i < 3; ++i) {
                var r = range_max[i] - range_min[i];
                this._clamped[i] = LiteGraph.clamp(
                    this._value[i],
                    range_min[i],
                    range_max[i],
                );
                if (r == 0) {
                    this._value[i] = (target_min[i] + target_max[i]) * 0.5;
                    continue;
                }

                var n = (this._value[i] - range_min[i]) / r;
                if (this.properties.clamp) n = LiteGraph.clamp(n, 0, 1);
                var t = target_max[i] - target_min[i];
                this._value[i] = target_min[i] + n * t;
            }

            this.setOutputData(0, this._value);
            this.setOutputData(1, this._clamped);
        }
    }
    LiteGraph.registerNodeType("math3d/remap_range", Math3DRemapRange);

// glMatrix
} else if (LiteGraph.debug) {
    console.warn?.("No glmatrix found, some Math3D nodes may not work");
}


function toString(a) {
    if (a && a.constructor === Object) {
        try {
            return JSON.stringify(a);
        } catch (err) {
            return String(a);
        }
    }
    return String(a);
}
LiteGraph.wrapFunctionAsNode("string/toString", toString, [""], "string");


function compare(a, b) {
    return a == b;
}
LiteGraph.wrapFunctionAsNode(
    "string/compare",
    compare,
    ["string", "string"],
    "boolean",
);


function concatenate(a, b) {
    if (a === undefined) {
        return b;
    }
    if (b === undefined) {
        return a;
    }
    return a + "" + b;
}
LiteGraph.wrapFunctionAsNode(
    "string/concatenate",
    concatenate,
    ["string", "string"],
    "string",
);


function contains(a, b) {
    if (a === undefined || b === undefined) {
        return false;
    }
    return a.indexOf(b) != -1;
}
LiteGraph.wrapFunctionAsNode(
    "string/contains",
    contains,
    ["string", "string"],
    "boolean",
);


function toUpperCase(a) {
    if (a != null && a.constructor === String) {
        return a.toUpperCase();
    }
    return a;
}
LiteGraph.wrapFunctionAsNode(
    "string/toUpperCase",
    toUpperCase,
    ["string"],
    "string",
);


function split(str, separator) {
    if (separator == null) separator = this.properties.separator;
    if (str == null) return [];
    if (str.constructor === String) return str.split(separator || " ");
    else if (str.constructor === Array) {
        var r = [];
        for (var i = 0; i < str.length; ++i) {
            if (typeof str[i] == "string")
                r[i] = str[i].split(separator || " ");
        }
        return r;
    }
    return null;
}
LiteGraph.wrapFunctionAsNode(
    "string/split",
    split,
    ["string,array", "string"],
    "array",
    { separator: "," },
);


function toFixed(a) {
    if (a != null && a.constructor === Number) {
        return a.toFixed(this.properties.precision);
    }
    return a;
}
LiteGraph.wrapFunctionAsNode("string/toFixed", toFixed, ["number"], "string", { precision: 0 });


class StringToTable {

    static title = "toTable";
    static desc = "Splits a string to table";

    constructor() {
        this.addInput("", "string");
        this.addOutput("table", "table");
        this.addOutput("rows", "number");
        this.addProperty("value", "");
        this.addProperty("separator", ",");
        this._table = null;
    }

    onExecute() {
        var input = this.getInputData(0);
        if (!input) return;
        var separator = this.properties.separator || ",";
        if (input != this._str || separator != this._last_separator) {
            this._last_separator = separator;
            this._str = input;
            this._table = input.split("\n").map(function (a) {
                return a.trim().split(separator);
            });
        }
        this.setOutputData(0, this._table);
        this.setOutputData(1, this._table ? this._table.length : 0);
    }
}
LiteGraph.registerNodeType("string/toTable", StringToTable);


class Selector {

    static title = "Selector";
    static desc = "selects an output";

    constructor() {
        this.addInput("sel", "number");
        this.addInput("A");
        this.addInput("B");
        this.addInput("C");
        this.addInput("D");
        this.addOutput("out");

        this.selected = 0;
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        ctx.fillStyle = "#AFB";
        var y = (this.selected + 1) * LiteGraph.NODE_SLOT_HEIGHT + 6;
        ctx.beginPath();
        ctx.moveTo(50, y);
        ctx.lineTo(50, y + LiteGraph.NODE_SLOT_HEIGHT);
        ctx.lineTo(34, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);
        ctx.fill();
    }

    onExecute() {
        var sel = this.getInputData(0);
        if (sel == null || sel.constructor !== Number) sel = 0;
        this.selected = sel = Math.round(sel) % (this.inputs.length - 1);
        var v = this.getInputData(sel + 1);
        if (v !== undefined) {
            this.setOutputData(0, v);
        }
    }

    onGetInputs() {
        return [
            ["E", 0],
            ["F", 0],
            ["G", 0],
            ["H", 0],
        ];
    }
}
LiteGraph.registerNodeType("logic/selector", Selector);


class Sequence {

    static title = "Sequence";
    static desc = "select one element from a sequence from a string";

    constructor() {
        this.properties = {sequence: "A,B,C"};
        this.addInput("index", "number");
        this.addInput("seq");
        this.addOutput("out");

        this.index = 0;
        this.values = this.properties.sequence.split(",");
    }

    onPropertyChanged(name, value) {
        if (name == "sequence") {
            this.values = value.split(",");
        }
    }

    onExecute() {
        var seq = this.getInputData(1);
        if (seq && seq != this.current_sequence) {
            this.values = seq.split(",");
            this.current_sequence = seq;
        }
        var index = this.getInputData(0);
        if (index == null) {
            index = 0;
        }
        this.index = index = Math.round(index) % this.values.length;

        this.setOutputData(0, this.values[index]);
    }
}
LiteGraph.registerNodeType("logic/sequence", Sequence);


class logicAnd {

    static title = "AND";
    static desc = "Return true if all inputs are true";

    constructor() {
        this.properties = {};
        this.addInput("a", "boolean");
        this.addInput("b", "boolean");
        this.addOutput("out", "boolean");
    }

    onExecute() {
        let ret = true;
        for (let inX in this.inputs) {
            if (!this.getInputData(inX)) {
                ret = false;
                break;
            }
        }
        this.setOutputData(0, ret);
    }

    onGetInputs() {
        return [["and", "boolean"]];
    }
}
LiteGraph.registerNodeType("logic/AND", logicAnd);


class logicOr {

    static title = "OR";
    static desc = "Return true if at least one input is true";

    constructor() {
        this.properties = {};
        this.addInput("a", "boolean");
        this.addInput("b", "boolean");
        this.addOutput("out", "boolean");
    }

    onExecute() {
        var ret = false;
        for (var inX in this.inputs) {
            if (this.getInputData(inX)) {
                ret = true;
                break;
            }
        }
        this.setOutputData(0, ret);
    }

    onGetInputs() {
        return [["or", "boolean"]];
    }
}
LiteGraph.registerNodeType("logic/OR", logicOr);


class logicNot {
    static title = "NOT";
    static desc = "Return the logical negation";
    constructor() {
        this.properties = {};
        this.addInput("in", "boolean");
        this.addOutput("out", "boolean");
    }

    onExecute() {
        var ret = !this.getInputData(0);
        this.setOutputData(0, ret);
    }
}
LiteGraph.registerNodeType("logic/NOT", logicNot);


class logicCompare {

    static title = "bool == bool";
    static desc = "Compare for logical equality";

    constructor() {
        this.properties = {};
        this.addInput("a", "boolean");
        this.addInput("b", "boolean");
        this.addOutput("out", "boolean");
    }

    onExecute() {
        var last = null;
        var ret = true;
        for (var inX in this.inputs) {
            if (last === null) last = this.getInputData(inX);
            else if (last != this.getInputData(inX)) {
                ret = false;
                break;
            }
        }
        this.setOutputData(0, ret);
    }

    onGetInputs() {
        return [["bool", "boolean"]];
    }
}
LiteGraph.registerNodeType("logic/CompareBool", logicCompare);


class logicBranch {

    static title = "Branch";
    static desc = "Branch execution on condition";

    constructor() {
        this.properties = {};
        this.addInput("onTrigger", LiteGraph.ACTION);
        this.addInput("condition", "boolean");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
        this.mode = LiteGraph.ON_TRIGGER;
    }

    onExecute(_param, _options) {
        var conditition = this.getInputData(1);
        if (conditition) {
            console.debug(this,conditition);
            this.triggerSlot(0, _param, null, _options);
        } else {
            this.triggerSlot(1, _param, null, _options);
        }
    }
}
LiteGraph.registerNodeType("logic/IF", logicBranch);


class logicFor {
    constructor() {
        this.properties = { };
        this.addInput("start", "number");
        this.addInput("nElements", "number");
        this.addInput("do", LiteGraph.ACTION);
        this.addInput("break", LiteGraph.ACTION);
        // this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("do", LiteGraph.EVENT);
        this.addOutput("index", "number");
        this.started = false;
        this.stopped = false;
    }

    static title = "FOR";
    static desc = "Cycle FOR";

    onExecute(param) {
        if (!this.started) return;
        var iI = this.getInputData(0);
        var num = this.getInputData(1);
        for (var k=iI;k<iI+num;k++) {
            console.debug?.("for cycle "+k);
            this.setOutputData(1, k);
            this.triggerSlot(0, param);
            if (this.stopped) {
                console.debug?.("for cycle stopped on index "+k);
                break;
            }
        }
        this.started = false;
        this.stopped = true;
    }

    onAction(action) {
        /* console.debug?.(action);
        console.debug?.(param);
        console.debug?.(this);*/
        switch(action) {
            case "break":
                this.stopped = true;
                break;
            /* case "reset":
                this.stopped = false;
            break;*/
            case "do":
                this.started = true;
                this.stopped = false;
                this.doExecute();
                break;
        }
    }
}
LiteGraph.registerNodeType("logic/CycleFOR", logicFor);

class logicForEach {
    constructor() {
        this.properties = { };
        this.addInput("array", "array");
        this.addInput("do", LiteGraph.ACTION);
        this.addInput("break", LiteGraph.ACTION);
        this.addOutput("do", LiteGraph.EVENT);
        this.addOutput("index", "number");
        this.addOutput("element", 0);
        this.started = false;
        this.stopped = false;
    }

    static title = "ForEach";
    static desc = "Cycle for each element in array";

    onExecute(param) {
        if (!this.started) return;
        var ar = this.getInputData(0);
        var num = this.getInputData(1);
        if(ar === null || !ar || typeof(ar.forEach)!="function"){
            return;
        }
        // for (var k=iI;k<iI+num;k++) {
        ar.forEach((el,k)=>{
            console.debug?.("for cycle "+k);
            this.setOutputData(1, k);
            this.setOutputData(2, el);
            this.triggerSlot(0, param);
            if (this.stopped) {
                console.debug?.("foreach cycle stopped on index "+k);
                return;
            }
        })
        this.started = false;
        this.stopped = true;
    }

    onAction(action) {
        /* console.debug?.(action);
        console.debug?.(param);
        console.debug?.(this);*/
        switch(action) {
            case "break":
                this.stopped = true;
                break;
            /* case "reset":
                this.stopped = false;
            break;*/
            case "do":
                this.started = true;
                this.stopped = false;
                this.doExecute();
                break;
        }
    }
}
LiteGraph.registerNodeType("logic/CycleForEach", logicForEach);


class logicWhile {
    constructor() {
        this.properties = { cycleLimit: 999, checkOnStart: true };
        this.addInput("do", LiteGraph.ACTION);
        this.addInput("condition", "boolean");
        this.addInput("break", LiteGraph.ACTION);
        this.addOutput("do", LiteGraph.EVENT);
        this.addOutput("index", "number");
        this.started = false;
        this.stopped = false;
        this.k = 0;
        this.cond = false;
        this.addWidget("toggle","checkOnStart",this.properties.checkOnStart,"checkOnStart");
    }

    static title = "WHILE";
    static desc = "Cycle WHILE";

    onExecute() {
        this.setOutputData(1, this.k);
        this.cond = this.getInputData(1);
    }
    onAction(action, param) {
        switch(action) {
            case "break":
                this.stopped = true;
                break;
            case "do":
                /* this.started = true;
                this.stopped = false;
                this.execute();*/
                this.started = true;
                this.stopped = false;
                var checkOnStart = this.getInputOrProperty("checkOnStart");
                this.cond = !checkOnStart || this.getInputData(1);
                this.k = 0;
                var cycleLimit = this.properties.cycleLimit || 999;
                while (this.cond && this.k<cycleLimit) {
                    console.debug?.("while cycle "+this.k);
                    this.setOutputData(1, this.k);
                    this.triggerSlot(0, param);
                    // done
                    if (this.stopped) {
                        console.debug?.("while cycle stopped on index "+k);
                        break;
                    }
                    this.k++;
                    this.cond = this.getInputData(1,true,true); // CHECK THIS : USING FORCE ANCESTOR REFRESH ( ?!? getInputData refresh_tree )
                }
                this.k = 0;
                this.setOutputData(1, this.k);
                this.cond = this.getInputData(1);
                this.started = false;
                this.stopped = true;
                break;
        }
    }
}
LiteGraph.registerNodeType("logic/CycleWHILE", logicWhile);



class GraphicsPlot {

    static title = "Plot";
    static desc = "Plots data over time";

    constructor() {
        this.addInput("A", "Number");
        this.addInput("B", "Number");
        this.addInput("C", "Number");
        this.addInput("D", "Number");

        this.values = [[], [], [], []];
        this.properties = { scale: 2 };
    }

    onExecute() {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        for (var i = 0; i < 4; ++i) {
            var v = this.getInputData(i);
            if (v == null) {
                continue;
            }
            var values = this.values[i];
            values.push(v);
            if (values.length > size[0]) {
                values.shift();
            }
        }
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        var scale = (0.5 * size[1]) / this.properties.scale;
        var colors = GraphicsPlot.colors;
        var offset = size[1] * 0.5;

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, size[0], size[1]);
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(size[0], offset);
        ctx.stroke();

        if (this.inputs) {
            for (let i = 0; i < 4; ++i) {
                let values = this.values[i];
                if (!this.inputs[i] || !this.inputs[i].link) {
                    continue;
                }
                ctx.strokeStyle = colors[i];
                ctx.beginPath();
                let v = values[0] * scale * -1 + offset;
                ctx.moveTo(0, LiteGraph.clamp(v, 0, size[1]));
                for (let j = 1; j < values.length && j < size[0]; ++j) {
                    v = values[j] * scale * -1 + offset;
                    ctx.lineTo(j, LiteGraph.clamp(v, 0, size[1]));
                }
                ctx.stroke();
            }
        }
    }
    static colors = ["#FFF", "#F99", "#9F9", "#99F"];
}
LiteGraph.registerNodeType("graphics/plot", GraphicsPlot);


class GraphicsImage {

    static title = "Image";
    static desc = "Image loader";

    constructor() {
        this.addOutput("frame", "image");
        this.properties = { url: "" };
    }

    onAdded() {
        if (this.properties["url"] != "" && this.img == null) {
            this.loadImage(this.properties["url"]);
        }
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.img && this.size[0] > 5 && this.size[1] > 5 && this.img.width) {
            ctx.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
        }
    }

    onExecute() {
        if (!this.img) {
            this.boxcolor = "#000";
        }
        if (this.img && this.img.width) {
            this.setOutputData(0, this.img);
        } else {
            this.setOutputData(0, null);
        }
        if (this.img && this.img.dirty) {
            this.img.dirty = false;
        }
    }

    onPropertyChanged(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadImage(value);
        }

        return true;
    }

    loadImage(url, callback) {
        if (url == "") {
            this.img = null;
            return;
        }

        this.img = document.createElement("img");

        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this.img.src = url;
        this.boxcolor = "#F95";
        var that = this;
        this.img.onload = function () {
            if (callback) {
                callback(this);
            }
            console.log?.(`Image loaded, size: ${that.img.width}x${that.img.height}`);
            this.dirty = true;
            that.boxcolor = "#9F9";
            that.setDirtyCanvas(true);
        };
        this.img.onerror = function () {
            console.log?.("error loading the image:" + url);
        };
    }

    onWidget(e, widget) {
        if (widget.name == "load") {
            this.loadImage(this.properties["url"]);
        }
    }

    onDropFile(file) {
        var that = this;
        if (this._url) {
            URL.revokeObjectURL(this._url);
        }
        this._url = URL.createObjectURL(file);
        this.properties.url = this._url;
        this.loadImage(this._url, function (img) {
            that.size[1] = (img.height / img.width) * that.size[0];
        });
    }

    static widgets = [{ name: "load", text: "Load", type: "button" }];
    static supported_extensions = ["jpg", "jpeg", "png", "gif"];
}
LiteGraph.registerNodeType("graphics/image", GraphicsImage);


class ColorPalette {

    static title = "Palette";
    static desc = "Generates a color";

    constructor() {
        this.addInput("f", "number");
        this.addOutput("Color", "color");
        this.properties = {
            colorA: "#444444",
            colorB: "#44AAFF",
            colorC: "#44FFAA",
            colorD: "#FFFFFF",
        };
    }

    onExecute() {
        var c = [];

        if (this.properties.colorA != null) {
            c.push(hex2num(this.properties.colorA));
        }
        if (this.properties.colorB != null) {
            c.push(hex2num(this.properties.colorB));
        }
        if (this.properties.colorC != null) {
            c.push(hex2num(this.properties.colorC));
        }
        if (this.properties.colorD != null) {
            c.push(hex2num(this.properties.colorD));
        }

        var f = this.getInputData(0);
        if (f == null) {
            f = 0.5;
        }
        if (f > 1.0) {
            f = 1.0;
        } else if (f < 0.0) {
            f = 0.0;
        }

        if (c.length == 0) {
            return;
        }

        var result = [0, 0, 0];
        if (f == 0) {
            result = c[0];
        } else if (f == 1) {
            result = c[c.length - 1];
        } else {
            var pos = (c.length - 1) * f;
            var c1 = c[Math.floor(pos)];
            var c2 = c[Math.floor(pos) + 1];
            var t = pos - Math.floor(pos);
            result[0] = c1[0] * (1 - t) + c2[0] * t;
            result[1] = c1[1] * (1 - t) + c2[1] * t;
            result[2] = c1[2] * (1 - t) + c2[2] * t;
        }

        /*
    c[0] = 1.0 - Math.abs( Math.sin( 0.1 * reModular.getTime() * Math.PI) );
    c[1] = Math.abs( Math.sin( 0.07 * reModular.getTime() * Math.PI) );
    c[2] = Math.abs( Math.sin( 0.01 * reModular.getTime() * Math.PI) );
    */

        for (var i = 0; i < result.length; i++) {
            result[i] /= 255;
        }

        this.boxcolor = colorToString(result);
        this.setOutputData(0, result);
    }
}
LiteGraph.registerNodeType("color/palette", ColorPalette);


class ImageFrame {

    static title = "Frame";
    static desc = "Frame viewer";

    constructor() {
        this.addInput("", "image,canvas");
        this.size = [200, 200];
    }

    onDrawBackground(ctx) {
        if (this.frame && !this.flags.collapsed) {
            ctx.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
        }
    }

    onExecute() {
        this.frame = this.getInputData(0);
        this.setDirtyCanvas(true);
    }

    onWidget(e, widget) {
        if (widget.name == "resize" && this.frame) {
            var width = this.frame.width;
            var height = this.frame.height;

            if (!width && this.frame.videoWidth != null) {
                width = this.frame.videoWidth;
                height = this.frame.videoHeight;
            }

            if (width && height) {
                this.size = [width, height];
            }
            this.setDirtyCanvas(true, true);
        } else if (widget.name == "view") {
            this.show();
        }
    }

    show() {
        // var str = this.canvas.toDataURL("image/png");
        if (showElement && this.frame) {
            showElement(this.frame);
        }
    }

    static widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "view", text: "View Image", type: "button" },
    ];
}
LiteGraph.registerNodeType("graphics/frame", ImageFrame);


class ImageFade {

    static title = "Image fade";
    static desc = "Fades between images";

    constructor() {
        this.addInputs([
            ["img1", "image"],
            ["img2", "image"],
            ["fade", "number"],
        ]);
        this.addOutput("", "image");
        this.properties = { fade: 0.5, width: 512, height: 512 };
    }

    onAdded() {
        this.createCanvas();
        var ctx = this.canvas.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, this.properties["width"], this.properties["height"]);
    }

    createCanvas() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    }

    onExecute() {
        var ctx = this.canvas.getContext("2d");
        // this.canvas.width = this.canvas.width; //@BUG: Test with this excised, I couldn't find a setter

        var A = this.getInputData(0);
        if (A != null) {
            ctx.drawImage(A, 0, 0, this.canvas.width, this.canvas.height);
        }

        var fade = this.getInputData(2);
        if (fade == null) {
            fade = this.properties["fade"];
        } else {
            this.properties["fade"] = fade;
        }

        ctx.globalAlpha = fade;
        var B = this.getInputData(1);
        if (B != null) {
            ctx.drawImage(B, 0, 0, this.canvas.width, this.canvas.height);
        }
        ctx.globalAlpha = 1.0;

        this.setOutputData(0, this.canvas);
        this.setDirtyCanvas(true);
    }

    static widgets = [
        { name: "resizeA", text: "Resize to A", type: "button" },
        { name: "resizeB", text: "Resize to B", type: "button" },
    ];
}
LiteGraph.registerNodeType("graphics/imagefade", ImageFade);


class ImageCrop {

    static title = "Crop";
    static desc = "Crop Image";

    constructor() {
        this.addInput("", "image");
        this.addOutput("", "image");
        this.properties = { width: 256, height: 256, x: 0, y: 0, scale: 1.0 };
        this.size = [50, 20];
    }

    onAdded() {
        this.createCanvas();
    }

    createCanvas() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    }

    onExecute() {
        var input = this.getInputData(0);
        if (!input) {
            return;
        }

        if (input.width) {
            var ctx = this.canvas.getContext("2d");

            ctx.drawImage(
                input,
                -this.properties["x"],
                -this.properties["y"],
                input.width * this.properties["scale"],
                input.height * this.properties["scale"],
            );
            this.setOutputData(0, this.canvas);
        } else {
            this.setOutputData(0, null);
        }
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.canvas) {
            ctx.drawImage(
                this.canvas,
                0,
                0,
                this.canvas.width,
                this.canvas.height,
                0,
                0,
                this.size[0],
                this.size[1],
            );
        }
    }

    onPropertyChanged(name, value) {
        this.properties[name] = value;

        if (name == "scale") {
            this.properties[name] = parseFloat(value);
            if (this.properties[name] == 0) {
                console.error?.("Error in scale");
                this.properties[name] = 1.0;
            }
        } else {
            this.properties[name] = parseInt(value);
        }

        this.createCanvas();

        return true;
    }
}
LiteGraph.registerNodeType("graphics/cropImage", ImageCrop);


class CanvasNode {

    static title = "Canvas";
    static desc = "Canvas to render stuff";

    constructor() {
        this.addInput("clear", LiteGraph.ACTION);
        this.addOutput("", "canvas");
        this.properties = { width: 512, height: 512, autoclear: true };

        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
    }

    onExecute() {
        var canvas = this.canvas;
        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (canvas.width != w) {
            canvas.width = w;
        }
        if (canvas.height != h) {
            canvas.height = h;
        }

        if (this.properties.autoclear) {
            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        this.setOutputData(0, canvas);
    }

    onAction(action) {
        if (action == "clear") {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }
}
LiteGraph.registerNodeType("graphics/canvas", CanvasNode);


class DrawImageNode {

    static title = "DrawImage";
    static desc = "Draws image into a canvas";

    constructor() {
        this.addInput("canvas", "canvas");
        this.addInput("img", "image,canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.properties = { x: 0, y: 0, opacity: 1 };
    }

    onExecute() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var img = this.getInputOrProperty("img");
        if (!img) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, x, y);
    }
}
LiteGraph.registerNodeType("graphics/drawImage", DrawImageNode);


class DrawRectangleNode {

    static title = "DrawRectangle";
    static desc = "Draws rectangle in canvas";

    constructor() {
        this.addInput("canvas", "canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addInput("w", "number");
        this.addInput("h", "number");
        this.properties = {
            x: 0,
            y: 0,
            w: 10,
            h: 10,
            color: "white",
            opacity: 1,
        };
    }

    onExecute() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var w = this.getInputOrProperty("w");
        var h = this.getInputOrProperty("h");
        var ctx = canvas.getContext("2d");
        ctx.fillRect(x, y, w, h);
    }
}
LiteGraph.registerNodeType("graphics/drawRectangle", DrawRectangleNode);


class ImageVideo {

    static title = "Video";
    static desc = "Video playback";

    constructor() {
        this.addInput("t", "number");
        this.addOutputs([
            ["frame", "image"],
            ["t", "number"],
            ["d", "number"],
        ]);
        this.properties = { url: "", use_proxy: true };
    }

    onExecute() {
        if (!this.properties.url) {
            return;
        }

        if (this.properties.url != this._video_url) {
            this.loadVideo(this.properties.url);
        }

        if (!this._video || this._video.width == 0) {
            return;
        }

        var t = this.getInputData(0);
        if (t && t >= 0 && t <= 1.0) {
            this._video.currentTime = t * this._video.duration;
            this._video.pause();
        }

        this._video.dirty = true;
        this.setOutputData(0, this._video);
        this.setOutputData(1, this._video.currentTime);
        this.setOutputData(2, this._video.duration);
        this.setDirtyCanvas(true);
    }

    onStart() {
        this.play();
    }

    onStop() {
        this.stop();
    }

    loadVideo(url) {
        this._video_url = url;

        var pos = url.substr(0, 10).indexOf(":");
        var protocol = "";
        if (pos != -1) protocol = url.substr(0, pos);

        var host = "";
        if (protocol) {
            host = url.substr(0, url.indexOf("/", protocol.length + 3));
            host = host.substr(protocol.length + 3);
        }

        if (
            this.properties.use_proxy &&
            protocol &&
            LiteGraph.proxy &&
            host != location.host
        ) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this._video = document.createElement("video");
        this._video.src = url;
        this._video.type = "type=video/mp4";

        this._video.muted = true;
        this._video.autoplay = true;

        var that = this;
        this._video.addEventListener("loadedmetadata", (_event) => {
            // onload
            console.log?.("Duration: " + this.duration + " seconds");
            console.log?.("Size: " + this.videoWidth + "," + this.videoHeight);
            that.setDirtyCanvas(true);
            this.width = this.videoWidth;
            this.height = this.videoHeight;
        });
        this._video.addEventListener("progress", (_event) => {
            // onload
            console.log?.("video loading...");
        });
        this._video.addEventListener("error", (_event) => {
            console.error?.("Error loading video: " + this.src);
            if (this.error) {
                switch (this.error.code) {
                    case this.error.MEDIA_ERR_ABORTED:
                        console.error?.("You stopped the video.");
                        break;
                    case this.error.MEDIA_ERR_NETWORK:
                        console.error?.("Network error - please try again later.");
                        break;
                    case this.error.MEDIA_ERR_DECODE:
                        console.error?.("Video is broken..");
                        break;
                    case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        console.error?.("Sorry, your browser can't play this video.");
                        break;
                }
            }
        });

        this._video.addEventListener("ended", (_event) => {
            console.log?.("Video Ended.");
            this.play(); // loop
        });
        // document.body.appendChild(this.video);
    }

    onPropertyChanged(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadVideo(value);
        }

        return true;
    }

    play() {
        if (this._video && this._video.videoWidth) {
            // is loaded
            this._video.play();
        }
    }

    playPause() {
        if (!this._video) {
            return;
        }
        if (this._video.paused) {
            this.play();
        } else {
            this.pause();
        }
    }

    stop() {
        if (!this._video) {
            return;
        }
        this._video.pause();
        this._video.currentTime = 0;
    }

    pause() {
        if (!this._video) {
            return;
        }
        console.log?.("Video paused");
        this._video.pause();
    }

    onWidget(_e, _widget) { // @BUG: Consider excising this, it's dead code
        /*
    if(widget.name == "demo")
    {
        this.loadVideo();
    }
    else if(widget.name == "play")
    {
        if(this._video)
            this.playPause();
    }
    if(widget.name == "stop")
    {
        this.stop();
    }
    else if(widget.name == "mute")
    {
        if(this._video)
            this._video.muted = !this._video.muted;
    }
    */
    }

    static widgets = [
        { name: "play", text: "PLAY", type: "minibutton" },
        { name: "stop", text: "STOP", type: "minibutton" },
        { name: "demo", text: "Demo video", type: "button" },
        { name: "mute", text: "Mute video", type: "button" },
    ];
}
LiteGraph.registerNodeType("graphics/video", ImageVideo);


class ImageWebcam {

    static title = "Webcam";
    static desc = "Webcam image";

    constructor() {
        this.addOutput("Webcam", "image");
        this.properties = { filterFacingMode: false, facingMode: "user" };
        this.boxcolor = "black";
        this.frame = 0;
    }

    openStream() {
        if (!navigator.mediaDevices.getUserMedia) {
            console.log?.("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        var constraints = {
            audio: false,
            video: !this.properties.filterFacingMode
                ? true
                : { facingMode: this.properties.facingMode },
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(e) {
            console.log?.("Webcam rejected", e);
            that._webcam_stream = false;
            ImageWebcam.is_webcam_open = false;
            that.boxcolor = "red";
            that.trigger("stream_error");
        }
    }

    closeStream() {
        if (this._webcam_stream) {
            var tracks = this._webcam_stream.getTracks();
            if (tracks.length) {
                for (var i = 0; i < tracks.length; ++i) {
                    tracks[i].stop();
                }
            }
            ImageWebcam.is_webcam_open = false;
            this._webcam_stream = null;
            this._video = null;
            this.boxcolor = "black";
            this.trigger("stream_closed");
        }
    }

    onPropertyChanged(name, value) {
        if (name == "facingMode") {
            this.properties.facingMode = value;
            this.closeStream();
            this.openStream();
        }
    }

    onRemoved() {
        this.closeStream();
    }

    streamReady(localMediaStream) {
        this._webcam_stream = localMediaStream;
        // this._waiting_confirmation = false;
        this.boxcolor = "green";

        var video = this._video;
        if (!video) {
            video = document.createElement("video");
            video.autoplay = true;
            video.srcObject = localMediaStream;
            this._video = video;
            // document.body.appendChild( video ); //debug
            // when video info is loaded (size and so)
            video.onloadedmetadata = function (e) {
                // Ready to go. Do some stuff.
                console.log?.(e);
                ImageWebcam.is_webcam_open = true;
            };
        }

        this.trigger("stream_ready", video);
    }

    onExecute() {
        if (this._webcam_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (!this._video || !this._video.videoWidth) {
            return;
        }

        this._video.frame = ++this.frame;
        this._video.width = this._video.videoWidth;
        this._video.height = this._video.videoHeight;
        this.setOutputData(0, this._video);
        for (var i = 1; i < this.outputs.length; ++i) {
            if (!this.outputs[i]) {
                continue;
            }
            switch (this.outputs[i].name) {
                case "width":
                    this.setOutputData(i, this._video.videoWidth);
                    break;
                case "height":
                    this.setOutputData(i, this._video.videoHeight);
                    break;
            }
        }
    }

    getExtraMenuOptions() {
        var that = this;
        var txt = !that.properties.show ? "Show Frame" : "Hide Frame";
        return [
            {
                content: txt,
                callback: function () {
                    that.properties.show = !that.properties.show;
                },
            },
        ];
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed || this.size[1] <= 20 || !this.properties.show) {
            return;
        }

        if (!this._video) {
            return;
        }

        // render to graph canvas
        ctx.save();
        ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    }

    onGetOutputs() {
        return [
            ["width", "number"],
            ["height", "number"],
            ["stream_ready", LiteGraph.EVENT],
            ["stream_closed", LiteGraph.EVENT],
            ["stream_error", LiteGraph.EVENT],
        ];
    }

    static is_webcam_open = false;
}
LiteGraph.registerNodeType("graphics/webcam", ImageWebcam);


// TODO move this
// LiteGraph.LGraphCanvas.link_type_colors["Texture"] = "#987";

let DEG2RAD = 0.0174532925;


export class LGraphTexture {

    static title = "Texture";
    static desc = "Texture";

    constructor() {
        this.addOutput("tex", "Texture");
        this.addOutput("name", "string");
        this.properties = {
            name: "",
            filter: true,
        };
        this.size = [
            LGraphTexture.image_preview_size,
            LGraphTexture.image_preview_size,
        ];
    }

    static widgets_info = {
        name: { widget: "texture" },
        filter: { widget: "checkbox" },
    };

    // REPLACE THIS TO INTEGRATE WITH YOUR FRAMEWORK
    static loadTextureCallback = null; // function in charge of loading textures when not present in the container
    static image_preview_size = 256;

    // flags to choose output texture type
    static UNDEFINED = 0; // not specified
    static PASS_THROUGH = 1; // do not apply FX (like disable but passing the in to the out)
    static COPY = 2; // create new texture with the same properties as the origin texture
    static LOW = 3; // create new texture with low precision (byte)
    static HIGH = 4; // create new texture with high precision (half-float)
    static REUSE = 5; // reuse input texture
    static DEFAULT = 2; // use the default

    static MODE_VALUES = {
        undefined: LGraphTexture.UNDEFINED,
        "pass through": LGraphTexture.PASS_THROUGH,
        copy: LGraphTexture.COPY,
        low: LGraphTexture.LOW,
        high: LGraphTexture.HIGH,
        reuse: LGraphTexture.REUSE,
        default: LGraphTexture.DEFAULT,
    };

    // returns the container where all the loaded textures are stored (overwrite if you have a Resources Manager)
    static getTexturesContainer() {
        return gl.textures;
    }

    // process the loading of a texture (overwrite it if you have a Resources Manager)
    static loadTexture(name, options) {
        options = options || {};
        var url = name;
        if (url.substr(0, 7) == "http://") {
            if (LiteGraph.proxy) {
                // proxy external files
                url = LiteGraph.proxy + url.substr(7);
            }
        }

        var container = LGraphTexture.getTexturesContainer();
        var tex = (container[name] = GL.Texture.fromURL(url, options));
        return tex;
    }

    static getTexture(name) {
        var container = this.getTexturesContainer();

        if (!container) {
            throw new Error("Cannot load texture, container of textures not found");
        }

        var tex = container[name];
        if (!tex && name && name[0] != ":") {
            return this.loadTexture(name);
        }

        return tex;
    }

    // used to compute the appropiate output texture
    static getTargetTexture(origin, target, mode) {
        if (!origin) {
            throw new Error("LGraphTexture.getTargetTexture expects a reference texture");
        }

        var tex_type = null;

        switch (mode) {
            case LGraphTexture.LOW:
                tex_type = gl.UNSIGNED_BYTE;
                break;
            case LGraphTexture.HIGH:
                tex_type = gl.HIGH_PRECISION_FORMAT;
                break;
            case LGraphTexture.REUSE:
                return origin;
            default:
                tex_type = origin ? origin.type : gl.UNSIGNED_BYTE;
                break;
        }

        if (
            !target ||
            target.width != origin.width ||
            target.height != origin.height ||
            target.type != tex_type ||
            target.format != origin.format
        ) {
            target = new GL.Texture(origin.width, origin.height, {
                type: tex_type,
                format: origin.format,
                filter: gl.LINEAR,
            });
        }

        return target;
    }

    static getTextureType(precision, ref_texture) {
        var type = ref_texture ? ref_texture.type : gl.UNSIGNED_BYTE;
        switch (precision) {
            case LGraphTexture.HIGH:
                type = gl.HIGH_PRECISION_FORMAT;
                break;
            case LGraphTexture.LOW:
                type = gl.UNSIGNED_BYTE;
                break;
            // no default
        }
        return type;
    }

    static getWhiteTexture() {
        if (this._white_texture) {
            return this._white_texture;
        }
        var texture = (this._white_texture = GL.Texture.fromMemory(
            1,
            1,
            [255, 255, 255, 255],
            { format: gl.RGBA, wrap: gl.REPEAT, filter: gl.NEAREST },
        ));
        return texture;
    }

    static getNoiseTexture() {
        if (this._noise_texture) {
            return this._noise_texture;
        }

        var noise = new Uint8Array(512 * 512 * 4);
        for (var i = 0; i < 512 * 512 * 4; ++i) {
            noise[i] = Math.random() * 255;
        }

        var texture = GL.Texture.fromMemory(512, 512, noise, {
            format: gl.RGBA,
            wrap: gl.REPEAT,
            filter: gl.NEAREST,
        });
        this._noise_texture = texture;
        return texture;
    }

    onDropFile(data, filename, file) {
        if (!data) {
            this._drop_texture = null;
            this.properties.name = "";
        } else {
            var texture = null;
            if (typeof data == "string") {
                texture = GL.Texture.fromURL(data);
            } else if (filename.toLowerCase().indexOf(".dds") != -1) {
                texture = GL.Texture.fromDDSInMemory(data);
            } else {
                var blob = new Blob([file]);
                var url = URL.createObjectURL(blob);
                texture = GL.Texture.fromURL(url);
            }

            this._drop_texture = texture;
            this.properties.name = filename;
        }
    }

    getExtraMenuOptions() {
        var that = this;
        if (!this._drop_texture) {
            return;
        }
        return [
            {
                content: "Clear",
                callback: function () {
                    that._drop_texture = null;
                    that.properties.name = "";
                },
            },
        ];
    }

    onExecute() {
        var tex = null;
        if (this.isOutputConnected(1)) {
            tex = this.getInputData(0);
        }

        if (!tex && this._drop_texture) {
            tex = this._drop_texture;
        }

        if (!tex && this.properties.name) {
            tex = LGraphTexture.getTexture(this.properties.name);
        }

        if (!tex) {
            this.setOutputData(0, null);
            this.setOutputData(1, "");
            return;
        }

        this._last_tex = tex;

        if (this.properties.filter === false) {
            tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        } else {
            tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        this.setOutputData(0, tex);
        this.setOutputData(1, tex.fullpath || tex.filename);

        for (var i = 2; i < this.outputs.length; i++) {
            var output = this.outputs[i];
            if (!output) {
                continue;
            }
            var v = null;
            if (output.name == "width") {
                v = tex.width;
            } else if (output.name == "height") {
                v = tex.height;
            } else if (output.name == "aspect") {
                v = tex.width / tex.height;
            }
            this.setOutputData(i, v);
        }
    }

    onResourceRenamed(old_name, new_name) {
        if (this.properties.name == old_name) {
            this.properties.name = new_name;
        }
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed || this.size[1] <= 20) {
            return;
        }

        if (this._drop_texture && ctx.webgl) {
            ctx.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
            // this._drop_texture.renderQuad(this.pos[0],this.pos[1],this.size[0],this.size[1]);
            return;
        }

        // Different texture? then get it from the GPU
        if (this._last_preview_tex != this._last_tex) {
            if (ctx.webgl) {
                this._canvas = this._last_tex;
            } else {
                var tex_canvas = LGraphTexture.generateLowResTexturePreview(this._last_tex);
                if (!tex_canvas) {
                    return;
                }

                this._last_preview_tex = this._last_tex;
                this._canvas = GL.cloneCanvas(tex_canvas);
            }
        }

        if (!this._canvas) {
            return;
        }

        // render to graph canvas
        ctx.save();
        if (!ctx.webgl) {
            // reverse image
            ctx.translate(0, this.size[1]);
            ctx.scale(1, -1);
        }
        ctx.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    }

    // very slow, used at your own risk
    static generateLowResTexturePreview(tex) {
        if (!tex) {
            return null;
        }

        var size = LGraphTexture.image_preview_size;
        var temp_tex = tex;

        if (tex.format == gl.DEPTH_COMPONENT) {
            return null;
        } // cannot generate from depth

        // Generate low-level version in the GPU to speed up
        if (tex.width > size || tex.height > size) {
            temp_tex = this._preview_temp_tex;
            if (!this._preview_temp_tex) {
                temp_tex = new GL.Texture(size, size, {minFilter: gl.NEAREST});
                this._preview_temp_tex = temp_tex;
            }

            // copy
            tex.copyTo(temp_tex);
            tex = temp_tex;
        }

        // create intermediate canvas with lowquality version
        var tex_canvas = this._preview_canvas;
        if (!tex_canvas) {
            tex_canvas = GL.createCanvas(size, size);
            this._preview_canvas = tex_canvas;
        }

        if (temp_tex) {
            temp_tex.toCanvas(tex_canvas);
        }
        return tex_canvas;
    }

    getResources(res) {
        if (this.properties.name) res[this.properties.name] = GL.Texture;
        return res;
    }

    onGetInputs() {
        return [["in", "Texture"]];
    }

    onGetOutputs() {
        return [
            ["width", "number"],
            ["height", "number"],
            ["aspect", "number"],
        ];
    }

    // used to replace shader code
    static replaceCode(code, context) {
        return code.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function (v) {
            v = v.replace(/[\{\}]/g, ""); // @BUG: These escapes are being flagged as useless
            return context[v] || "";
        });
    }
}
LiteGraph.registerNodeType("texture/texture", LGraphTexture);

//* *************************
class LGraphTexturePreview {
    constructor() {
        this.addInput("Texture", "Texture");
        this.properties = { flipY: false };
        this.size = [
            LGraphTexture.image_preview_size,
            LGraphTexture.image_preview_size,
        ];
    }

    static title = "Preview";
    static desc = "Show a texture in the graph canvas";
    static allow_preview = false;

    onDrawBackground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (!ctx.webgl && !LGraphTexturePreview.allow_preview) {
            return;
        } // not working well

        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        var tex_canvas = null;

        if (!tex.handle && ctx.webgl) {
            tex_canvas = tex;
        } else {
            tex_canvas = LGraphTexture.generateLowResTexturePreview(tex);
        }

        // render to graph canvas
        ctx.save();
        if (this.properties.flipY) {
            ctx.translate(0, this.size[1]);
            ctx.scale(1, -1);
        }
        ctx.drawImage(tex_canvas, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    }
}
LiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);

//* *************************************

class LGraphTextureSave {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("tex", "Texture");
        this.addOutput("name", "string");
        this.properties = { name: "", generate_mipmaps: false };
    }

    static title = "Save";
    static desc = "Save a texture in the repository";

    getPreviewTexture() {
        return this._texture;
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (this.properties.generate_mipmaps) {
            tex.bind(0);
            tex.setParameter(gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(tex.texture_type);
            tex.unbind(0);
        }

        if (this.properties.name) {
            // for cases where we want to perform something when storing it
            if (LGraphTexture.storeTexture) {
                LGraphTexture.storeTexture(this.properties.name, tex);
            } else {
                var container = LGraphTexture.getTexturesContainer();
                container[this.properties.name] = tex;
            }
        }

        this._texture = tex;
        this.setOutputData(0, tex);
        this.setOutputData(1, this.properties.name);
    }
}
LiteGraph.registerNodeType("texture/save", LGraphTextureSave);

//* ***************************************************

class LGraphTextureOperation {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("TextureB", "Texture");
        this.addInput("value", "number");
        this.addOutput("Texture", "Texture");
        this.help =
            "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\
        <p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";

        this.properties = {
            value: 1,
            pixelcode: "color + colorB * value",
            uvcode: "",
            precision: LGraphTexture.DEFAULT,
        };

        this.has_error = false;
    }

    static widgets_info = {
        uvcode: { widget: "code" },
        pixelcode: { widget: "code" },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    static title = "Operation";
    static desc = "Texture shader operation";

    static presets = {};

    getExtraMenuOptions() {
        var that = this;
        var txt = !that.properties.show ? "Show Texture" : "Hide Texture";
        return [
            {
                content: txt,
                callback: function () {
                    that.properties.show = !that.properties.show;
                },
            },
        ];
    }

    onPropertyChanged() {
        this.has_error = false;
    }

    onDrawBackground(ctx) {
        if (
            this.flags.collapsed ||
            this.size[1] <= 20 ||
            !this.properties.show
        ) {
            return;
        }

        if (!this._tex) {
            return;
        }

        // only works if using a webgl renderer
        if (this._tex.gl != ctx) {
            return;
        }

        // render to graph canvas
        ctx.save();
        ctx.drawImage(this._tex, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    }

    onExecute() {
        var tex = this.getInputData(0);

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        var texB = this.getInputData(1);

        if (!this.properties.uvcode && !this.properties.pixelcode) {
            return;
        }

        var width = 512;
        var height = 512;
        if (tex) {
            width = tex.width;
            height = tex.height;
        } else if (texB) {
            width = texB.width;
            height = texB.height;
        }

        if (!texB) texB = GL.Texture.getWhiteTexture();

        var type = LGraphTexture.getTextureType(this.properties.precision, tex);

        if (!tex && !this._tex) {
            this._tex = new GL.Texture(width, height, {
                type: type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        } else {
            this._tex = LGraphTexture.getTargetTexture(
                tex || this._tex,
                this._tex,
                this.properties.precision,
            );
        }

        var uvcode = "";
        if (this.properties.uvcode) {
            uvcode = "uv = " + this.properties.uvcode;
            if (this.properties.uvcode.indexOf(";") != -1) {
                // there are line breaks, means multiline code
                uvcode = this.properties.uvcode;
            }
        }

        var pixelcode = "";
        if (this.properties.pixelcode) {
            pixelcode = "result = " + this.properties.pixelcode;
            if (this.properties.pixelcode.indexOf(";") != -1) {
                // there are line breaks, means multiline code
                pixelcode = this.properties.pixelcode;
            }
        }

        var shader = this._shader;

        if (
            !this.has_error &&
            (!shader || this._shader_code != uvcode + "|" + pixelcode)
        ) {
            var final_pixel_code = LGraphTexture.replaceCode(
                LGraphTextureOperation.pixel_shader,
                { UV_CODE: uvcode, PIXEL_CODE: pixelcode },
            );

            try {
                shader = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    final_pixel_code,
                );
                this.boxcolor = "#00FF00";
            } catch (err) {
                // console.log?.("Error compiling shader: ", err, final_pixel_code );
                GL.Shader.dumpErrorToConsole(
                    err,
                    Shader.SCREEN_VERTEX_SHADER,
                    final_pixel_code,
                );
                this.boxcolor = "#FF0000";
                this.has_error = true;
                return;
            }
            this._shader = shader;
            this._shader_code = uvcode + "|" + pixelcode;
        }

        if (!this._shader) return;

        var value = this.getInputData(2);
        if (value != null) {
            this.properties.value = value;
        } else {
            value = parseFloat(this.properties.value);
        }

        var time = this.graph.getTime();

        this._tex.drawTo(function () {
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            if (tex) {
                tex.bind(0);
            }
            if (texB) {
                texB.bind(1);
            }
            var mesh = Mesh.getScreenQuad();
            shader
                .uniforms({
                    u_texture: 0,
                    u_textureB: 1,
                    value: value,
                    texSize: [width, height, 1 / width, 1 / height],
                    time: time,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader = `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform vec4 texSize;
        uniform float time;
        uniform float value;
    
        void main() {
            vec2 uv = v_coord;
            {{UV_CODE}};
            vec4 color4 = texture2D(u_texture, uv);
            vec3 color = color4.rgb;
            vec4 color4B = texture2D(u_textureB, uv);
            vec3 colorB = color4B.rgb;
            vec3 result = color;
            float alpha = 1.0;
            {{PIXEL_CODE}};
            gl_FragColor = vec4(result, alpha);
        }
    `;

    static registerPreset(name, code) {
        LGraphTextureOperation.presets[name] = code;
    }


    // webglstudio stuff...
    onInspect(widgets) {
        var that = this;
        widgets.addCombo("Presets", "", {
            values: Object.keys(LGraphTextureOperation.presets),
            callback: function (v) {
                var code = LGraphTextureOperation.presets[v];
                if (!code)
                    return;
                that.setProperty("pixelcode", code);
                that.title = v;
                widgets.refresh();
            },
        });
    }
}

// these are calls, not declarations!
LGraphTextureOperation.registerPreset("", "");
LGraphTextureOperation.registerPreset("bypass", "color");
LGraphTextureOperation.registerPreset("add", "color + colorB * value");
LGraphTextureOperation.registerPreset(
    "substract",
    "(color - colorB) * value",
);
LGraphTextureOperation.registerPreset(
    "mate",
    "mix( color, colorB, color4B.a * value)",
);
LGraphTextureOperation.registerPreset("invert", "vec3(1.0) - color");
LGraphTextureOperation.registerPreset("multiply", "color * colorB * value");
LGraphTextureOperation.registerPreset("divide", "(color / colorB) / value");
LGraphTextureOperation.registerPreset(
    "difference",
    "abs(color - colorB) * value",
);
LGraphTextureOperation.registerPreset("max", "max(color, colorB) * value");
LGraphTextureOperation.registerPreset("min", "min(color, colorB) * value");
LGraphTextureOperation.registerPreset(
    "displace",
    "texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz",
);
LGraphTextureOperation.registerPreset(
    "grayscale",
    "vec3(color.x + color.y + color.z) * value / 3.0",
);
LGraphTextureOperation.registerPreset(
    "saturation",
    "mix( vec3(color.x + color.y + color.z) / 3.0, color, value )",
);
LGraphTextureOperation.registerPreset(
    "normalmap",
    "\n\
    float z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;\n\
    float z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;\n\
    float z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;\n\
    float z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;\n\
    float z4 = color.x;\n\
    float z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;\n\
    float z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;\n\
    float z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;\n\
    float z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;\n\
    vec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );\n\
    normal.xy *= value;\n\
    result.xyz = normalize(normal) * 0.5 + vec3(0.5);\n\
",
);
LGraphTextureOperation.registerPreset(
    "threshold",
    "vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)",
);
LiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);


class LGraphTextureShader {
    constructor() {
        this.addOutput("out", "Texture");
        this.properties = {
            code: "",
            u_value: 1,
            u_color: [1, 1, 1, 1],
            width: 512,
            height: 512,
            precision: LGraphTexture.DEFAULT,
        };

        this.properties.code = LGraphTextureShader.pixel_shader;
        this._uniforms = {
            u_value: 1,
            u_color: vec4.create(),
            in_texture: 0,
            texSize: vec4.create(),
            time: 0,
        };
    }

    static title = "Shader";
    static desc = "Texture shader";
    static widgets_info = {
        code: { type: "code", lang: "glsl" },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onPropertyChanged(name, _value) {
        if (name != "code") {
            return;
        }

        var shader = this.getShader();
        if (!shader) {
            return;
        }

        // update connections
        var uniforms = shader.uniformInfo;

        // remove deprecated slots
        if (this.inputs) {
            var already = {};
            for (let i = 0; i < this.inputs.length; ++i) {
                let info = this.getInputInfo(i);
                if (!info) {
                    continue;
                }

                if (uniforms[info.name] && !already[info.name]) {
                    already[info.name] = true;
                    continue;
                }
                this.removeInput(i);
                i--;
            }
        }

        // update existing ones
        for (let i in uniforms) {
            let info = shader.uniformInfo[i];
            if (info.loc === null) {
                continue;
            } // is an attribute, not a uniform
            if (i == "time") {
                // default one
                continue;
            }

            var type = "number";
            if (this._shader.samplers[i]) {
                type = "texture";
            } else {
                switch (info.size) {
                    case 1:
                        type = "number";
                        break;
                    case 2:
                        type = "vec2";
                        break;
                    case 3:
                        type = "vec3";
                        break;
                    case 4:
                        type = "vec4";
                        break;
                    case 9:
                        type = "mat3";
                        break;
                    case 16:
                        type = "mat4";
                        break;
                    default:
                        continue;
                }
            }

            var slot = this.findInputSlot(i);
            if (slot == -1) {
                this.addInput(i, type);
                continue;
            }

            var input_info = this.getInputInfo(slot);
            if (!input_info) {
                this.addInput(i, type);
            } else {
                if (input_info.type == type) {
                    continue;
                }
                this.removeInput(slot, type);
                this.addInput(i, type);
            }
        }
    }

    getShader() {
        // replug
        if (this._shader && this._shader_code == this.properties.code) {
            return this._shader;
        }

        this._shader_code = this.properties.code;
        this._shader = new GL.Shader(
            Shader.SCREEN_VERTEX_SHADER,
            this.properties.code,
        );
        if (!this._shader) {
            this.boxcolor = "red";
            return null;
        } else {
            this.boxcolor = "green";
        }
        return this._shader;
    }

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var shader = this.getShader();
        if (!shader) {
            return;
        }

        var tex_slot = 0;
        var in_tex = null;

        // set uniforms
        if (this.inputs)
            for (var i = 0; i < this.inputs.length; ++i) {
                var info = this.getInputInfo(i);
                var data = this.getInputData(i);
                if (data == null) {
                    continue;
                }

                if (data.constructor === GL.Texture) {
                    data.bind(tex_slot);
                    if (!in_tex) {
                        in_tex = data;
                    }
                    data = tex_slot;
                    tex_slot++;
                }
                shader.setUniform(info.name, data); // data is tex_slot
            }

        var uniforms = this._uniforms;
        var type = LGraphTexture.getTextureType(
            this.properties.precision,
            in_tex,
        );

        // render to texture
        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (w == 0) {
            w = in_tex ? in_tex.width : gl.canvas.width;
        }
        if (h == 0) {
            h = in_tex ? in_tex.height : gl.canvas.height;
        }
        uniforms.texSize[0] = w;
        uniforms.texSize[1] = h;
        uniforms.texSize[2] = 1 / w;
        uniforms.texSize[3] = 1 / h;
        uniforms.time = this.graph.getTime();
        uniforms.u_value = this.properties.u_value;
        uniforms.u_color.set(this.properties.u_color);

        if (
            !this._tex ||
            this._tex.type != type ||
            this._tex.width != w ||
            this._tex.height != h
        ) {
            this._tex = new GL.Texture(w, h, {
                type: type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }
        var tex = this._tex;
        tex.drawTo(function () {
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader = `
        precision highp float;
    
        varying vec2 v_coord;
        uniform float time; // time in seconds
        uniform vec4 texSize; // tex resolution
        uniform float u_value;
        uniform vec4 u_color;
    
        void main() {
            vec2 uv = v_coord;
            vec3 color = vec3(0.0);
            // Your custom code here
            color.xy = uv;
    
            gl_FragColor = vec4(color, 1.0);
        }
    `;
}
LiteGraph.registerNodeType("texture/shader", LGraphTextureShader);


// Texture Scale Offset
class LGraphTextureScaleOffset {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("scale", "vec2");
        this.addInput("offset", "vec2");
        this.addOutput("out", "Texture");
        this.properties = {
            offset: vec2.fromValues(0, 0),
            scale: vec2.fromValues(1, 1),
            precision: LGraphTexture.DEFAULT,
        };
    }

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static title = "Scale/Offset";
    static desc = "Applies an scaling and offseting";

    onExecute() {
        var tex = this.getInputData(0);

        if (!this.isOutputConnected(0) || !tex) {
            return;
        } // saves work

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        var width = tex.width;
        var height = tex.height;
        var type =
            this.precision === LGraphTexture.LOW
                ? gl.UNSIGNED_BYTE
                : gl.HIGH_PRECISION_FORMAT;
        if (this.precision === LGraphTexture.DEFAULT) {
            type = tex.type;
        }

        if (
            !this._tex ||
            this._tex.width != width ||
            this._tex.height != height ||
            this._tex.type != type
        ) {
            this._tex = new GL.Texture(width, height, {
                type: type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var shader = this._shader;

        if (!shader) {
            shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureScaleOffset.pixel_shader,
            );
        }

        var scale = this.getInputData(1);
        if (scale) {
            this.properties.scale[0] = scale[0];
            this.properties.scale[1] = scale[1];
        } else {
            scale = this.properties.scale;
        }

        var offset = this.getInputData(2);
        if (offset) {
            this.properties.offset[0] = offset[0];
            this.properties.offset[1] = offset[1];
        } else {
            offset = this.properties.offset;
        }

        this._tex.drawTo(function () {
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            tex.bind(0);
            var mesh = Mesh.getScreenQuad();
            shader
                .uniforms({
                    u_texture: 0,
                    u_scale: scale,
                    u_offset: offset,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader = `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform vec2 u_scale;
        uniform vec2 u_offset;
    
        void main() {
            vec2 uv = v_coord;
            uv = uv / u_scale - u_offset;
            gl_FragColor = texture2D(u_texture, uv);
        }
    `;
}
LiteGraph.registerNodeType("texture/scaleOffset", LGraphTextureScaleOffset);


class LGraphTextureWarp {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("warp", "Texture");
        this.addInput("factor", "number");
        this.addOutput("out", "Texture");
        this.properties = {
            factor: 0.01,
            scale: [1, 1],
            offset: [0, 0],
            precision: LGraphTexture.DEFAULT,
        };

        this._uniforms = {
            u_texture: 0,
            u_textureB: 1,
            u_factor: 1,
            u_scale: vec2.create(),
            u_offset: vec2.create(),
        };
    }

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static title = "Warp";
    static desc = "Texture warp operation";

    onExecute() {
        var tex = this.getInputData(0);

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        var texB = this.getInputData(1);

        var width = 512;
        var height = 512;
        // var type = gl.UNSIGNED_BYTE;
        if (tex) {
            width = tex.width;
            height = tex.height;
        //  type = tex.type;
        } else if (texB) {
            width = texB.width;
            height = texB.height;
        //  type = texB.type;
        }

        if (!tex && !this._tex) {
            this._tex = new GL.Texture(width, height, {
                type:
                    this.precision === LGraphTexture.LOW
                        ? gl.UNSIGNED_BYTE
                        : gl.HIGH_PRECISION_FORMAT,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        } else {
            this._tex = LGraphTexture.getTargetTexture(
                tex || this._tex,
                this._tex,
                this.properties.precision,
            );
        }

        var shader = this._shader;

        if (!shader) {
            shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureWarp.pixel_shader,
            );
        }

        var factor = this.getInputData(2);
        if (factor != null) {
            this.properties.factor = factor;
        } else {
            factor = parseFloat(this.properties.factor);
        }
        var uniforms = this._uniforms;
        uniforms.u_factor = factor;
        uniforms.u_scale.set(this.properties.scale);
        uniforms.u_offset.set(this.properties.offset);

        this._tex.drawTo(function () {
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            if (tex) {
                tex.bind(0);
            }
            if (texB) {
                texB.bind(1);
            }
            var mesh = Mesh.getScreenQuad();
            shader.uniforms(uniforms).draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    pixel_shader = `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform float u_factor;
        uniform vec2 u_scale;
        uniform vec2 u_offset;
    
        void main() {
            vec2 uv = v_coord;
            uv += (texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;
            gl_FragColor = texture2D(u_texture, uv);
        }
    `;
}
LiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);


class LGraphTextureToViewport {
    constructor() {
        this.addInput("Texture", "Texture");
        this.properties = {
            additive: false,
            antialiasing: false,
            filter: true,
            disable_alpha: false,
            gamma: 1.0,
            viewport: [0, 0, 1, 1],
        };
        this.size[0] = 130;
    }

    static title = "to Viewport";
    static desc = "Texture to viewport";

    static _prev_viewport = new Float32Array(4);

    onDrawBackground(ctx) {
        if (this.flags.collapsed || this.size[1] <= 40) return;

        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        ctx.drawImage(
            ctx == gl ? tex : gl.canvas,
            10,
            30,
            this.size[0] - 20,
            this.size[1] - 40,
        );
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (this.properties.disable_alpha) {
            gl.disable(gl.BLEND);
        } else {
            gl.enable(gl.BLEND);
            if (this.properties.additive) {
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            } else {
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }
        }

        gl.disable(gl.DEPTH_TEST);
        var gamma = this.properties.gamma || 1.0;
        if (this.isInputConnected(1)) {
            gamma = this.getInputData(1);
        }

        tex.setParameter(
            gl.TEXTURE_MAG_FILTER,
            this.properties.filter ? gl.LINEAR : gl.NEAREST,
        );

        var old_viewport = LGraphTextureToViewport._prev_viewport;
        old_viewport.set(gl.viewport_data);
        var new_view = this.properties.viewport;
        gl.viewport(
            old_viewport[0] + old_viewport[2] * new_view[0],
            old_viewport[1] + old_viewport[3] * new_view[1],
            old_viewport[2] * new_view[2],
            old_viewport[3] * new_view[3],
        );

        if (this.properties.antialiasing) {
            if (!LGraphTextureToViewport._shader) {
                LGraphTextureToViewport._shader = new GL.Shader(
                    GL.Shader.SCREEN_VERTEX_SHADER,
                    LGraphTextureToViewport.aa_pixel_shader,
                );
            }

            var mesh = Mesh.getScreenQuad();
            tex.bind(0);
            LGraphTextureToViewport._shader
                .uniforms({
                    u_texture: 0,
                    uViewportSize: [tex.width, tex.height],
                    u_igamma: 1 / gamma,
                    inverseVP: [1 / tex.width, 1 / tex.height],
                })
                .draw(mesh);
        } else {
            if (gamma != 1.0) {
                if (!LGraphTextureToViewport._gamma_shader) {
                    LGraphTextureToViewport._gamma_shader = new GL.Shader(
                        Shader.SCREEN_VERTEX_SHADER,
                        LGraphTextureToViewport.gamma_pixel_shader,
                    );
                }
                tex.toViewport(LGraphTextureToViewport._gamma_shader, {
                    u_texture: 0,
                    u_igamma: 1 / gamma,
                });
            } else {
                tex.toViewport();
            }
        }

        gl.viewport(
            old_viewport[0],
            old_viewport[1],
            old_viewport[2],
            old_viewport[3],
        );
    }

    onGetInputs() {
        return [["gamma", "number"]];
    }

    static aa_pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 uViewportSize;
        uniform vec2 inverseVP;
        uniform float u_igamma;
        #define FXAA_REDUCE_MIN   (1.0/128.0)
        #define FXAA_REDUCE_MUL   (1.0/8.0)
        #define FXAA_SPAN_MAX     8.0
    
        vec4 applyFXAA(sampler2D tex, vec2 fragCoord) {
            vec4 color = vec4(0.0);
            vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbM  = texture2D(tex, fragCoord * inverseVP).xyz;
            vec3 luma = vec3(0.299, 0.587, 0.114);
            
            // Rest of the FXAA algorithm
            
            return color;
        }
    
        void main() {
            gl_FragColor = applyFXAA(u_texture, v_coord * uViewportSize);
        }
    `;

    static gamma_pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_igamma;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            color.xyz = pow(color.xyz, vec3(u_igamma));
            gl_FragColor = color;
        }
    `;
}
LiteGraph.registerNodeType("texture/toviewport", LGraphTextureToViewport);


class LGraphTextureCopy {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("", "Texture");
        this.properties = {
            size: 0,
            generate_mipmaps: false,
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Copy";
    static desc = "Copy Texture";

    static widgets_info = {
        size: {
            widget: "combo",
            values: [0, 32, 64, 128, 256, 512, 1024, 2048],
        },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex && !this._temp_texture) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        // copy the texture
        if (tex) {
            var width = tex.width;
            var height = tex.height;

            if (this.properties.size != 0) {
                width = this.properties.size;
                height = this.properties.size;
            }

            var temp = this._temp_texture;

            var type = tex.type;
            if (this.properties.precision === LGraphTexture.LOW) {
                type = gl.UNSIGNED_BYTE;
            } else if (this.properties.precision === LGraphTexture.HIGH) {
                type = gl.HIGH_PRECISION_FORMAT;
            }

            if (
                !temp ||
                temp.width != width ||
                temp.height != height ||
                temp.type != type
            ) {
                var minFilter = gl.LINEAR;
                if (
                    this.properties.generate_mipmaps &&
                    GL.isPowerOfTwo(width) &&
                    GL.isPowerOfTwo(height)
                ) {
                    minFilter = gl.LINEAR_MIPMAP_LINEAR;
                }
                this._temp_texture = new GL.Texture(width, height, {
                    type: type,
                    format: gl.RGBA,
                    minFilter: minFilter,
                    magFilter: gl.LINEAR,
                });
            }
            tex.copyTo(this._temp_texture);

            if (this.properties.generate_mipmaps) {
                this._temp_texture.bind(0);
                gl.generateMipmap(this._temp_texture.texture_type);
                this._temp_texture.unbind(0);
            }
        }

        this.setOutputData(0, this._temp_texture);
    }
}
LiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);


class LGraphTextureDownsample {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("", "Texture");
        this.properties = {
            iterations: 1,
            generate_mipmaps: false,
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Downsample";
    static desc = "Downsample Texture";

    static widgets_info = {
        iterations: { type: "number", step: 1, precision: 0, min: 0 },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex && !this._temp_texture) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        // we do not allow any texture different than texture 2D
        if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
            return;
        }

        if (this.properties.iterations < 1) {
            this.setOutputData(0, tex);
            return;
        }

        var shader = LGraphTextureDownsample._shader;
        if (!shader) {
            LGraphTextureDownsample._shader = shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureDownsample.pixel_shader,
            );
        }

        var width = tex.width | 0;
        var height = tex.height | 0;
        var type = tex.type;
        if (this.properties.precision === LGraphTexture.LOW) {
            type = gl.UNSIGNED_BYTE;
        } else if (this.properties.precision === LGraphTexture.HIGH) {
            type = gl.HIGH_PRECISION_FORMAT;
        }
        var iterations = this.properties.iterations || 1;

        var origin = tex;
        var target = null;

        var temp = [];
        var options = {
            type: type,
            format: tex.format,
        };

        var offset = vec2.create();
        var uniforms = {u_offset: offset};

        if (this._texture) {
            GL.Texture.releaseTemporary(this._texture);
        }

        for (let i = 0; i < iterations; ++i) {
            offset[0] = 1 / width;
            offset[1] = 1 / height;
            width = width >> 1 || 0;
            height = height >> 1 || 0;
            target = GL.Texture.getTemporary(width, height, options);
            temp.push(target);
            origin.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
            origin.copyTo(target, shader, uniforms);
            if (width == 1 && height == 1) {
                break;
            } // nothing else to do
            origin = target;
        }

        // keep the last texture used
        this._texture = temp.pop();

        // free the rest
        for (let i = 0; i < temp.length; ++i) {
            GL.Texture.releaseTemporary(temp[i]);
        }

        if (this.properties.generate_mipmaps) {
            this._texture.bind(0);
            gl.generateMipmap(this._texture.texture_type);
            this._texture.unbind(0);
        }

        this.setOutputData(0, this._texture);
    }

    static pixel_shader = `
        precision highp float;
        uniform sampler2D u_texture;
        uniform vec2 u_offset;
        varying vec2 v_coord;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            color += texture2D(u_texture, v_coord + vec2(u_offset.x, 0.0));
            color += texture2D(u_texture, v_coord + vec2(0.0, u_offset.y));
            color += texture2D(u_texture, v_coord + u_offset);
            gl_FragColor = color * 0.25;
        }
    `;
}
LiteGraph.registerNodeType("texture/downsample", LGraphTextureDownsample);


class LGraphTextureResize {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("", "Texture");
        this.properties = {
            size: [512, 512],
            generate_mipmaps: false,
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Resize";
    static desc = "Resize Texture";

    static widgets_info = {
        iterations: { type: "number", step: 1, precision: 0, min: 0 },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex && !this._temp_texture) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        // we do not allow any texture different than texture 2D
        if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
            return;
        }

        var width = this.properties.size[0] | 0;
        var height = this.properties.size[1] | 0;
        if (width == 0) width = tex.width;
        if (height == 0) height = tex.height;
        var type = tex.type;
        if (this.properties.precision === LGraphTexture.LOW) {
            type = gl.UNSIGNED_BYTE;
        } else if (this.properties.precision === LGraphTexture.HIGH) {
            type = gl.HIGH_PRECISION_FORMAT;
        }

        if (
            !this._texture ||
            this._texture.width != width ||
            this._texture.height != height ||
            this._texture.type != type
        )
            this._texture = new GL.Texture(width, height, { type: type });

        tex.copyTo(this._texture);

        if (this.properties.generate_mipmaps) {
            this._texture.bind(0);
            gl.generateMipmap(this._texture.texture_type);
            this._texture.unbind(0);
        }

        this.setOutputData(0, this._texture);
    }
}
LiteGraph.registerNodeType("texture/resize", LGraphTextureResize);


class LGraphTextureAverage {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("tex", "Texture");
        this.addOutput("avg", "vec4");
        this.addOutput("lum", "number");
        this.properties = {
            use_previous_frame: true, // to avoid stalls
            high_quality: false, // to use as much pixels as possible
        };

        this._uniforms = {
            u_texture: 0,
            u_mipmap_offset: 0,
        };
        this._luminance = new Float32Array(4);
    }

    static title = "Average";
    static desc =
        "Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.";

    onExecute() {
        if (!this.properties.use_previous_frame) {
            this.updateAverage();
        }

        var v = this._luminance;
        this.setOutputData(0, this._temp_texture);
        this.setOutputData(1, v);
        this.setOutputData(2, (v[0] + v[1] + v[2]) / 3);
    }

    // executed before rendering the frame
    onPreRenderExecute() {
        this.updateAverage();
    }

    updateAverage() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (
            !this.isOutputConnected(0) &&
            !this.isOutputConnected(1) &&
            !this.isOutputConnected(2)
        ) {
            return;
        } // saves work

        if (!LGraphTextureAverage._shader) {
            LGraphTextureAverage._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureAverage.pixel_shader,
            );
            // creates 256 random numbers and stores them in two mat4
            var samples = new Float32Array(16);
            for (var i = 0; i < samples.length; ++i) {
                samples[i] = Math.random(); // poorly distributed samples
            }
            // upload only once
            LGraphTextureAverage._shader.uniforms({
                u_samples_a: samples.subarray(0, 16),
                u_samples_b: samples.subarray(16, 32),
            });
        }

        var temp = this._temp_texture;
        var type = gl.UNSIGNED_BYTE;
        if (tex.type != type) {
            // force floats, half floats cannot be read with gl.readPixels
            type = gl.FLOAT;
        }

        if (!temp || temp.type != type) {
            this._temp_texture = new GL.Texture(1, 1, {
                type: type,
                format: gl.RGBA,
                filter: gl.NEAREST,
            });
        }

        this._uniforms.u_mipmap_offset = 0;

        if (this.properties.high_quality) {
            if (
                !this._temp_pot2_texture ||
                this._temp_pot2_texture.type != type
            )
                this._temp_pot2_texture = new GL.Texture(512, 512, {
                    type: type,
                    format: gl.RGBA,
                    minFilter: gl.LINEAR_MIPMAP_LINEAR,
                    magFilter: gl.LINEAR,
                });

            tex.copyTo(this._temp_pot2_texture);
            tex = this._temp_pot2_texture;
            tex.bind(0);
            gl.generateMipmap(GL.TEXTURE_2D);
            this._uniforms.u_mipmap_offset = 9;
        }

        var shader = LGraphTextureAverage._shader;
        var uniforms = this._uniforms;
        uniforms.u_mipmap_offset = this.properties.mipmap_offset;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        this._temp_texture.drawTo(function () {
            tex.toViewport(shader, uniforms);
        });

        if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
            var pixel = this._temp_texture.getPixels();
            if (pixel) {
                var v = this._luminance;
                type = this._temp_texture.type;
                v.set(pixel);
                if (type == gl.UNSIGNED_BYTE) {
                    vec4.scale(v, v, 1 / 255);
                } else if (type == GL.HALF_FLOAT || type == GL.HALF_FLOAT_OES) {
                    // no half floats possible, hard to read back unless copyed to a FLOAT texture, so temp_texture is always forced to FLOAT
                }
            }
        }
    }

    static pixel_shader = `
        precision highp float;
        uniform mat4 u_samples_a;
        uniform mat4 u_samples_b;
        uniform sampler2D u_texture;
        uniform float u_mipmap_offset;
        varying vec2 v_coord;
    
        void main() {
            vec4 color = vec4(0.0);
            
            // Random average
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    color += texture2D(u_texture, vec2(u_samples_a[i][j], u_samples_b[i][j]), u_mipmap_offset);
                    color += texture2D(u_texture, vec2(1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j]), u_mipmap_offset);
                }
            }
            
            gl_FragColor = color * 0.03125;
        }
    `;
}
LiteGraph.registerNodeType("texture/average", LGraphTextureAverage);


class LGraphTextureMinMax {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("min_t", "Texture");
        this.addOutput("max_t", "Texture");
        this.addOutput("min", "vec4");
        this.addOutput("max", "vec4");
        this.properties = {
            mode: "max",
            use_previous_frame: true, // to avoid stalls
        };

        this._uniforms = {u_texture: 0};

        this._max = new Float32Array(4);
        this._min = new Float32Array(4);

        this._textures_chain = [];
    }

    static widgets_info = {
        mode: {
            widget: "combo",
            values: ["min", "max", "avg"],
        },
    };

    static title = "MinMax";
    static desc = "Compute the scene min max";

    onExecute() {
        if (!this.properties.use_previous_frame) {
            this.update();
        }

        this.setOutputData(0, this._temp_texture);
        this.setOutputData(1, this._luminance);
    }

    // executed before rendering the frame
    onPreRenderExecute() {
        this.update();
    }

    update() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0) && !this.isOutputConnected(1)) {
            return;
        } // saves work

        if (!LGraphTextureMinMax._shader) {
            LGraphTextureMinMax._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureMinMax.pixel_shader,
            );
        }

        var type = gl.UNSIGNED_BYTE;
        if (tex.type != type) {
            // force floats, half floats cannot be read with gl.readPixels
            type = gl.FLOAT;
        }

        var size = 512;

        if (
            !this._textures_chain.length ||
            this._textures_chain[0].type != type
        ) {
            while (i) {
                this._textures_chain[i] = new GL.Texture(size, size, {
                    type: type,
                    format: gl.RGBA,
                    filter: gl.NEAREST,
                });
                size = size >> 2;
                i++;
                if (size == 1) break;
            }
        }

        // @BUG: the behavior of tex here is probably a bug.
        tex.copyTo(this._textures_chain[0]);
        for (let i = 1; i <= this._textures_chain.length; ++i) {
            tex = this._textures_chain[i];
        }

        var shader = LGraphTextureMinMax._shader;
        var uniforms = this._uniforms;
        uniforms.u_mipmap_offset = this.properties.mipmap_offset;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        this._temp_texture.drawTo(function () {
            tex.toViewport(shader, uniforms);
        });
    }

    static pixel_shader = `
        precision highp float;
        uniform mat4 u_samples_a;
        uniform mat4 u_samples_b;
        uniform sampler2D u_texture;
        uniform float u_mipmap_offset;
        varying vec2 v_coord;
    
        void main() {
            vec4 color = vec4(0.0);
    
            // Random average
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    vec2 sampleCoordA = vec2(u_samples_a[i][j], u_samples_b[i][j]);
                    vec2 sampleCoordB = vec2(1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j]);
                    color += texture2D(u_texture, sampleCoordA, u_mipmap_offset);
                    color += texture2D(u_texture, sampleCoordB, u_mipmap_offset);
                }
            }
    
            gl_FragColor = color * 0.03125;
        }
    `;
}
// LiteGraph.registerNodeType("texture/clustered_operation", LGraphTextureClusteredOperation);


class LGraphTextureTemporalSmooth {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("factor", "Number");
        this.addOutput("out", "Texture");
        this.properties = { factor: 0.5 };
        this._uniforms = {
            u_texture: 0,
            u_textureB: 1,
            u_factor: this.properties.factor,
        };
    }

    static title = "Smooth";
    static desc = "Smooth texture over time";

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex || !this.isOutputConnected(0)) {
            return;
        }

        if (!LGraphTextureTemporalSmooth._shader) {
            LGraphTextureTemporalSmooth._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureTemporalSmooth.pixel_shader,
            );
        }

        var temp = this._temp_texture;
        if (
            !temp ||
            temp.type != tex.type ||
            temp.width != tex.width ||
            temp.height != tex.height
        ) {
            var options = {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.NEAREST,
            };
            this._temp_texture = new GL.Texture(tex.width, tex.height, options);
            this._temp_texture2 = new GL.Texture(
                tex.width,
                tex.height,
                options,
            );
            tex.copyTo(this._temp_texture2);
        }

        var tempA = this._temp_texture;
        var tempB = this._temp_texture2;

        var shader = LGraphTextureTemporalSmooth._shader;
        var uniforms = this._uniforms;
        uniforms.u_factor = 1.0 - this.getInputOrProperty("factor");

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        tempA.drawTo(function () {
            tempB.bind(1);
            tex.toViewport(shader, uniforms);
        });

        this.setOutputData(0, tempA);

        // swap
        this._temp_texture = tempB;
        this._temp_texture2 = tempA;
    }

    static pixel_shader =
        "precision highp float;\n\
    precision highp float;\n\
    uniform sampler2D u_texture;\n\
    uniform sampler2D u_textureB;\n\
    uniform float u_factor;\n\
    varying vec2 v_coord;\n\
    \n\
    void main() {\n\
        gl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/temporal_smooth", LGraphTextureTemporalSmooth);


class LGraphTextureLinearAvgSmooth {
    constructor() {
        this.addInput("in", "Texture");
        this.addOutput("avg", "Texture");
        this.addOutput("array", "Texture");
        this.properties = { samples: 64, frames_interval: 1 };
        this._uniforms = {
            u_texture: 0,
            u_textureB: 1,
            u_samples: this.properties.samples,
            u_isamples: 1 / this.properties.samples,
        };
        this.frame = 0;
    }

    static title = "Lineal Avg Smooth";
    static desc = "Smooth texture linearly over time";

    static ["@samples"] = {
        type: "number",
        min: 1,
        max: 64,
        step: 1,
        precision: 1,
    };

    getPreviewTexture() {
        return this._temp_texture2;
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex || !this.isOutputConnected(0)) {
            return;
        }

        if (!LGraphTextureLinearAvgSmooth._shader) {
            LGraphTextureLinearAvgSmooth._shader_copy = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureLinearAvgSmooth.pixel_shader_copy,
            );
            LGraphTextureLinearAvgSmooth._shader_avg = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureLinearAvgSmooth.pixel_shader_avg,
            );
        }

        var samples = clamp(this.properties.samples, 0, 64);
        var frame = this.frame;
        var interval = this.properties.frames_interval;

        if (interval == 0 || frame % interval == 0) {
            var temp = this._temp_texture;
            if (!temp || temp.type != tex.type || temp.width != samples) {
                var options = {
                    type: tex.type,
                    format: gl.RGBA,
                    filter: gl.NEAREST,
                };
                this._temp_texture = new GL.Texture(samples, 1, options);
                this._temp_texture2 = new GL.Texture(samples, 1, options);
                this._temp_texture_out = new GL.Texture(1, 1, options);
            }

            var tempA = this._temp_texture;
            var tempB = this._temp_texture2;

            var shader_copy = LGraphTextureLinearAvgSmooth._shader_copy;
            var shader_avg = LGraphTextureLinearAvgSmooth._shader_avg;
            var uniforms = this._uniforms;
            uniforms.u_samples = samples;
            uniforms.u_isamples = 1.0 / samples;

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            tempA.drawTo(function () {
                tempB.bind(1);
                tex.toViewport(shader_copy, uniforms);
            });

            this._temp_texture_out.drawTo(function () {
                tempA.toViewport(shader_avg, uniforms);
            });

            this.setOutputData(0, this._temp_texture_out);

            // swap
            this._temp_texture = tempB;
            this._temp_texture2 = tempA;
        } else this.setOutputData(0, this._temp_texture_out);
        this.setOutputData(1, this._temp_texture2);
        this.frame++;
    }

    static pixel_shader_copy =
        "precision highp float;\n\
    precision highp float;\n\
    uniform sampler2D u_texture;\n\
    uniform sampler2D u_textureB;\n\
    uniform float u_isamples;\n\
    varying vec2 v_coord;\n\
    \n\
    void main() {\n\
        if( v_coord.x <= u_isamples )\n\
            gl_FragColor = texture2D( u_texture, vec2(0.5) );\n\
        else\n\
            gl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\n\
    }\n\
    ";

    static pixel_shader_avg =
        "precision highp float;\n\
    precision highp float;\n\
    uniform sampler2D u_texture;\n\
    uniform int u_samples;\n\
    uniform float u_isamples;\n\
    varying vec2 v_coord;\n\
    \n\
    void main() {\n\
        vec4 color = vec4(0.0);\n\
        for(int i = 0; i < 64; ++i)\n\
        {\n\
            color += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\n\
            if(i == (u_samples - 1))\n\
                break;\n\
        }\n\
        gl_FragColor = color * u_isamples;\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/linear_avg_smooth", LGraphTextureLinearAvgSmooth);


class LGraphImageToTexture {
    constructor() {
        this.addInput("Image", "image");
        this.addOutput("", "Texture");
        this.properties = {};
    }

    static title = "Image to Texture";
    static desc = "Uploads an image to the GPU";
    // LGraphImageToTexture.widgets_info = { size: { widget:"combo", values:[0,32,64,128,256,512,1024,2048]} };

    onExecute() {
        var img = this.getInputData(0);
        if (!img) {
            return;
        }

        var width = img.videoWidth || img.width;
        var height = img.videoHeight || img.height;

        // this is in case we are using a webgl canvas already, no need to reupload it
        if (img.gltexture) {
            this.setOutputData(0, img.gltexture);
            return;
        }

        var temp = this._temp_texture;
        if (!temp || temp.width != width || temp.height != height) {
            this._temp_texture = new GL.Texture(width, height, {
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        try {
            this._temp_texture.uploadImage(img);
        } catch (err) {
            console.error?.("image comes from an unsafe location, cannot be uploaded to webgl: "+err);
            return;
        }

        this.setOutputData(0, this._temp_texture);
    }
}
LiteGraph.registerNodeType("texture/imageToTexture", LGraphImageToTexture);


class LGraphTextureLUT {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("LUT", "Texture");
        this.addInput("Intensity", "number");
        this.addOutput("", "Texture");
        this.properties = {
            enabled: true,
            intensity: 1,
            precision: LGraphTexture.DEFAULT,
            texture: null,
        };

        if (!LGraphTextureLUT._shader) {
            LGraphTextureLUT._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureLUT.pixel_shader,
            );
        }
    }

    static widgets_info = {
        texture: { widget: "texture" },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    static title = "LUT";
    static desc = "Apply LUT to Texture";

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);

        if (
            this.properties.precision === LGraphTexture.PASS_THROUGH ||
            this.properties.enabled === false
        ) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        var lut_tex = this.getInputData(1);

        if (!lut_tex) {
            lut_tex = LGraphTexture.getTexture(this.properties.texture);
        }

        if (!lut_tex) {
            this.setOutputData(0, tex);
            return;
        }

        lut_tex.bind(0);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);

        var intensity = this.properties.intensity;
        if (this.isInputConnected(2)) {
            this.properties.intensity = intensity = this.getInputData(2);
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        // var mesh = Mesh.getScreenQuad();

        this._tex.drawTo(function () {
            lut_tex.bind(1);
            tex.toViewport(LGraphTextureLUT._shader, {
                u_texture: 0,
                u_textureB: 1,
                u_amount: intensity,
            });
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader =
        "precision highp float;\n\
    precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_texture;\n\
    uniform sampler2D u_textureB;\n\
    uniform float u_amount;\n\
    \n\
    void main() {\n\
            lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\
            mediump float blueColor = textureColor.b * 63.0;\n\
            mediump vec2 quad1;\n\
            quad1.y = floor(floor(blueColor) / 8.0);\n\
            quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\
            mediump vec2 quad2;\n\
            quad2.y = floor(ceil(blueColor) / 8.0);\n\
            quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\
            highp vec2 texPos1;\n\
            texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
            texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
            highp vec2 texPos2;\n\
            texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
            texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
            lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\
            lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\
            lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\
            gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);


class LGraphTextureEncode {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("Atlas", "Texture");
        this.addOutput("", "Texture");
        this.properties = {
            enabled: true,
            num_row_symbols: 4,
            symbol_size: 16,
            brightness: 1,
            colorize: false,
            filter: false,
            invert: false,
            precision: LGraphTexture.DEFAULT,
            generate_mipmaps: false,
            texture: null,
        };

        if (!LGraphTextureEncode._shader) {
            LGraphTextureEncode._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureEncode.pixel_shader,
            );
        }

        this._uniforms = {
            u_texture: 0,
            u_textureB: 1,
            u_row_simbols: 4,
            u_simbol_size: 16,
            u_res: vec2.create(),
        };
    }

    static widgets_info = {
        texture: { widget: "texture" },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    static title = "Encode";
    static desc = "Apply a texture atlas to encode a texture";

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);

        if (
            this.properties.precision === LGraphTexture.PASS_THROUGH ||
            this.properties.enabled === false
        ) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        var symbols_tex = this.getInputData(1);

        if (!symbols_tex) {
            symbols_tex = LGraphTexture.getTexture(this.properties.texture);
        }

        if (!symbols_tex) {
            this.setOutputData(0, tex);
            return;
        }

        symbols_tex.bind(0);
        gl.texParameteri(
            gl.TEXTURE_2D,
            gl.TEXTURE_MAG_FILTER,
            this.properties.filter ? gl.LINEAR : gl.NEAREST,
        );
        gl.texParameteri(
            gl.TEXTURE_2D,
            gl.TEXTURE_MIN_FILTER,
            this.properties.filter ? gl.LINEAR : gl.NEAREST,
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);

        var uniforms = this._uniforms;
        uniforms.u_row_simbols = Math.floor(this.properties.num_row_symbols);
        uniforms.u_symbol_size = this.properties.symbol_size;
        uniforms.u_brightness = this.properties.brightness;
        uniforms.u_invert = this.properties.invert ? 1 : 0;
        uniforms.u_colorize = this.properties.colorize ? 1 : 0;

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );
        uniforms.u_res[0] = this._tex.width;
        uniforms.u_res[1] = this._tex.height;
        this._tex.bind(0);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

        this._tex.drawTo(function () {
            symbols_tex.bind(1);
            tex.toViewport(LGraphTextureEncode._shader, uniforms);
        });

        if (this.properties.generate_mipmaps) {
            this._tex.bind(0);
            gl.generateMipmap(this._tex.texture_type);
            this._tex.unbind(0);
        }

        this.setOutputData(0, this._tex);
    }

    static pixel_shader =
        "precision highp float;\n\
    precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_texture;\n\
    uniform sampler2D u_textureB;\n\
    uniform float u_row_simbols;\n\
    uniform float u_symbol_size;\n\
    uniform float u_brightness;\n\
    uniform float u_invert;\n\
    uniform float u_colorize;\n\
    uniform vec2 u_res;\n\
    \n\
    void main() {\n\
        vec2 total_symbols = u_res / u_symbol_size;\n\
        vec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate \n\
        vec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;\n\
        lowp vec4 textureColor = texture2D(u_texture, uv );\n\
        float lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);\n\
        if( u_invert == 1.0 ) lum = 1.0 - lum;\n\
        float index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));\n\
        float col = mod( index, u_row_simbols );\n\
        float row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;\n\
        vec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;\n\
        vec4 color = texture2D( u_textureB, simbol_uv );\n\
        if(u_colorize == 1.0)\n\
            color *= textureColor;\n\
        gl_FragColor = color;\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/encode", LGraphTextureEncode);


class LGraphTextureChannels {
    constructor() {
        this.addInput("Texture", "Texture");

        this.addOutput("R", "Texture");
        this.addOutput("G", "Texture");
        this.addOutput("B", "Texture");
        this.addOutput("A", "Texture");

        // this.properties = { use_single_channel: true };
        if (!LGraphTextureChannels._shader) {
            LGraphTextureChannels._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureChannels.pixel_shader,
            );
        }
    }

    static title = "Texture to Channels";
    static desc = "Split texture channels";

    onExecute() {
        var texA = this.getInputData(0);
        if (!texA) {
            return;
        }

        if (!this._channels) {
            this._channels = Array(4);
        }

        // var format = this.properties.use_single_channel ? gl.LUMINANCE : gl.RGBA; //not supported by WebGL1
        var format = gl.RGB;
        var connections = 0;
        for (let i = 0; i < 4; i++) {
            if (this.isOutputConnected(i)) {
                if (
                    !this._channels[i] ||
                    this._channels[i].width != texA.width ||
                    this._channels[i].height != texA.height ||
                    this._channels[i].type != texA.type ||
                    this._channels[i].format != format
                ) {
                    this._channels[i] = new GL.Texture(
                        texA.width,
                        texA.height,
                        {
                            type: texA.type,
                            format: format,
                            filter: gl.LINEAR,
                        },
                    );
                }
                connections++;
            } else {
                this._channels[i] = null;
            }
        }

        if (!connections) {
            return;
        }

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = Mesh.getScreenQuad();
        var shader = LGraphTextureChannels._shader;
        var masks = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ];

        for (let i = 0; i < 4; i++) {
            if (!this._channels[i]) {
                continue;
            }

            this._channels[i].drawTo(function () {
                texA.bind(0);
                shader.uniforms({ u_texture: 0, u_mask: masks[i] }).draw(mesh);
            });
            this.setOutputData(i, this._channels[i]);
        }
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec4 u_mask;\n\
        \n\
        void main() {\n\
            gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\
        }\n\
        ";
}
LiteGraph.registerNodeType("texture/textureChannels", LGraphTextureChannels);


class LGraphChannelsTexture {
    constructor() {
        this.addInput("R", "Texture");
        this.addInput("G", "Texture");
        this.addInput("B", "Texture");
        this.addInput("A", "Texture");

        this.addOutput("Texture", "Texture");

        this.properties = {
            precision: LGraphTexture.DEFAULT,
            R: 1,
            G: 1,
            B: 1,
            A: 1,
        };
        this._color = vec4.create();
        this._uniforms = {
            u_textureR: 0,
            u_textureG: 1,
            u_textureB: 2,
            u_textureA: 3,
            u_color: this._color,
        };
    }

    static title = "Channels to Texture";
    static desc = "Split texture channels";
    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        var white = LGraphTexture.getWhiteTexture();
        var texR = this.getInputData(0) || white;
        var texG = this.getInputData(1) || white;
        var texB = this.getInputData(2) || white;
        var texA = this.getInputData(3) || white;

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = Mesh.getScreenQuad();
        if (!LGraphChannelsTexture._shader) {
            LGraphChannelsTexture._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphChannelsTexture.pixel_shader,
            );
        }
        var shader = LGraphChannelsTexture._shader;

        var w = Math.max(texR.width, texG.width, texB.width, texA.width);
        var h = Math.max(texR.height, texG.height, texB.height, texA.height);
        var type =
            this.properties.precision == LGraphTexture.HIGH
                ? LGraphTexture.HIGH_PRECISION_FORMAT
                : gl.UNSIGNED_BYTE;

        if (
            !this._texture ||
            this._texture.width != w ||
            this._texture.height != h ||
            this._texture.type != type
        ) {
            this._texture = new GL.Texture(w, h, {
                type: type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var color = this._color;
        color[0] = this.properties.R;
        color[1] = this.properties.G;
        color[2] = this.properties.B;
        color[3] = this.properties.A;
        var uniforms = this._uniforms;

        this._texture.drawTo(function () {
            texR.bind(0);
            texG.bind(1);
            texB.bind(2);
            texA.bind(3);
            shader.uniforms(uniforms).draw(mesh);
        });
        this.setOutputData(0, this._texture);
    }

    static pixel_shader =
        "precision highp float;\n\
    precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_textureR;\n\
    uniform sampler2D u_textureG;\n\
    uniform sampler2D u_textureB;\n\
    uniform sampler2D u_textureA;\n\
    uniform vec4 u_color;\n\
    \n\
    void main() {\n\
        gl_FragColor = u_color * vec4( \
                texture2D(u_textureR, v_coord).r,\
                texture2D(u_textureG, v_coord).r,\
                texture2D(u_textureB, v_coord).r,\
                texture2D(u_textureA, v_coord).r);\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/channelsTexture", LGraphChannelsTexture);


class LGraphTextureColor {
    constructor() {
        this.addOutput("Texture", "Texture");

        this._tex_color = vec4.create();
        this.properties = {
            color: vec4.create(),
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Color";
    static desc = "Generates a 1x1 texture with a constant color";

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onDrawBackground(ctx) {
        var c = this.properties.color;
        ctx.fillStyle =
            "rgb(" +
            Math.floor(clamp(c[0], 0, 1) * 255) +
            "," +
            Math.floor(clamp(c[1], 0, 1) * 255) +
            "," +
            Math.floor(clamp(c[2], 0, 1) * 255) +
            ")";
        if (this.flags.collapsed) {
            this.boxcolor = ctx.fillStyle;
        } else {
            ctx.fillRect(0, 0, this.size[0], this.size[1]);
        }
    }

    onExecute() {
        var type =
            this.properties.precision == LGraphTexture.HIGH
                ? LGraphTexture.HIGH_PRECISION_FORMAT
                : gl.UNSIGNED_BYTE;

        if (!this._tex || this._tex.type != type) {
            this._tex = new GL.Texture(1, 1, {
                format: gl.RGBA,
                type: type,
                minFilter: gl.NEAREST,
            });
        }
        var color = this.properties.color;

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                switch (input.name) {
                    case "RGB":
                    case "RGBA":
                        color.set(v);
                        break;
                    case "R":
                        color[0] = v;
                        break;
                    case "G":
                        color[1] = v;
                        break;
                    case "B":
                        color[2] = v;
                        break;
                    case "A":
                        color[3] = v;
                        break;
                }
            }
        }

        if (vec4.sqrDist(this._tex_color, color) > 0.001) {
            this._tex_color.set(color);
            this._tex.fill(color);
        }
        this.setOutputData(0, this._tex);
    }

    onGetInputs() {
        return [
            ["RGB", "vec3"],
            ["RGBA", "vec4"],
            ["R", "number"],
            ["G", "number"],
            ["B", "number"],
            ["A", "number"],
        ];
    }
}
LiteGraph.registerNodeType("texture/color", LGraphTextureColor);


class LGraphTextureGradient {
    constructor() {
        this.addInput("A", "color");
        this.addInput("B", "color");
        this.addOutput("Texture", "Texture");

        this.properties = {
            angle: 0,
            scale: 1,
            A: [0, 0, 0],
            B: [1, 1, 1],
            texture_size: 32,
        };
        if (!LGraphTextureGradient._shader) {
            LGraphTextureGradient._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureGradient.pixel_shader,
            );
        }

        this._uniforms = {
            u_angle: 0,
            u_colorA: vec3.create(),
            u_colorB: vec3.create(),
        };
    }

    static title = "Gradient";
    static desc = "Generates a gradient";
    static ["@A"] = { type: "color" };
    static ["@B"] = { type: "color" };
    static ["@texture_size"] = {
        type: "enum",
        values: [32, 64, 128, 256, 512],
    };

    onExecute() {
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = GL.Mesh.getScreenQuad();
        var shader = LGraphTextureGradient._shader;

        var A = this.getInputData(0);
        if (!A) {
            A = this.properties.A;
        }
        var B = this.getInputData(1);
        if (!B) {
            B = this.properties.B;
        }

        // angle and scale
        for (var i = 2; i < this.inputs.length; i++) {
            var input = this.inputs[i];
            var v = this.getInputData(i);
            if (v === undefined) {
                continue;
            }
            this.properties[input.name] = v;
        }

        var uniforms = this._uniforms;
        this._uniforms.u_angle = this.properties.angle * DEG2RAD;
        this._uniforms.u_scale = this.properties.scale;
        vec3.copy(uniforms.u_colorA, A);
        vec3.copy(uniforms.u_colorB, B);

        var size = parseInt(this.properties.texture_size);
        if (!this._tex || this._tex.width != size) {
            this._tex = new GL.Texture(size, size, {
                format: gl.RGB,
                filter: gl.LINEAR,
            });
        }

        this._tex.drawTo(function () {
            shader.uniforms(uniforms).draw(mesh);
        });
        this.setOutputData(0, this._tex);
    }

    onGetInputs() {
        return [
            ["angle", "number"],
            ["scale", "number"],
        ];
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform float u_angle;\n\
        uniform float u_scale;\n\
        uniform vec3 u_colorA;\n\
        uniform vec3 u_colorB;\n\
        \n\
        vec2 rotate(vec2 v, float angle)\n\
        {\n\
            vec2 result;\n\
            float _cos = cos(angle);\n\
            float _sin = sin(angle);\n\
            result.x = v.x * _cos - v.y * _sin;\n\
            result.y = v.x * _sin + v.y * _cos;\n\
            return result;\n\
        }\n\
        void main() {\n\
            float f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\
            vec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\
            gl_FragColor = vec4(color,1.0);\n\
        }\n\
        ";
}
LiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);


class LGraphTextureMix {
    constructor() {
        this.addInput("A", "Texture");
        this.addInput("B", "Texture");
        this.addInput("Mixer", "Texture");

        this.addOutput("Texture", "Texture");
        this.properties = {
            factor: 0.5,
            size_from_biggest: true,
            invert: false,
            precision: LGraphTexture.DEFAULT,
        };
        this._uniforms = {
            u_textureA: 0,
            u_textureB: 1,
            u_textureMix: 2,
            u_mix: vec4.create(),
        };
    }

    static title = "Mix";
    static desc = "Generates a texture mixing two textures";

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        var texA = this.getInputData(0);

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, texA);
            return;
        }

        var texB = this.getInputData(1);
        if (!texA || !texB) {
            return;
        }

        var texMix = this.getInputData(2);

        var factor = this.getInputData(3);

        this._tex = LGraphTexture.getTargetTexture(
            this.properties.size_from_biggest && texB.width > texA.width
                ? texB
                : texA,
            this._tex,
            this.properties.precision,
        );

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = Mesh.getScreenQuad();
        var shader = null;
        var uniforms = this._uniforms;
        if (texMix) {
            shader = LGraphTextureMix._shader_tex;
            if (!shader) {
                shader = LGraphTextureMix._shader_tex = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphTextureMix.pixel_shader,
                    { MIX_TEX: "" },
                );
            }
        } else {
            shader = LGraphTextureMix._shader_factor;
            if (!shader) {
                shader = LGraphTextureMix._shader_factor = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphTextureMix.pixel_shader,
                );
            }
            var f = factor == null ? this.properties.factor : factor;
            uniforms.u_mix.set([f, f, f, f]);
        }

        var invert = this.properties.invert;

        this._tex.drawTo(function () {
            texA.bind(invert ? 1 : 0);
            texB.bind(invert ? 0 : 1);
            if (texMix) {
                texMix.bind(2);
            }
            shader.uniforms(uniforms).draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    onGetInputs() {
        return [["factor", "number"]];
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_textureA;\n\
        uniform sampler2D u_textureB;\n\
        #ifdef MIX_TEX\n\
            uniform sampler2D u_textureMix;\n\
        #else\n\
            uniform vec4 u_mix;\n\
        #endif\n\
        \n\
        void main() {\n\
            #ifdef MIX_TEX\n\
                vec4 f = texture2D(u_textureMix, v_coord);\n\
            #else\n\
                vec4 f = u_mix;\n\
            #endif\n\
            gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\
        }\n\
        ";
}
LiteGraph.registerNodeType("texture/mix", LGraphTextureMix);


class LGraphTextureEdges {
    constructor() {
        this.addInput("Tex.", "Texture");

        this.addOutput("Edges", "Texture");
        this.properties = {
            invert: true,
            threshold: false,
            factor: 1,
            precision: LGraphTexture.DEFAULT,
        };

        if (!LGraphTextureEdges._shader) {
            LGraphTextureEdges._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureEdges.pixel_shader,
            );
        }
    }

    static title = "Edges";
    static desc = "Detects edges";

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = Mesh.getScreenQuad();
        var shader = LGraphTextureEdges._shader;
        var invert = this.properties.invert;
        var factor = this.properties.factor;
        var threshold = this.properties.threshold ? 1 : 0;

        this._tex.drawTo(function () {
            tex.bind(0);
            shader
                .uniforms({
                    u_texture: 0,
                    u_isize: [1 / tex.width, 1 / tex.height],
                    u_factor: factor,
                    u_threshold: threshold,
                    u_invert: invert ? 1 : 0,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec2 u_isize;\n\
        uniform int u_invert;\n\
        uniform float u_factor;\n\
        uniform float u_threshold;\n\
        \n\
        void main() {\n\
            vec4 center = texture2D(u_texture, v_coord);\n\
            vec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\
            vec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\
            vec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\
            vec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\
            vec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\
            diff *= u_factor;\n\
            if(u_invert == 1)\n\
                diff.xyz = vec3(1.0) - diff.xyz;\n\
            if( u_threshold == 0.0 )\n\
                gl_FragColor = vec4( diff.xyz, center.a );\n\
            else\n\
                gl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\
        }\n\
        ";
}
LiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);


class LGraphTextureDepthRange {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("Distance", "number");
        this.addInput("Range", "number");
        this.addOutput("Texture", "Texture");
        this.properties = {
            distance: 100,
            range: 50,
            only_depth: false,
            high_precision: false,
        };
        this._uniforms = {
            u_texture: 0,
            u_distance: 100,
            u_range: 50,
            u_camera_planes: null,
        };
    }

    static title = "Depth Range";
    static desc = "Generates a texture with a depth range";

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        var precision = gl.UNSIGNED_BYTE;
        if (this.properties.high_precision) {
            precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
        }

        if (
            !this._temp_texture ||
            this._temp_texture.type != precision ||
            this._temp_texture.width != tex.width ||
            this._temp_texture.height != tex.height
        ) {
            this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: precision,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var uniforms = this._uniforms;

        // iterations
        var distance = this.properties.distance;
        if (this.isInputConnected(1)) {
            distance = this.getInputData(1);
            this.properties.distance = distance;
        }

        var range = this.properties.range;
        if (this.isInputConnected(2)) {
            range = this.getInputData(2);
            this.properties.range = range;
        }

        uniforms.u_distance = distance;
        uniforms.u_range = range;

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var mesh = Mesh.getScreenQuad();
        if (!LGraphTextureDepthRange._shader) {
            LGraphTextureDepthRange._shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureDepthRange.pixel_shader,
            );
            LGraphTextureDepthRange._shader_onlydepth = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureDepthRange.pixel_shader,
                { ONLY_DEPTH: "" },
            );
        }
        var shader = this.properties.only_depth
            ? LGraphTextureDepthRange._shader_onlydepth
            : LGraphTextureDepthRange._shader;

        // NEAR AND FAR PLANES
        var planes = null;
        if (tex.near_far_planes) {
            planes = tex.near_far_planes;
        } else if (window.LS && LS.Renderer._main_camera) {
            planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
        } else {
            planes = [0.1, 1000];
        } // hardcoded
        uniforms.u_camera_planes = planes;

        this._temp_texture.drawTo(function () {
            tex.bind(0);
            shader.uniforms(uniforms).draw(mesh);
        });

        this._temp_texture.near_far_planes = planes;
        this.setOutputData(0, this._temp_texture);
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec2 u_camera_planes;\n\
        uniform float u_distance;\n\
        uniform float u_range;\n\
        \n\
        float LinearDepth()\n\
        {\n\
            float zNear = u_camera_planes.x;\n\
            float zFar = u_camera_planes.y;\n\
            float depth = texture2D(u_texture, v_coord).x;\n\
            depth = depth * 2.0 - 1.0;\n\
            return zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
        }\n\
        \n\
        void main() {\n\
            float depth = LinearDepth();\n\
            #ifdef ONLY_DEPTH\n\
                gl_FragColor = vec4(depth);\n\
            #else\n\
                float diff = abs(depth * u_camera_planes.y - u_distance);\n\
                float dof = 1.0;\n\
                if(diff <= u_range)\n\
                    dof = diff / u_range;\n\
                gl_FragColor = vec4(dof);\n\
            #endif\n\
        }\n\
    ";
}
LiteGraph.registerNodeType("texture/depth_range", LGraphTextureDepthRange);


class LGraphTextureLinearDepth {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("Texture", "Texture");
        this.properties = {
            precision: LGraphTexture.DEFAULT,
            invert: false,
        };
        this._uniforms = {
            u_texture: 0,
            u_camera_planes: null, // filled later
            u_ires: vec2.create(),
        };
    }

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static title = "Linear Depth";
    static desc = "Creates a color texture with linear depth";

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);
        if (
            !tex ||
            (tex.format != gl.DEPTH_COMPONENT && tex.format != gl.DEPTH_STENCIL)
        ) {
            return;
        }

        var precision =
            this.properties.precision == LGraphTexture.HIGH
                ? gl.HIGH_PRECISION_FORMAT
                : gl.UNSIGNED_BYTE;

        if (
            !this._temp_texture ||
            this._temp_texture.type != precision ||
            this._temp_texture.width != tex.width ||
            this._temp_texture.height != tex.height
        ) {
            this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: precision,
                format: gl.RGB,
                filter: gl.LINEAR,
            });
        }

        var uniforms = this._uniforms;
        uniforms.u_invert = this.properties.invert ? 1 : 0;

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var mesh = Mesh.getScreenQuad();
        if (!LGraphTextureLinearDepth._shader)
            LGraphTextureLinearDepth._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureLinearDepth.pixel_shader,
            );
        var shader = LGraphTextureLinearDepth._shader;

        // NEAR AND FAR PLANES
        var planes = null;
        if (tex.near_far_planes) {
            planes = tex.near_far_planes;
        } else if (window.LS && LS.Renderer._main_camera) {
            planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
        } else {
            planes = [0.1, 1000];
        } // hardcoded
        uniforms.u_camera_planes = planes;
        // uniforms.u_ires.set([1/tex.width, 1/tex.height]);
        uniforms.u_ires.set([0, 0]);

        this._temp_texture.drawTo(function () {
            tex.bind(0);
            shader.uniforms(uniforms).draw(mesh);
        });

        this._temp_texture.near_far_planes = planes;
        this.setOutputData(0, this._temp_texture);
    }

    static pixel_shader =
        "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec2 u_camera_planes;\n\
        uniform int u_invert;\n\
        uniform vec2 u_ires;\n\
        \n\
        void main() {\n\
            float zNear = u_camera_planes.x;\n\
            float zFar = u_camera_planes.y;\n\
            float depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;\n\
            float f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
            if( u_invert == 1 )\n\
                f = 1.0 - f;\n\
            gl_FragColor = vec4(vec3(f),1.0);\n\
        }\n\
        ";
}
LiteGraph.registerNodeType("texture/linear_depth", LGraphTextureLinearDepth);


class LGraphTextureBlur {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("Iterations", "number");
        this.addInput("Intensity", "number");
        this.addOutput("Blurred", "Texture");
        this.properties = {
            intensity: 1,
            iterations: 1,
            preserve_aspect: false,
            scale: [1, 1],
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Blur";
    static desc = "Blur a texture";

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static max_iterations = 20;

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var temp = this._final_texture;

        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            // we need two textures to do the blurring
            // this._temp_texture = new GL.Texture( tex.width, tex.height, { type: tex.type, format: gl.RGBA, filter: gl.LINEAR });
            temp = this._final_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        // iterations
        var iterations = this.properties.iterations;
        if (this.isInputConnected(1)) {
            iterations = this.getInputData(1);
            this.properties.iterations = iterations;
        }
        iterations = Math.min(
            Math.floor(iterations),
            LGraphTextureBlur.max_iterations,
        );
        if (iterations == 0) {
            // skip blurring
            this.setOutputData(0, tex);
            return;
        }

        var intensity = this.properties.intensity;
        if (this.isInputConnected(2)) {
            intensity = this.getInputData(2);
            this.properties.intensity = intensity;
        }

        // blur sometimes needs an aspect correction
        var aspect = LiteGraph.camera_aspect;
        if (!aspect && window.gl !== undefined) {
            aspect = gl.canvas.height / gl.canvas.width;
        }
        if (!aspect) {
            aspect = 1;
        }
        aspect = this.properties.preserve_aspect ? aspect : 1;

        var scale = this.properties.scale || [1, 1];
        tex.applyBlur(aspect * scale[0], scale[1], intensity, temp);
        for (var i = 1; i < iterations; ++i) {
            temp.applyBlur(
                aspect * scale[0] * (i + 1),
                scale[1] * (i + 1),
                intensity,
            );
        }

        this.setOutputData(0, temp);
    }

    /*
    LGraphTextureBlur.pixel_shader = "precision highp float;\n\
        precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec2 u_offset;\n\
        uniform float u_intensity;\n\
        void main() {\n\
            vec4 sum = vec4(0.0);\n\
            vec4 center = texture2D(u_texture, v_coord);\n\
            sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\
            sum += center * 0.16/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\
            sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\
            gl_FragColor = u_intensity * sum;\n\
        }\n\
        ";
    */
}
LiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);


// Independent glow FX
// based on https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/
class FXGlow {
    constructor() {
        this.intensity = 0.5;
        this.persistence = 0.6;
        this.iterations = 8;
        this.threshold = 0.8;
        this.scale = 1;

        this.dirt_texture = null;
        this.dirt_factor = 0.5;

        this._textures = [];
        this._uniforms = {
            u_intensity: 1,
            u_texture: 0,
            u_glow_texture: 1,
            u_threshold: 0,
            u_texel_size: vec2.create(),
        };
    }

    applyFX(tex, output_texture, glow_texture, average_texture) {
        var width = tex.width;
        var height = tex.height;

        var texture_info = {
            format: tex.format,
            type: tex.type,
            minFilter: GL.LINEAR,
            magFilter: GL.LINEAR,
            wrap: gl.CLAMP_TO_EDGE,
        };

        var uniforms = this._uniforms;
        var textures = this._textures;

        // cut
        var shader = FXGlow._cut_shader;
        if (!shader) {
            shader = FXGlow._cut_shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                FXGlow.cut_pixel_shader,
            );
        }

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        uniforms.u_threshold = this.threshold;
        var currentDestination = (textures[0] = GL.Texture.getTemporary(
            width,
            height,
            texture_info,
        ));
        tex.blit(currentDestination, shader.uniforms(uniforms));
        var currentSource = currentDestination;

        var iterations = this.iterations;
        iterations = clamp(iterations, 1, 16) | 0;
        var texel_size = uniforms.u_texel_size;
        var intensity = this.intensity;

        uniforms.u_intensity = 1;
        uniforms.u_delta = this.scale; // 1

        // downscale/upscale shader
        shader = FXGlow._shader;
        if (!shader) {
            shader = FXGlow._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                FXGlow.scale_pixel_shader,
            );
        }

        var i = 1;
        // downscale
        for (; i < iterations; i++) {
            width = width >> 1;
            if ((height | 0) > 1) {
                height = height >> 1;
            }
            if (width < 2) {
                break;
            }
            currentDestination = textures[i] = GL.Texture.getTemporary(
                width,
                height,
                texture_info,
            );
            texel_size[0] = 1 / currentSource.width;
            texel_size[1] = 1 / currentSource.height;
            currentSource.blit(currentDestination, shader.uniforms(uniforms));
            currentSource = currentDestination;
        }

        // average
        if (average_texture) {
            texel_size[0] = 1 / currentSource.width;
            texel_size[1] = 1 / currentSource.height;
            uniforms.u_intensity = intensity;
            uniforms.u_delta = 1;
            currentSource.blit(average_texture, shader.uniforms(uniforms));
        }

        // upscale and blend
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        uniforms.u_intensity = this.persistence;
        uniforms.u_delta = 0.5;

        // i-=2 => -1 to point to last element in array, -1 to go to texture above
        for (i -= 2; i >= 0; i--) {
            currentDestination = textures[i];
            textures[i] = null;
            texel_size[0] = 1 / currentSource.width;
            texel_size[1] = 1 / currentSource.height;
            currentSource.blit(currentDestination, shader.uniforms(uniforms));
            GL.Texture.releaseTemporary(currentSource);
            currentSource = currentDestination;
        }
        gl.disable(gl.BLEND);

        // glow
        if (glow_texture) {
            currentSource.blit(glow_texture);
        }

        // final composition
        if (output_texture) {
            var final_texture = output_texture;
            var dirt_texture = this.dirt_texture;
            var dirt_factor = this.dirt_factor;
            uniforms.u_intensity = intensity;

            shader = dirt_texture
                ? FXGlow._dirt_final_shader
                : FXGlow._final_shader;
            if (!shader) {
                if (dirt_texture) {
                    shader = FXGlow._dirt_final_shader = new GL.Shader(
                        GL.Shader.SCREEN_VERTEX_SHADER,
                        FXGlow.final_pixel_shader,
                        { USE_DIRT: "" },
                    );
                } else {
                    shader = FXGlow._final_shader = new GL.Shader(
                        GL.Shader.SCREEN_VERTEX_SHADER,
                        FXGlow.final_pixel_shader,
                    );
                }
            }

            final_texture.drawTo(function () {
                tex.bind(0);
                currentSource.bind(1);
                if (dirt_texture) {
                    shader.setUniform("u_dirt_factor", dirt_factor);
                    shader.setUniform("u_dirt_texture", dirt_texture.bind(2));
                }
                shader.toViewport(uniforms);
            });
        }

        GL.Texture.releaseTemporary(currentSource);
    }

    static cut_pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform float u_threshold;\n\
        void main() {\n\
            gl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\
        }";

    static scale_pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec2 u_texel_size;\n\
        uniform float u_delta;\n\
        uniform float u_intensity;\n\
        \n\
        vec4 sampleBox(vec2 uv) {\n\
            vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
            vec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\
            return s * 0.25;\n\
        }\n\
        void main() {\n\
            gl_FragColor = u_intensity * sampleBox( v_coord );\n\
        }";

    static final_pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform sampler2D u_glow_texture;\n\
        #ifdef USE_DIRT\n\
            uniform sampler2D u_dirt_texture;\n\
        #endif\n\
        uniform vec2 u_texel_size;\n\
        uniform float u_delta;\n\
        uniform float u_intensity;\n\
        uniform float u_dirt_factor;\n\
        \n\
        vec4 sampleBox(vec2 uv) {\n\
            vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
            vec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\
            return s * 0.25;\n\
        }\n\
        void main() {\n\
            vec4 glow = sampleBox( v_coord );\n\
            #ifdef USE_DIRT\n\
                glow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\
            #endif\n\
            gl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\
        }";
}


// Texture Glow *****************************************
class LGraphTextureGlow {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("dirt", "Texture");
        this.addOutput("out", "Texture");
        this.addOutput("glow", "Texture");
        this.properties = {
            enabled: true,
            intensity: 1,
            persistence: 0.99,
            iterations: 16,
            threshold: 0,
            scale: 1,
            dirt_factor: 0.5,
            precision: LGraphTexture.DEFAULT,
        };

        this.fx = new FXGlow();
    }

    static title = "Glow";
    static desc = "Filters a texture giving it a glow effect";

    static widgets_info = {
        iterations: {
            type: "number",
            min: 0,
            max: 16,
            step: 1,
            precision: 0,
        },
        threshold: {
            type: "number",
            min: 0,
            max: 10,
            step: 0.01,
            precision: 2,
        },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onGetInputs() {
        return [
            ["enabled", "boolean"],
            ["threshold", "number"],
            ["intensity", "number"],
            ["persistence", "number"],
            ["iterations", "number"],
            ["dirt_factor", "number"],
        ];
    }

    onGetOutputs() {
        return [["average", "Texture"]];
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isAnyOutputConnected()) {
            return;
        } // saves work

        if (
            this.properties.precision === LGraphTexture.PASS_THROUGH ||
            this.getInputOrProperty("enabled") === false
        ) {
            this.setOutputData(0, tex);
            return;
        }

        var fx = this.fx;
        fx.threshold = this.getInputOrProperty("threshold");
        fx.iterations = this.getInputOrProperty("iterations");
        fx.intensity = this.getInputOrProperty("intensity");
        fx.persistence = this.getInputOrProperty("persistence");
        fx.dirt_texture = this.getInputData(1);
        fx.dirt_factor = this.getInputOrProperty("dirt_factor");
        fx.scale = this.properties.scale;

        var type = LGraphTexture.getTextureType(this.properties.precision, tex);

        var average_texture = null;
        if (this.isOutputConnected(2)) {
            average_texture = this._average_texture;
            if (
                !average_texture ||
                average_texture.type != tex.type ||
                average_texture.format != tex.format
            ) {
                average_texture = this._average_texture = new GL.Texture(1, 1, {
                    type: tex.type,
                    format: tex.format,
                    filter: gl.LINEAR,
                });
            }
        }

        var glow_texture = null;
        if (this.isOutputConnected(1)) {
            glow_texture = this._glow_texture;
            if (
                !glow_texture ||
                glow_texture.width != tex.width ||
                glow_texture.height != tex.height ||
                glow_texture.type != type ||
                glow_texture.format != tex.format
            ) {
                glow_texture = this._glow_texture = new GL.Texture(
                    tex.width,
                    tex.height,
                    { type: type, format: tex.format, filter: gl.LINEAR },
                );
            }
        }

        var final_texture = null;
        if (this.isOutputConnected(0)) {
            final_texture = this._final_texture;
            if (
                !final_texture ||
                final_texture.width != tex.width ||
                final_texture.height != tex.height ||
                final_texture.type != type ||
                final_texture.format != tex.format
            ) {
                final_texture = this._final_texture = new GL.Texture(
                    tex.width,
                    tex.height,
                    { type: type, format: tex.format, filter: gl.LINEAR },
                );
            }
        }

        // apply FX
        fx.applyFX(tex, final_texture, glow_texture, average_texture);

        if (this.isOutputConnected(0)) this.setOutputData(0, final_texture);

        if (this.isOutputConnected(1)) this.setOutputData(1, average_texture);

        if (this.isOutputConnected(2)) this.setOutputData(2, glow_texture);
    }
}
LiteGraph.registerNodeType("texture/glow", LGraphTextureGlow);


class LGraphTextureKuwaharaFilter {

    static title = "Kuwahara Filter";
    static desc = "Filters a texture giving an artistic oil canvas painting";

    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("Filtered", "Texture");
        this.properties = { intensity: 1, radius: 5 };
    }

    static max_radius = 10;
    static _shaders = [];

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var temp = this._temp_texture;

        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        // iterations
        var radius = this.properties.radius;
        radius = Math.min(
            Math.floor(radius),
            LGraphTextureKuwaharaFilter.max_radius,
        );
        if (radius == 0) {
            // skip blurring
            this.setOutputData(0, tex);
            return;
        }

        var intensity = this.properties.intensity;

        // blur sometimes needs an aspect correction
        var aspect = LiteGraph.camera_aspect;
        if (!aspect && window.gl !== undefined) {
            aspect = gl.canvas.height / gl.canvas.width;
        }
        if (!aspect) {
            aspect = 1;
        }
        aspect = this.properties.preserve_aspect ? aspect : 1;

        if (!LGraphTextureKuwaharaFilter._shaders[radius]) {
            LGraphTextureKuwaharaFilter._shaders[radius] = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureKuwaharaFilter.pixel_shader,
                { RADIUS: radius.toFixed(0) },
            );
        }

        var shader = LGraphTextureKuwaharaFilter._shaders[radius];
        var mesh = GL.Mesh.getScreenQuad();
        tex.bind(0);

        this._temp_texture.drawTo(function () {
            shader
                .uniforms({
                    u_texture: 0,
                    u_intensity: intensity,
                    u_resolution: [tex.width, tex.height],
                    u_iResolution: [1 / tex.width, 1 / tex.height],
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._temp_texture);
    }

    // from https://www.shadertoy.com/view/MsXSz4
    static pixel_shader =
        "\n\
    precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_texture;\n\
    uniform float u_intensity;\n\
    uniform vec2 u_resolution;\n\
    uniform vec2 u_iResolution;\n\
    #ifndef RADIUS\n\
    #define RADIUS 7\n\
    #endif\n\
    void main() {\n\
    \n\
    const int radius = RADIUS;\n\
    vec2 fragCoord = v_coord;\n\
    vec2 src_size = u_iResolution;\n\
    vec2 uv = v_coord;\n\
    float n = float((radius + 1) * (radius + 1));\n\
    int i;\n\
    int j;\n\
    vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\
    vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\
    vec3 c;\n\
    \n\
    for (int j = -radius; j <= 0; ++j)  {\n\
        for (int i = -radius; i <= 0; ++i)  {\n\
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
            m0 += c;\n\
            s0 += c * c;\n\
        }\n\
    }\n\
    \n\
    for (int j = -radius; j <= 0; ++j)  {\n\
        for (int i = 0; i <= radius; ++i)  {\n\
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
            m1 += c;\n\
            s1 += c * c;\n\
        }\n\
    }\n\
    \n\
    for (int j = 0; j <= radius; ++j)  {\n\
        for (int i = 0; i <= radius; ++i)  {\n\
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
            m2 += c;\n\
            s2 += c * c;\n\
        }\n\
    }\n\
    \n\
    for (int j = 0; j <= radius; ++j)  {\n\
        for (int i = -radius; i <= 0; ++i)  {\n\
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
            m3 += c;\n\
            s3 += c * c;\n\
        }\n\
    }\n\
    \n\
    float min_sigma2 = 1e+2;\n\
    m0 /= n;\n\
    s0 = abs(s0 / n - m0 * m0);\n\
    \n\
    float sigma2 = s0.r + s0.g + s0.b;\n\
    if (sigma2 < min_sigma2) {\n\
        min_sigma2 = sigma2;\n\
        gl_FragColor = vec4(m0, 1.0);\n\
    }\n\
    \n\
    m1 /= n;\n\
    s1 = abs(s1 / n - m1 * m1);\n\
    \n\
    sigma2 = s1.r + s1.g + s1.b;\n\
    if (sigma2 < min_sigma2) {\n\
        min_sigma2 = sigma2;\n\
        gl_FragColor = vec4(m1, 1.0);\n\
    }\n\
    \n\
    m2 /= n;\n\
    s2 = abs(s2 / n - m2 * m2);\n\
    \n\
    sigma2 = s2.r + s2.g + s2.b;\n\
    if (sigma2 < min_sigma2) {\n\
        min_sigma2 = sigma2;\n\
        gl_FragColor = vec4(m2, 1.0);\n\
    }\n\
    \n\
    m3 /= n;\n\
    s3 = abs(s3 / n - m3 * m3);\n\
    \n\
    sigma2 = s3.r + s3.g + s3.b;\n\
    if (sigma2 < min_sigma2) {\n\
        min_sigma2 = sigma2;\n\
        gl_FragColor = vec4(m3, 1.0);\n\
    }\n\
    }\n\
    ";
}
LiteGraph.registerNodeType("texture/kuwahara", LGraphTextureKuwaharaFilter);


class LGraphTextureXDoGFilter {

    static title = "XDoG Filter";
    static desc = "Filters a texture giving an artistic ink style";

    constructor() {
        this.addInput("Texture", "Texture");
        this.addOutput("Filtered", "Texture");
        this.properties = {
            sigma: 1.4,
            k: 1.6,
            p: 21.7,
            epsilon: 79,
            phi: 0.017,
        };
    }

    static max_radius = 10;
    static _shaders = [];

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var temp = this._temp_texture;
        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        if (!LGraphTextureXDoGFilter._xdog_shader) {
            LGraphTextureXDoGFilter._xdog_shader = new GL.Shader(
                Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureXDoGFilter.xdog_pixel_shader,
            );
        }
        var shader = LGraphTextureXDoGFilter._xdog_shader;
        var mesh = GL.Mesh.getScreenQuad();

        var sigma = this.properties.sigma;
        var k = this.properties.k;
        var p = this.properties.p;
        var epsilon = this.properties.epsilon;
        var phi = this.properties.phi;
        tex.bind(0);
        this._temp_texture.drawTo(function () {
            shader
                .uniforms({
                    src: 0,
                    sigma: sigma,
                    k: k,
                    p: p,
                    epsilon: epsilon,
                    phi: phi,
                    cvsWidth: tex.width,
                    cvsHeight: tex.height,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._temp_texture);
    }

    // from https://github.com/RaymondMcGuire/GPU-Based-Image-Processing-Tools/blob/master/lib_webgl/scripts/main.js
    static xdog_pixel_shader =
        "\n\
    precision highp float;\n\
    uniform sampler2D src;\n\n\
    uniform float cvsHeight;\n\
    uniform float cvsWidth;\n\n\
    uniform float sigma;\n\
    uniform float k;\n\
    uniform float p;\n\
    uniform float epsilon;\n\
    uniform float phi;\n\
    varying vec2 v_coord;\n\n\
    float cosh(float val)\n\
    {\n\
    float tmp = exp(val);\n\
    float cosH = (tmp + 1.0 / tmp) / 2.0;\n\
    return cosH;\n\
    }\n\n\
    float tanh(float val)\n\
    {\n\
    float tmp = exp(val);\n\
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\
    return tanH;\n\
    }\n\n\
    float sinh(float val)\n\
    {\n\
    float tmp = exp(val);\n\
    float sinH = (tmp - 1.0 / tmp) / 2.0;\n\
    return sinH;\n\
    }\n\n\
    void main(void){\n\
    vec3 destColor = vec3(0.0);\n\
    float tFrag = 1.0 / cvsHeight;\n\
    float sFrag = 1.0 / cvsWidth;\n\
    vec2 Frag = vec2(sFrag,tFrag);\n\
    vec2 uv = gl_FragCoord.st;\n\
    float twoSigmaESquared = 2.0 * sigma * sigma;\n\
    float twoSigmaRSquared = twoSigmaESquared * k * k;\n\
    int halfWidth = int(ceil( 1.0 * sigma * k ));\n\n\
    const int MAX_NUM_ITERATION = 99999;\n\
    vec2 sum = vec2(0.0);\n\
    vec2 norm = vec2(0.0);\n\n\
    for(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\n\
        if(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\n\
        int i = int(cnt / (2*halfWidth+1)) - halfWidth;\n\
        int j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\n\n\
        float d = length(vec2(i,j));\n\
        vec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \n\
                            exp( -d * d / twoSigmaRSquared ));\n\n\
        vec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\n\n\
        norm += kernel;\n\
        sum += kernel * L;\n\
    }\n\n\
    sum /= norm;\n\n\
    float H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\n\
    float edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\n\
    destColor = vec3(edge);\n\
    gl_FragColor = vec4(destColor, 1.0);\n\
    }";
}
LiteGraph.registerNodeType("texture/xDoG", LGraphTextureXDoGFilter);


class LGraphTextureWebcam {

    constructor() {
        this.addOutput("Webcam", "Texture");
        this.properties = { texture_name: "", facingMode: "user" };
        this.boxcolor = "black";
        this.version = 0;
    }

    static title = "Webcam";
    static desc = "Webcam texture";

    static is_webcam_open = false;

    openStream() {
        if (!navigator.getUserMedia) {
            // console.log?.('getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags');
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        var constraints = {
            audio: false,
            video: { facingMode: this.properties.facingMode },
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(e) {
            LGraphTextureWebcam.is_webcam_open = false;
            console.log?.("Webcam rejected", e);
            that._webcam_stream = false;
            that.boxcolor = "red";
            that.trigger("stream_error");
        }
    }

    closeStream() {
        if (this._webcam_stream) {
            var tracks = this._webcam_stream.getTracks();
            if (tracks.length) {
                for (var i = 0; i < tracks.length; ++i) {
                    tracks[i].stop();
                }
            }
            LGraphTextureWebcam.is_webcam_open = false;
            this._webcam_stream = null;
            this._video = null;
            this.boxcolor = "black";
            this.trigger("stream_closed");
        }
    }

    streamReady(localMediaStream) {
        this._webcam_stream = localMediaStream;
        // this._waiting_confirmation = false;
        this.boxcolor = "green";
        var video = this._video;
        if (!video) {
            video = document.createElement("video");
            video.autoplay = true;
            video.srcObject = localMediaStream;
            this._video = video;
            // document.body.appendChild( video ); //debug
            // when video info is loaded (size and so)
            video.onloadedmetadata = function (e) {
                // Ready to go. Do some stuff.
                LGraphTextureWebcam.is_webcam_open = true;
                console.log?.(e);
            };
        }
        this.trigger("stream_ready", video);
    }

    onPropertyChanged(name, value) {
        if (name == "facingMode") {
            this.properties.facingMode = value;
            this.closeStream();
            this.openStream();
        }
    }

    onRemoved() {
        if (!this._webcam_stream) {
            return;
        }

        var tracks = this._webcam_stream.getTracks();
        if (tracks.length) {
            for (var i = 0; i < tracks.length; ++i) {
                tracks[i].stop();
            }
        }

        this._webcam_stream = null;
        this._video = null;
    }

    onDrawBackground(ctx) {
        if (this.flags.collapsed || this.size[1] <= 20) {
            return;
        }

        if (!this._video) {
            return;
        }

        // render to graph canvas
        ctx.save();
        if (!ctx.webgl) {
            // reverse image
            ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
        } else {
            if (this._video_texture) {
                ctx.drawImage(
                    this._video_texture,
                    0,
                    0,
                    this.size[0],
                    this.size[1],
                );
            }
        }
        ctx.restore();
    }

    onExecute() {
        if (this._webcam_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (!this._video || !this._video.videoWidth) {
            return;
        }

        var width = this._video.videoWidth;
        var height = this._video.videoHeight;

        var temp = this._video_texture;
        if (!temp || temp.width != width || temp.height != height) {
            this._video_texture = new GL.Texture(width, height, {
                format: gl.RGB,
                filter: gl.LINEAR,
            });
        }

        this._video_texture.uploadImage(this._video);
        this._video_texture.version = ++this.version;

        if (this.properties.texture_name) {
            var container = LGraphTexture.getTexturesContainer();
            container[this.properties.texture_name] = this._video_texture;
        }

        this.setOutputData(0, this._video_texture);
        for (var i = 1; i < this.outputs.length; ++i) {
            if (!this.outputs[i]) {
                continue;
            }
            switch (this.outputs[i].name) {
                case "width":
                    this.setOutputData(i, this._video.videoWidth);
                    break;
                case "height":
                    this.setOutputData(i, this._video.videoHeight);
                    break;
            }
        }
    }

    onGetOutputs() {
        return [
            ["width", "number"],
            ["height", "number"],
            ["stream_ready", LiteGraph.EVENT],
            ["stream_closed", LiteGraph.EVENT],
            ["stream_error", LiteGraph.EVENT],
        ];
    }
}
LiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);


// from https://github.com/spite/Wagner
class LGraphLensFX {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("f", "number");
        this.addOutput("out", "Texture");
        this.properties = {
            enabled: true,
            factor: 1,
            precision: LGraphTexture.LOW,
        };

        this._uniforms = { u_texture: 0, u_factor: 1 };
    }

    static title = "Lens FX";
    static desc = "distortion and chromatic aberration";

    static widgets_info = {precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }};

    onGetInputs() {
        return [["enabled", "boolean"]];
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        if (
            this.properties.precision === LGraphTexture.PASS_THROUGH ||
            this.getInputOrProperty("enabled") === false
        ) {
            this.setOutputData(0, tex);
            return;
        }

        var temp = this._temp_texture;
        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            temp = this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var shader = LGraphLensFX._shader;
        if (!shader) {
            shader = LGraphLensFX._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphLensFX.pixel_shader,
            );
        }

        var factor = this.getInputData(1);
        if (factor == null) {
            factor = this.properties.factor;
        }

        var uniforms = this._uniforms;
        uniforms.u_factor = factor;

        // apply shader
        gl.disable(gl.DEPTH_TEST);
        temp.drawTo(function () {
            tex.bind(0);
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, temp);
    }

    static pixel_shader =
        "precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_texture;\n\
    uniform float u_factor;\n\
    vec2 barrelDistortion(vec2 coord, float amt) {\n\
        vec2 cc = coord - 0.5;\n\
        float dist = dot(cc, cc);\n\
        return coord + cc * dist * amt;\n\
    }\n\
    \n\
    float sat( float t )\n\
    {\n\
        return clamp( t, 0.0, 1.0 );\n\
    }\n\
    \n\
    float linterp( float t ) {\n\
        return sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\
    }\n\
    \n\
    float remap( float t, float a, float b ) {\n\
        return sat( (t - a) / (b - a) );\n\
    }\n\
    \n\
    vec4 spectrum_offset( float t ) {\n\
        vec4 ret;\n\
        float lo = step(t,0.5);\n\
        float hi = 1.0-lo;\n\
        float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\
        ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\
    \n\
        return pow( ret, vec4(1.0/2.2) );\n\
    }\n\
    \n\
    const float max_distort = 2.2;\n\
    const int num_iter = 12;\n\
    const float reci_num_iter_f = 1.0 / float(num_iter);\n\
    \n\
    void main()\n\
    {	\n\
        vec2 uv=v_coord;\n\
        vec4 sumcol = vec4(0.0);\n\
        vec4 sumw = vec4(0.0);	\n\
        for ( int i=0; i<num_iter;++i )\n\
        {\n\
            float t = float(i) * reci_num_iter_f;\n\
            vec4 w = spectrum_offset( t );\n\
            sumw += w;\n\
            sumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\
        }\n\
        gl_FragColor = sumcol / sumw;\n\
    }";
}
LiteGraph.registerNodeType("texture/lensfx", LGraphLensFX);


class LGraphTextureFromData {

    static title = "Data->Tex";
    static desc = "Generates or applies a curve to a texture";

    constructor() {
        this.addInput("in", "");
        this.properties = {
            precision: LGraphTexture.LOW,
            width: 0,
            height: 0,
            channels: 1,
        };
        this.addOutput("out", "Texture");
    }

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    }

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var data = this.getInputData(0);
        if (!data) return;

        var channels = this.properties.channels;
        var w = this.properties.width;
        var h = this.properties.height;
        if (!w || !h) {
            w = Math.floor(data.length / channels);
            h = 1;
        }
        var format = gl.RGBA;
        if (channels == 3) format = gl.RGB;
        else if (channels == 1) format = gl.LUMINANCE;

        var temp = this._temp_texture;
        var type = LGraphTexture.getTextureType(this.properties.precision);
        if (!temp || temp.width != w || temp.height != h || temp.type != type) {
            temp = this._temp_texture = new GL.Texture(w, h, {
                type: type,
                format: format,
                filter: gl.LINEAR,
            });
        }

        temp.uploadData(data);
        this.setOutputData(0, temp);
    }
}
LiteGraph.registerNodeType("texture/fromdata", LGraphTextureFromData);


class LGraphTextureCurve {

    static title = "Curve";
    static desc = "Generates or applies a curve to a texture";

    constructor() {
        this.addInput("in", "Texture");
        this.addOutput("out", "Texture");
        this.properties = {
            precision: LGraphTexture.LOW,
            split_channels: false,
        };
        this._values = new Uint8Array(256 * 4);
        this._values.fill(255);
        this._curve_texture = null;
        this._uniforms = { u_texture: 0, u_curve: 1, u_range: 1.0 };
        this._must_update = true;
        this._points = {
            RGB: [
                [0, 0],
                [1, 1],
            ],
            R: [
                [0, 0],
                [1, 1],
            ],
            G: [
                [0, 0],
                [1, 1],
            ],
            B: [
                [0, 0],
                [1, 1],
            ],
        };
        this.curve_editor = null;
        this.addWidget("toggle", "Split Channels", false, "split_channels");
        this.addWidget(
            "combo",
            "Channel",
            "RGB",
            {values: ["RGB", "R", "G", "B"]},
        );
        this.curve_offset = 68;
        this.size = [240, 160];
    }

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);

        var temp = this._temp_texture;
        if (!tex) {
            // generate one texture, nothing else
            if (this._must_update || !this._curve_texture) this.updateCurve();
            this.setOutputData(0, this._curve_texture);
            return;
        }

        var type = LGraphTexture.getTextureType(this.properties.precision, tex);

        // apply curve to input texture
        if (
            !temp ||
            temp.type != type ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.format != tex.format
        )
            temp = this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: type,
                format: tex.format,
                filter: gl.LINEAR,
            });

        var shader = LGraphTextureCurve._shader;
        if (!shader) {
            shader = LGraphTextureCurve._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureCurve.pixel_shader,
            );
        }

        if (this._must_update || !this._curve_texture) this.updateCurve();

        var uniforms = this._uniforms;
        var curve_texture = this._curve_texture;

        // apply shader
        temp.drawTo(function () {
            gl.disable(gl.DEPTH_TEST);
            tex.bind(0);
            curve_texture.bind(1);
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, temp);
    }

    sampleCurve(f, points) {
        points ||= this._points.RGB;
        if (!points)
            return;
        for (var i = 0; i < points.length - 1; ++i) {
            var p = points[i];
            var pn = points[i + 1];
            if (pn[0] < f) continue;
            var r = pn[0] - p[0];
            if (Math.abs(r) < 0.00001) return p[1];
            var local_f = (f - p[0]) / r;
            return p[1] * (1.0 - local_f) + pn[1] * local_f;
        }
        return 0;
    }

    updateCurve() {
        var values = this._values;
        var num = values.length / 4;
        var split = this.properties.split_channels;
        for (var i = 0; i < num; ++i) {
            if (split) {
                values[i * 4] = clamp(
                    this.sampleCurve(i / num, this._points.R) * 255,
                    0,
                    255,
                );
                values[i * 4 + 1] = clamp(
                    this.sampleCurve(i / num, this._points.G) * 255,
                    0,
                    255,
                );
                values[i * 4 + 2] = clamp(
                    this.sampleCurve(i / num, this._points.B) * 255,
                    0,
                    255,
                );
            } else {
                var v = this.sampleCurve(i / num); // sample curve
                values[i * 4] =
                    values[i * 4 + 1] =
                    values[i * 4 + 2] =
                        clamp(v * 255, 0, 255);
            }
            values[i * 4 + 3] = 255; // alpha fixed
        }
        if (!this._curve_texture)
            this._curve_texture = new GL.Texture(256, 1, {
                format: gl.RGBA,
                magFilter: gl.LINEAR,
                wrap: gl.CLAMP_TO_EDGE,
            });
        this._curve_texture.uploadData(values, null, true);
    }

    onSerialize(o) {
        var curves = {};
        for (var i in this._points) curves[i] = this._points[i].concat();
        o.curves = curves;
    }

    onConfigure(o) {
        this._points = o.curves;
        if (this.curve_editor) curve_editor.points = this._points;
        this._must_update = true;
    }

    onMouseDown(e, localpos, graphcanvas) {
        if (this.curve_editor) {
            var r = this.curve_editor.onMouseDown(
                [localpos[0], localpos[1] - this.curve_offset],
                graphcanvas,
            );
            if (r) this.captureInput(true);
            return r;
        }
    }

    onMouseMove(e, localpos, graphcanvas) {
        if (this.curve_editor)
            return this.curve_editor.onMouseMove(
                [localpos[0], localpos[1] - this.curve_offset],
                graphcanvas,
            );
    }

    onMouseUp(e, localpos, graphcanvas) {
        if (this.curve_editor)
            return this.curve_editor.onMouseUp(
                [localpos[0], localpos[1] - this.curve_offset],
                graphcanvas,
            );
        this.captureInput(false);
    }

    static channel_line_colors = {
        RGB: "#666",
        R: "#F33",
        G: "#3F3",
        B: "#33F",
    };

    onDrawBackground(ctx, graphcanvas) {
        if (this.flags.collapsed) return;

        if (!this.curve_editor)
            this.curve_editor = new LiteGraph.CurveEditor(this._points.R);
        ctx.save();
        ctx.translate(0, this.curve_offset);
        var channel = this.widgets[1].value;

        if (this.properties.split_channels) {
            if (channel == "RGB") {
                this.widgets[1].value = channel = "R";
                this.widgets[1].disabled = false;
            }
            this.curve_editor.points = this._points.R;
            this.curve_editor.draw(
                ctx,
                [this.size[0], this.size[1] - this.curve_offset],
                graphcanvas,
                "#111",
                LGraphTextureCurve.channel_line_colors.R,
                true,
            );
            ctx.globalCompositeOperation = "lighten";
            this.curve_editor.points = this._points.G;
            this.curve_editor.draw(
                ctx,
                [this.size[0], this.size[1] - this.curve_offset],
                graphcanvas,
                null,
                LGraphTextureCurve.channel_line_colors.G,
                true,
            );
            this.curve_editor.points = this._points.B;
            this.curve_editor.draw(
                ctx,
                [this.size[0], this.size[1] - this.curve_offset],
                graphcanvas,
                null,
                LGraphTextureCurve.channel_line_colors.B,
                true,
            );
            ctx.globalCompositeOperation = "source-over";
        } else {
            this.widgets[1].value = channel = "RGB";
            this.widgets[1].disabled = true;
        }

        this.curve_editor.points = this._points[channel];
        this.curve_editor.draw(
            ctx,
            [this.size[0], this.size[1] - this.curve_offset],
            graphcanvas,
            this.properties.split_channels ? null : "#111",
            LGraphTextureCurve.channel_line_colors[channel],
        );
        ctx.restore();
    }

    pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform sampler2D u_curve;\n\
        uniform float u_range;\n\
        \n\
        void main() {\n\
            vec4 color = texture2D( u_texture, v_coord ) * u_range;\n\
            color.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\n\
            color.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\n\
            color.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\n\
            //color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\n\
            gl_FragColor = color;\n\
        }";
}
LiteGraph.registerNodeType("texture/curve", LGraphTextureCurve);


// simple exposition, but plan to expand it to support different gamma curves
class LGraphExposition {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("exp", "number");
        this.addOutput("out", "Texture");
        this.properties = { exposition: 1, precision: LGraphTexture.LOW };
        this._uniforms = { u_texture: 0, u_exposition: 1 };
    }

    static title = "Exposition";
    static desc = "Controls texture exposition";

    static widgets_info = {
        exposition: { widget: "slider", min: 0, max: 3 },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var temp = this._temp_texture;
        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            temp = this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var shader = LGraphExposition._shader;
        if (!shader) {
            shader = LGraphExposition._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphExposition.pixel_shader,
            );
        }

        // @BUG: It isn't actually *using* exp or exp_input in execution.
        var exp = this.properties.exposition;
        var exp_input = this.getInputData(1);
        if (exp_input != null) {
            exp = this.properties.exposition = exp_input;
        }
        var uniforms = this._uniforms;

        // apply shader
        temp.drawTo(function () {
            gl.disable(gl.DEPTH_TEST);
            tex.bind(0);
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, temp);
    }

    static pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_exposition;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            gl_FragColor = vec4(color.xyz * u_exposition, color.a);
        }
    `;
}
LiteGraph.registerNodeType("texture/exposition", LGraphExposition);


class LGraphToneMapping {
    constructor() {
        this.addInput("in", "Texture");
        this.addInput("avg", "number,Texture");
        this.addOutput("out", "Texture");
        this.properties = {
            enabled: true,
            scale: 1,
            gamma: 1,
            average_lum: 1,
            lum_white: 1,
            precision: LGraphTexture.LOW,
        };

        this._uniforms = {
            u_texture: 0,
            u_lumwhite2: 1,
            u_igamma: 1,
            u_scale: 1,
            u_average_lum: 1,
        };
    }

    static title = "Tone Mapping";
    static desc = "Applies Tone Mapping to convert from high to low";

    static widgets_info = {precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }};

    onGetInputs() {
        return [["enabled", "boolean"]];
    }

    onExecute() {
        var tex = this.getInputData(0);
        if (!tex) {
            return;
        }

        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        if (
            this.properties.precision === LGraphTexture.PASS_THROUGH ||
            this.getInputOrProperty("enabled") === false
        ) {
            this.setOutputData(0, tex);
            return;
        }

        var temp = this._temp_texture;

        if (
            !temp ||
            temp.width != tex.width ||
            temp.height != tex.height ||
            temp.type != tex.type
        ) {
            temp = this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: tex.type,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var avg = this.getInputData(1);
        if (avg == null) {
            avg = this.properties.average_lum;
        }

        var uniforms = this._uniforms;
        var shader = null;

        if (avg.constructor === Number) {
            this.properties.average_lum = avg;
            uniforms.u_average_lum = this.properties.average_lum;
            shader = LGraphToneMapping._shader;
            if (!shader) {
                shader = LGraphToneMapping._shader = new GL.Shader(
                    GL.Shader.SCREEN_VERTEX_SHADER,
                    LGraphToneMapping.pixel_shader,
                );
            }
        } else if (avg.constructor === GL.Texture) {
            uniforms.u_average_texture = avg.bind(1);
            shader = LGraphToneMapping._shader_texture;
            if (!shader) {
                shader = LGraphToneMapping._shader_texture = new GL.Shader(
                    GL.Shader.SCREEN_VERTEX_SHADER,
                    LGraphToneMapping.pixel_shader,
                    { AVG_TEXTURE: "" },
                );
            }
        }

        uniforms.u_lumwhite2 =
            this.properties.lum_white * this.properties.lum_white;
        uniforms.u_scale = this.properties.scale;
        uniforms.u_igamma = 1 / this.properties.gamma;

        // apply shader
        gl.disable(gl.DEPTH_TEST);
        temp.drawTo(function () {
            tex.bind(0);
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, this._temp_texture);
    }

    static pixel_shader =
        "precision highp float;\n\
    varying vec2 v_coord;\n\
    uniform sampler2D u_texture;\n\
    uniform float u_scale;\n\
    #ifdef AVG_TEXTURE\n\
        uniform sampler2D u_average_texture;\n\
    #else\n\
        uniform float u_average_lum;\n\
    #endif\n\
    uniform float u_lumwhite2;\n\
    uniform float u_igamma;\n\
    vec3 RGB2xyY (vec3 rgb)\n\
    {\n\
            const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\
                                    0.2126, 0.7152, 0.0722,\n\
                                    0.0193, 0.1192, 0.9505);\n\
        vec3 XYZ = RGB2XYZ * rgb;\n\
        \n\
        float f = (XYZ.x + XYZ.y + XYZ.z);\n\
        return vec3(XYZ.x / f,\n\
                    XYZ.y / f,\n\
                    XYZ.y);\n\
    }\n\
    \n\
    void main() {\n\
        vec4 color = texture2D( u_texture, v_coord );\n\
        vec3 rgb = color.xyz;\n\
        float average_lum = 0.0;\n\
        #ifdef AVG_TEXTURE\n\
            vec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\n\
            average_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\n\
        #else\n\
            average_lum = u_average_lum;\n\
        #endif\n\
        //Ld - this part of the code is the same for both versions\n\
        float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\
        float L = (u_scale / average_lum) * lum;\n\
        float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\
        //first\n\
        //vec3 xyY = RGB2xyY(rgb);\n\
        //xyY.z *= Ld;\n\
        //rgb = xyYtoRGB(xyY);\n\
        //second\n\
        rgb = (rgb / lum) * Ld;\n\
        rgb = max(rgb,vec3(0.001));\n\
        rgb = pow( rgb, vec3( u_igamma ) );\n\
        gl_FragColor = vec4( rgb, color.a );\n\
    }";
}
LiteGraph.registerNodeType("texture/tonemapping", LGraphToneMapping);

class LGraphTexturePerlin {
    constructor() {
        this.addOutput("out", "Texture");
        this.properties = {
            width: 512,
            height: 512,
            seed: 0,
            persistence: 0.1,
            octaves: 8,
            scale: 1,
            offset: [0, 0],
            amplitude: 1,
            precision: LGraphTexture.DEFAULT,
        };
        this._key = 0;
        this._texture = null;
        this._uniforms = {
            u_persistence: 0.1,
            u_seed: 0,
            u_offset: vec2.create(),
            u_scale: 1,
            u_viewport: vec2.create(),
        };
    }

    static title = "Perlin";
    static desc = "Generates a perlin noise texture";

    static widgets_info = {
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
        width: { type: "number", precision: 0, step: 1 },
        height: { type: "number", precision: 0, step: 1 },
        octaves: { type: "number", precision: 0, step: 1, min: 1, max: 50 },
    };

    onGetInputs() {
        return [
            ["seed", "number"],
            ["persistence", "number"],
            ["octaves", "number"],
            ["scale", "number"],
            ["amplitude", "number"],
            ["offset", "vec2"],
        ];
    }

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (w == 0) {
            w = gl.viewport_data[2];
        } // 0 means default
        if (h == 0) {
            h = gl.viewport_data[3];
        } // 0 means default
        var type = LGraphTexture.getTextureType(this.properties.precision);

        var temp = this._texture;
        if (!temp || temp.width != w || temp.height != h || temp.type != type) {
            temp = this._texture = new GL.Texture(w, h, {
                type: type,
                format: gl.RGB,
                filter: gl.LINEAR,
            });
        }

        var persistence = this.getInputOrProperty("persistence");
        var octaves = this.getInputOrProperty("octaves");
        var offset = this.getInputOrProperty("offset");
        var scale = this.getInputOrProperty("scale");
        var amplitude = this.getInputOrProperty("amplitude");
        var seed = this.getInputOrProperty("seed");

        // reusing old texture
        var key =
            "" +
            w +
            h +
            type +
            persistence +
            octaves +
            scale +
            seed +
            offset[0] +
            offset[1] +
            amplitude;
        if (key == this._key) {
            this.setOutputData(0, temp);
            return;
        }
        this._key = key;

        // gather uniforms
        var uniforms = this._uniforms;
        uniforms.u_persistence = persistence;
        uniforms.u_octaves = octaves;
        uniforms.u_offset.set(offset);
        uniforms.u_scale = scale;
        uniforms.u_amplitude = amplitude;
        uniforms.u_seed = seed * 128;
        uniforms.u_viewport[0] = w;
        uniforms.u_viewport[1] = h;

        // render
        var shader = LGraphTexturePerlin._shader;
        if (!shader) {
            shader = LGraphTexturePerlin._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTexturePerlin.pixel_shader,
            );
        }

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        temp.drawTo(function () {
            shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
        });

        this.setOutputData(0, temp);
    }

    static pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform vec2 u_offset;\n\
        uniform float u_scale;\n\
        uniform float u_persistence;\n\
        uniform int u_octaves;\n\
        uniform float u_amplitude;\n\
        uniform vec2 u_viewport;\n\
        uniform float u_seed;\n\
        #define M_PI 3.14159265358979323846\n\
        \n\
        float rand(vec2 c){	return fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\
        \n\
        float noise(vec2 p, float freq ){\n\
            float unit = u_viewport.x/freq;\n\
            vec2 ij = floor(p/unit);\n\
            vec2 xy = mod(p,unit)/unit;\n\
            //xy = 3.*xy*xy-2.*xy*xy*xy;\n\
            xy = .5*(1.-cos(M_PI*xy));\n\
            float a = rand((ij+vec2(0.,0.)));\n\
            float b = rand((ij+vec2(1.,0.)));\n\
            float c = rand((ij+vec2(0.,1.)));\n\
            float d = rand((ij+vec2(1.,1.)));\n\
            float x1 = mix(a, b, xy.x);\n\
            float x2 = mix(c, d, xy.x);\n\
            return mix(x1, x2, xy.y);\n\
        }\n\
        \n\
        float pNoise(vec2 p, int res){\n\
            float persistance = u_persistence;\n\
            float n = 0.;\n\
            float normK = 0.;\n\
            float f = 4.;\n\
            float amp = 1.0;\n\
            int iCount = 0;\n\
            for (int i = 0; i<50; i++){\n\
                n+=amp*noise(p, f);\n\
                f*=2.;\n\
                normK+=amp;\n\
                amp*=persistance;\n\
                if (iCount >= res)\n\
                    break;\n\
                iCount++;\n\
            }\n\
            float nf = n/normK;\n\
            return nf*nf*nf*nf;\n\
        }\n\
        void main() {\n\
            vec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\
            vec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\
            gl_FragColor = color;\n\
        }";
}
LiteGraph.registerNodeType("texture/perlin", LGraphTexturePerlin);

class LGraphTextureCanvas2D {
    constructor() {
        this.addInput("v");
        this.addOutput("out", "Texture");
        this.properties = {
            code: LGraphTextureCanvas2D.default_code,
            width: 512,
            height: 512,
            clear: true,
            precision: LGraphTexture.DEFAULT,
            use_html_canvas: false,
        };
        this._func = null;
        this._temp_texture = null;
        this.compileCode();
    }

    static title = "Canvas2D";
    static desc = "Executes Canvas2D code inside a texture or the viewport.";
    static help = "Set width and height to 0 to match viewport size.";
    static default_code = "//vars: canvas,ctx,time\nctx.fillStyle='red';\nctx.fillRect(0,0,50,50);\n";

    static widgets_info = {
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
        code: { type: "code" },
        width: { type: "number", precision: 0, step: 1 },
        height: { type: "number", precision: 0, step: 1 },
    };

    onPropertyChanged(name, value) {
        if (name == "code") this.compileCode(value);
    }

    compileCode(code) {
        this._func = null;
        if (!LiteGraph.allow_scripts) return;

        try {
            this._func = new Function(
                "canvas",
                "ctx",
                "time",
                "script",
                "v",
                code,
            );
            this.boxcolor = "#00FF00";
        } catch (err) {
            this.boxcolor = "#FF0000";
            console.error?.("Error parsing script");
            console.error?.(err);
        }
    }

    onExecute() {
        var func = this._func;
        if (!func || !this.isOutputConnected(0)) {
            return;
        }
        this.executeDraw(func);
    }

    executeDraw(func_context) {
        var width = this.properties.width || gl.canvas.width;
        var height = this.properties.height || gl.canvas.height;
        var temp = this._temp_texture;
        var type = LGraphTexture.getTextureType(this.properties.precision);
        if (
            !temp ||
            temp.width != width ||
            temp.height != height ||
            temp.type != type
        ) {
            temp = this._temp_texture = new GL.Texture(width, height, {
                format: gl.RGBA,
                filter: gl.LINEAR,
                type: type,
            });
        }

        var v = this.getInputData(0);

        var properties = this.properties;
        var that = this;
        var time = this.graph.getTime();
        var ctx = gl;
        var canvas = gl.canvas;
        if (this.properties.use_html_canvas || !enableWebGLCanvas) {
            if (!this._canvas) {
                canvas = this._canvas = GL.createCanvas(width.height);
                ctx = this._ctx = canvas.getContext("2d");
            } else {
                canvas = this._canvas;
                ctx = this._ctx;
            }
            canvas.width = width;
            canvas.height = height;
        }

        if (ctx == gl)
            // using Canvas2DtoWebGL
            temp.drawTo(function () {
                gl.start2D();
                if (properties.clear) {
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }

                try {
                    if (func_context.draw) {
                        func_context.draw.call(
                            that,
                            canvas,
                            ctx,
                            time,
                            func_context,
                            v,
                        );
                    } else {
                        func_context.call(
                            that,
                            canvas,
                            ctx,
                            time,
                            func_context,
                            v,
                        );
                    }
                    that.boxcolor = "#00FF00";
                } catch (err) {
                    that.boxcolor = "#FF0000";
                    console.error?.("Error executing script");
                    console.error?.(err);
                }
                gl.finish2D();
            });
        // rendering to offscreen canvas and uploading to texture
        else {
            if (properties.clear)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

            try {
                if (func_context.draw) {
                    func_context.draw.call(
                        this,
                        canvas,
                        ctx,
                        time,
                        func_context,
                        v,
                    );
                } else {
                    func_context.call(this, canvas, ctx, time, func_context, v);
                }
                this.boxcolor = "#00FF00";
            } catch (err) {
                this.boxcolor = "#FF0000";
                console.error?.("Error executing script");
                console.error?.(err);
            }
            temp.uploadImage(canvas);
        }

        this.setOutputData(0, temp);
    }
}
LiteGraph.registerNodeType("texture/canvas2D", LGraphTextureCanvas2D);


// To do chroma keying *****************
class LGraphTextureMatte {
    constructor() {
        this.addInput("in", "Texture");

        this.addOutput("out", "Texture");
        this.properties = {
            key_color: vec3.fromValues(0, 1, 0),
            threshold: 0.8,
            slope: 0.2,
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "Matte";
    static desc = "Extracts background";

    static widgets_info = {
        key_color: { widget: "color" },
        precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
    };

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        if (!this._uniforms) {
            this._uniforms = {
                u_texture: 0,
                u_key_color: this.properties.key_color,
                u_threshold: 1,
                u_slope: 1,
            };
        }
        var uniforms = this._uniforms;

        var mesh = Mesh.getScreenQuad();
        var shader = LGraphTextureMatte._shader;
        if (!shader) {
            shader = LGraphTextureMatte._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphTextureMatte.pixel_shader,
            );
        }

        uniforms.u_key_color = this.properties.key_color;
        uniforms.u_threshold = this.properties.threshold;
        uniforms.u_slope = this.properties.slope;

        this._tex.drawTo(function () {
            tex.bind(0);
            shader.uniforms(uniforms).draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader =
        "precision highp float;\n\
        varying vec2 v_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform vec3 u_key_color;\n\
        uniform float u_threshold;\n\
        uniform float u_slope;\n\
        \n\
        void main() {\n\
            vec3 color = texture2D( u_texture, v_coord ).xyz;\n\
            float diff = length( normalize(color) - normalize(u_key_color) );\n\
            float edge = u_threshold * (1.0 - u_slope);\n\
            float alpha = smoothstep( edge, u_threshold, diff);\n\
            gl_FragColor = vec4( color, alpha );\n\
        }";
}
LiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);


class LGraphCubemapToTexture2D {
    constructor() {
        this.addInput("in", "texture");
        this.addInput("yaw", "number");
        this.addOutput("out", "texture");
        this.properties = { yaw: 0 };
    }

    static title = "CubemapToTexture2D";
    static desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation";

    onExecute() {
        if (!this.isOutputConnected(0)) return;

        var tex = this.getInputData(0);
        if (!tex || tex.texture_type != GL.TEXTURE_CUBE_MAP) return;
        if (
            this._last_tex &&
            (this._last_tex.height != tex.height ||
                this._last_tex.type != tex.type)
        )
            this._last_tex = null;
        var yaw = this.getInputOrProperty("yaw");
        this._last_tex = GL.Texture.cubemapToTexture2D(
            tex,
            tex.height,
            this._last_tex,
            true,
            yaw,
        );
        this.setOutputData(0, this._last_tex);
    }
}
LiteGraph.registerNodeType("texture/cubemapToTexture2D",LGraphCubemapToTexture2D);



var SHADERNODES_COLOR = "#345";

var LGShaders = (LiteGraph.Shaders = {});

var GLSL_types = (LGShaders.GLSL_types = [
    "float",
    "vec2",
    "vec3",
    "vec4",
    "mat3",
    "mat4",
    "sampler2D",
    "samplerCube",
]);
var GLSL_types_const = (LGShaders.GLSL_types_const = [
    "float",
    "vec2",
    "vec3",
    "vec4",
]);

var GLSL_functions_desc = {
    radians: "T radians(T degrees)",
    degrees: "T degrees(T radians)",
    sin: "T sin(T angle)",
    cos: "T cos(T angle)",
    tan: "T tan(T angle)",
    asin: "T asin(T x)",
    acos: "T acos(T x)",
    atan: "T atan(T x)",
    atan2: "T atan(T x,T y)",
    pow: "T pow(T x,T y)",
    exp: "T exp(T x)",
    log: "T log(T x)",
    exp2: "T exp2(T x)",
    log2: "T log2(T x)",
    sqrt: "T sqrt(T x)",
    inversesqrt: "T inversesqrt(T x)",
    abs: "T abs(T x)",
    sign: "T sign(T x)",
    floor: "T floor(T x)",
    round: "T round(T x)",
    ceil: "T ceil(T x)",
    fract: "T fract(T x)",
    mod: "T mod(T x,T y)", // "T mod(T x,float y)"
    min: "T min(T x,T y)",
    max: "T max(T x,T y)",
    clamp: "T clamp(T x,T minVal = 0.0,T maxVal = 1.0)",
    mix: "T mix(T x,T y,T a)", // "T mix(T x,T y,float a)"
    step: "T step(T edge, T edge2, T x)", // "T step(float edge, T x)"
    smoothstep: "T smoothstep(T edge, T edge2, T x)", // "T smoothstep(float edge, T x)"
    length: "float length(T x)",
    distance: "float distance(T p0, T p1)",
    normalize: "T normalize(T x)",
    dot: "float dot(T x,T y)",
    cross: "vec3 cross(vec3 x,vec3 y)",
    reflect: "vec3 reflect(vec3 V,vec3 N)",
    refract: "vec3 refract(vec3 V,vec3 N, float IOR)",
};

// parse them
var GLSL_functions = {};
var GLSL_functions_name = [];
parseGLSLDescriptions();

LGShaders.ALL_TYPES = "float,vec2,vec3,vec4";

function parseGLSLDescriptions() {
    GLSL_functions_name.length = 0;

    for (var i in GLSL_functions_desc) {
        var op = GLSL_functions_desc[i];
        var index = op.indexOf(" ");
        var return_type = op.substr(0, index);
        var index2 = op.indexOf("(", index);
        var func_name = op.substr(index, index2 - index).trim();
        var params = op
            .substr(index2 + 1, op.length - index2 - 2)
            .split(",");
        for (var j in params) {
            var p = params[j].split(" ").filter(function (a) {
                return a;
            });
            params[j] = { type: p[0].trim(), name: p[1].trim() };
            if (p[2] == "=") params[j].value = p[3].trim();
        }
        GLSL_functions[i] = {
            return_type: return_type,
            func: func_name,
            params: params,
        };
        GLSL_functions_name.push(func_name);
        // console.log?.( GLSL_functions[i] );
    }
}

// common actions to all shader node classes
function registerShaderNode(type, node_ctor) {
    // static attributes
    node_ctor.color = SHADERNODES_COLOR;
    node_ctor.filter = "shader";

    // common methods
    node_ctor.prototype.clearDestination = function () {
        this.shader_destination = {};
    };
    node_ctor.prototype.propagateDestination =
        function propagateDestination(dest_name) {
            this.shader_destination[dest_name] = true;
            if (this.inputs)
                for (var i = 0; i < this.inputs.length; ++i) {
                    var origin_node = this.getInputNode(i);
                    if (origin_node)
                        origin_node.propagateDestination(dest_name);
                }
        };
    if (!node_ctor.prototype.onPropertyChanged)
        node_ctor.prototype.onPropertyChanged = function () {
            if (this.graph) this.graph._version++;
        };

    /*
    if(!node_ctor.prototype.onGetCode)
        node_ctor.prototype.onGetCode = function()
        {
            //check destination to avoid lonely nodes
            if(!this.shader_destination)
                return;
            //grab inputs with types
            var inputs = [];
            if(this.inputs)
            for(var i = 0; i < this.inputs.length; ++i)
                inputs.push({ type: this.getInputData(i), name: getInputLinkID(this,i) });
            var outputs = [];
            if(this.outputs)
            for(var i = 0; i < this.outputs.length; ++i)
                outputs.push({ name: getOutputLinkID(this,i) });
            //pass to code func
            var results = this.extractCode(inputs);
            //grab output, pass to next
            if(results)
            for(var i = 0; i < results.length; ++i)
            {
                var r = results[i];
                if(!r)
                    continue;
                this.setOutputData(i,r.value);
            }
        }
    */

    LiteGraph.registerNodeType("shader::" + type, node_ctor);
}

function getShaderNodeVarName(node, name) {
    return "VAR_" + (name || "TEMP") + "_" + node.id;
}

function getInputLinkID(node, slot) {
    if (!node.inputs) return null;
    var link = node.getInputLink(slot);
    if (!link) return null;
    var origin_node = node.graph.getNodeById(link.origin_id);
    if (!origin_node) return null;
    if (origin_node.getOutputVarName)
        return origin_node.getOutputVarName(link.origin_slot);
    // generate
    return "link_" + origin_node.id + "_" + link.origin_slot;
}

function getOutputLinkID(node, slot) {
    if (!node.isOutputConnected(slot)) return null;
    return "link_" + node.id + "_" + slot;
}

LGShaders.registerShaderNode = registerShaderNode;
LGShaders.getInputLinkID = getInputLinkID;
LGShaders.getOutputLinkID = getOutputLinkID;
LGShaders.getShaderNodeVarName = getShaderNodeVarName;
LGShaders.parseGLSLDescriptions = parseGLSLDescriptions;

// given a const number, it transform it to a string that matches a type
export function valueToGLSL(
    v,
    type,
    precision,
) {
    var n = 5; // num decimals
    if (precision != null) {
        n = precision;
    }
    if (!type) {
        if (v.constructor === Number) {
            type = "float";
        } else if (v.length) {
            switch (v.length) {
                case 2:
                    type = "vec2";
                    break;
                case 3:
                    type = "vec3";
                    break;
                case 4:
                    type = "vec4";
                    break;
                case 9:
                    type = "mat3";
                    break;
                case 16:
                    type = "mat4";
                    break;
                default:
                    throw new Error("unknown type for glsl value size");
            }
        } else {
            throw new Error("unknown type for glsl value: " + v.constructor);
        }
    }
    switch (type) {
        case "float":
            return v.toFixed(n);
        case "vec2":
            return `vec2(${v[0].toFixed(n)},${v[1].toFixed(n)})`;
        case "color3":
        case "vec3":
            return `vec3(${v[0].toFixed(n)},${v[1].toFixed(n)},${v[2].toFixed(n)})`;
        case "color4":
        case "vec4":
            return `vec4(${v[0].toFixed(n)},${v[1].toFixed(n)},${v[2].toFixed(n)},${v[3].toFixed(n)})`;
        case "mat3":
            return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)";
        case "mat4":
            return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)";
        default:
            throw ("unknown glsl type in valueToGLSL:", type);
    }
}

// makes sure that a var is of a type, and if not, it converts it
var varToTypeGLSL = (LiteGraph.varToTypeGLSL = function varToTypeGLSL(
    v,
    input_type,
    output_type,
) {
    if (input_type == output_type) {
        return v;
    }
    if (v == null) {
        switch (output_type) {
            case "float":
                return "0.0";
            case "vec2":
                return "vec2(0.0)";
            case "vec3":
                return "vec3(0.0)";
            case "vec4":
                return "vec4(0.0,0.0,0.0,1.0)";
            default: // null
                return null;
        }
    }
    if (!output_type) {
        throw new Error("error: no output type specified");
    }
    if (output_type == "float") {
        switch (input_type) {
            // case "float":
            case "vec2":
            case "vec3":
            case "vec4":
                return v + ".x";
            default: // null
                return "0.0";
        }
    } else if (output_type == "vec2") {
        switch (input_type) {
            case "float":
                return "vec2(" + v + ")";
            // case "vec2":
            case "vec3":
            case "vec4":
                return v + ".xy";
            default: // null
                return "vec2(0.0)";
        }
    } else if (output_type == "vec3") {
        switch (input_type) {
            case "float":
                return "vec3(" + v + ")";
            case "vec2":
                return "vec3(" + v + ",0.0)";
            // case "vec3":
            case "vec4":
                return v + ".xyz";
            default: // null
                return "vec3(0.0)";
        }
    } else if (output_type == "vec4") {
        switch (input_type) {
            case "float":
                return "vec4(" + v + ")";
            case "vec2":
                return "vec4(" + v + ",0.0,1.0)";
            case "vec3":
                return "vec4(" + v + ",1.0)";
            default: // null
                return "vec4(0.0,0.0,0.0,1.0)";
        }
    }
    throw new Error("type cannot be converted");
});

// used to plug incompatible stuff
var convertVarToGLSLType = (LiteGraph.convertVarToGLSLType =
    function convertVarToGLSLType(varname, type, target_type) {
        if (type == target_type) return varname;
        if (type == "float") return target_type + "(" + varname + ")";
        if (target_type == "vec2")
            // works for vec2,vec3 and vec4
            return "vec2(" + varname + ".xy)";
        if (target_type == "vec3") {
            // works for vec2,vec3 and vec4
            if (type == "vec2") return "vec3(" + varname + ",0.0)";
            if (type == "vec4") return "vec4(" + varname + ".xyz)";
        }
        if (target_type == "vec4") {
            if (type == "vec2") return "vec4(" + varname + ",0.0,0.0)";
            if (target_type == "vec3") return "vec4(" + varname + ",1.0)";
        }
        return null;
    });

// used to host a shader body
export class LGShaderContext {
    constructor() {
        // to store the code template
        this.vs_template = "";
        this.fs_template = "";

        // required so nodes now where to fetch the input data
        this.buffer_names = {uvs: "v_coord"};

        this.extra = {}; // to store custom info from the nodes (like if this shader supports a feature, etc)

        this._functions = {};
        this._uniforms = {};
        this._codeparts = {};
        this._uniform_value = null;
    }

    clear() {
        this._uniforms = {};
        this._functions = {};
        this._codeparts = {};
        this._uniform_value = null;
        this.extra = {};
    }

    addUniform(name, type, value) {
        this._uniforms[name] = type;
        if (value != null) {
            if (!this._uniform_value) this._uniform_value = {};
            this._uniform_value[name] = value;
        }
    }

    addFunction(name, code) {
        this._functions[name] = code;
    }

    addCode(hook, code, destinations) {
        destinations = destinations || { "": "" };
        for (var i in destinations) {
            var h = i ? i + "_" + hook : hook;
            if (!this._codeparts[h]) this._codeparts[h] = code + "\n";
            else this._codeparts[h] += code + "\n";
        }
    }

    // the system works by grabbing code fragments from every node and concatenating them in blocks depending on where must they be attached
    computeCodeBlocks(graph, extra_uniforms) {
        // prepare context
        this.clear();

        // grab output nodes
        var vertexout = graph.findNodesByType("shader::output/vertex");
        vertexout = vertexout && vertexout.length ? vertexout[0] : null;
        var fragmentout = graph.findNodesByType("shader::output/fragcolor");
        fragmentout = fragmentout && fragmentout.length ? fragmentout[0] : null;
        if (!fragmentout)
            // ??
            return null;

        // propagate back destinations
        graph.sendEventToAllNodes("clearDestination");
        if (vertexout) vertexout.propagateDestination("vs");
        if (fragmentout) fragmentout.propagateDestination("fs");

        // gets code from graph
        graph.sendEventToAllNodes("onGetCode", this);

        var uniforms = "";
        for (let i in this._uniforms)
            uniforms += "uniform " + this._uniforms[i] + " " + i + ";\n";
        if (extra_uniforms)
            for (let i in extra_uniforms)
                uniforms += "uniform " + extra_uniforms[i] + " " + i + ";\n";

        var functions = "";
        for (let i in this._functions)
            functions += "//" + i + "\n" + this._functions[i] + "\n";

        var blocks = this._codeparts;
        blocks.uniforms = uniforms;
        blocks.functions = functions;
        return blocks;
    }

    // replaces blocks using the vs and fs template and returns the final codes
    computeShaderCode(graph) {
        var blocks = this.computeCodeBlocks(graph);
        var vs_code = GL.Shader.replaceCodeUsingContext(
            this.vs_template,
            blocks,
        );
        var fs_code = GL.Shader.replaceCodeUsingContext(
            this.fs_template,
            blocks,
        );
        return {
            vs_code: vs_code,
            fs_code: fs_code,
        };
    }

    // generates the shader code from the template and the
    computeShader(graph, shader) {
        var finalcode = this.computeShaderCode(graph);
        console.log?.(finalcode.vs_code, finalcode.fs_code);

        if (!LiteGraph.catch_exceptions) {
            this._shader_error = true;
            if (shader)
                shader.updateShader(finalcode.vs_code, finalcode.fs_code);
            else shader = new GL.Shader(finalcode.vs_code, finalcode.fs_code);
            this._shader_error = false;
            return shader;
        }

        try {
            if (shader)
                shader.updateShader(finalcode.vs_code, finalcode.fs_code);
            else shader = new GL.Shader(finalcode.vs_code, finalcode.fs_code);
            this._shader_error = false;
            return shader;
        } catch (err) {
            if (!this._shader_error) {
                console.error?.(err);
                if (err.indexOf("Fragment shader") != -1)
                    console.log?.(finalcode.fs_code
                        .split("\n")
                        .map(function (v, i) {
                            return i + ".- " + v;
                        })
                        .join("\n"));
                else
                    console.log?.(finalcode.vs_code);
            }
            this._shader_error = true;
            return null;
        }
    }

    getShader(graph) {
        // if graph not changed?
        if (this._shader && this._shader._version == graph._version)
            return this._shader;

        // compile shader
        var shader = this.computeShader(graph, this._shader);
        if (!shader) return null;

        this._shader = shader;
        shader._version = graph._version;
        return shader;
    }

    // some shader nodes could require to fill the box with some uniforms
    fillUniforms(uniforms, param) {
        if (!this._uniform_value) return;

        for (var i in this._uniform_value) {
            var v = this._uniform_value[i];
            if (v == null) continue;
            if (v.constructor === Function) uniforms[i] = v.call(this, param);
            else if (v.constructor === GL.Texture) {
                // todo...
            } else uniforms[i] = v;
        }
    }
}


// applies a shader graph to texture, it can be uses as an example
class LGraphShaderGraph {
    constructor() {
        // before inputs
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;
        this.subgraph.filter = "shader";

        this.addInput("in", "texture");
        this.addOutput("out", "texture");
        this.properties = {
            width: 0,
            height: 0,
            alpha: false,
            precision:
                typeof LGraphTexture != "undefined" ? LGraphTexture.DEFAULT : 2,
        };

        var inputNode = this.subgraph.findNodesByType("shader::input/uniform")[0];
        inputNode.pos = [200, 300];

        var sampler = LiteGraph.createNode("shader::texture/sampler2D");
        sampler.pos = [400, 300];
        this.subgraph.add(sampler);

        var outnode = LiteGraph.createNode("shader::output/fragcolor");
        outnode.pos = [600, 300];
        this.subgraph.add(outnode);

        inputNode.connect(0, sampler);
        sampler.connect(0, outnode);

        this.size = [180, 60];
        this.redraw_on_mouse = true; // force redraw

        this._uniforms = {};
        this._shader = null;
        this._context = new LGShaderContext();
        this._context.vs_template =
            "#define VERTEX\n" + GL.Shader.SCREEN_VERTEX_SHADER;
        this._context.fs_template = LGraphShaderGraph.template;
    }

    static template = `
        #define FRAGMENT
        precision highp float;
        varying vec2 v_coord;
        {{varying}}
        {{uniforms}}
        {{functions}}
        {{fs_functions}}
        void main() {
    
            vec2 uv = v_coord;
            vec4 fragcolor = vec4(0.0);
            vec4 fragcolor1 = vec4(0.0);
            {{fs_code}}
            gl_FragColor = fragcolor;
        }
    `;

    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static title = "ShaderGraph";
    static desc = "Builds a shader using a graph";
    static input_node_type = "input/uniform";
    static output_node_type = "output/fragcolor";
    static title_color = SHADERNODES_COLOR;

    onSerialize(o) {
        o.subgraph = this.subgraph.serialize();
    }

    onConfigure(o) {
        this.subgraph.configure(o.subgraph);
    }

    onExecute() {
        if (!this.isOutputConnected(0)) return;

        // read input texture
        var intex = this.getInputData(0);
        if (intex && intex.constructor != GL.Texture) intex = null;

        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (w == 0) {
            w = intex ? intex.width : gl.viewport_data[2];
        } // 0 means default
        if (h == 0) {
            h = intex ? intex.height : gl.viewport_data[3];
        } // 0 means default

        var type = LGraphTexture.getTextureType(
            this.properties.precision,
            intex,
        );

        var texture = this._texture;
        if (
            !texture ||
            texture.width != w ||
            texture.height != h ||
            texture.type != type
        ) {
            texture = this._texture = new GL.Texture(w, h, {
                type: type,
                format: this.alpha ? gl.RGBA : gl.RGB,
                filter: gl.LINEAR,
            });
        }

        var shader = this.getShader(this.subgraph);
        if (!shader) return;

        var uniforms = this._uniforms;
        this._context.fillUniforms(uniforms);

        var tex_slot = 0;
        if (this.inputs)
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                var data = this.getInputData(i);
                if (input.type == "texture") {
                    if (!data) data = GL.Texture.getWhiteTexture();
                    data = data.bind(tex_slot++);
                }

                if (data != null) uniforms["u_" + input.name] = data;
            }

        var mesh = GL.Mesh.getScreenQuad();

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        texture.drawTo(function () {
            shader.uniforms(uniforms);
            shader.draw(mesh);
        });

        // use subgraph output
        this.setOutputData(0, texture);
    }

    // add input node inside subgraph
    onInputAdded(slot_info) {
        var subnode = LiteGraph.createNode("shader::input/uniform");
        subnode.setProperty("name", slot_info.name);
        subnode.setProperty("type", slot_info.type);
        this.subgraph.add(subnode);
    }

    // remove all
    onInputRemoved(slot, slot_info) {
        var nodes = this.subgraph.findNodesByType("shader::input/uniform");
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            if (node.properties.name == slot_info.name)
                this.subgraph.remove(node);
        }
    }

    computeSize() {
        var num_inputs = this.inputs ? this.inputs.length : 0;
        var num_outputs = this.outputs ? this.outputs.length : 0;
        return [
            200,
            Math.max(num_inputs, num_outputs) * LiteGraph.NODE_SLOT_HEIGHT +
                LiteGraph.NODE_TITLE_HEIGHT +
                10,
        ];
    }

    getShader() {
        var shader = this._context.getShader(this.subgraph);
        if (!shader) this.boxcolor = "red";
        else this.boxcolor = null;
        return shader;
    }

    onDrawBackground(ctx, graphcanvas, canvas, pos) {
        if (this.flags.collapsed)
            return;

        // allows to preview the node if the canvas is a webgl canvas
        var tex = this.getOutputData(0);
        var inputs_y = this.inputs
            ? this.inputs.length * LiteGraph.NODE_SLOT_HEIGHT
            : 0;
        if (
            tex &&
            ctx == tex.gl &&
            this.size[1] > inputs_y + LiteGraph.NODE_TITLE_HEIGHT
        ) {
            ctx.drawImage(
                tex,
                10,
                y,
                this.size[0] - 20,
                this.size[1] - inputs_y - LiteGraph.NODE_TITLE_HEIGHT,
            );
        }

        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;

        // button
        var over = LiteGraph.isInsideRectangle(
            pos[0],
            pos[1],
            this.pos[0],
            this.pos[1] + y,
            this.size[0],
            LiteGraph.NODE_TITLE_HEIGHT,
        );
        ctx.fillStyle = over ? "#555" : "#222";
        ctx.beginPath();
        if (this._shape == LiteGraph.BOX_SHAPE)
            ctx.rect(0, y, this.size[0] + 1, LiteGraph.NODE_TITLE_HEIGHT);
        else
            ctx.roundRect(
                0,
                y,
                this.size[0] + 1,
                LiteGraph.NODE_TITLE_HEIGHT,
                0,
                8,
            );
        ctx.fill();

        // button
        ctx.textAlign = "center";
        ctx.font = "24px Arial";
        ctx.fillStyle = over ? "#DDD" : "#999";
        ctx.fillText("+", this.size[0] * 0.5, y + 24);
    }

    onMouseDown(e, localpos, graphcanvas) {
        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
        if (localpos[1] > y) {
            graphcanvas.showSubgraphPropertiesDialog(this);
        }
    }

    /*
    * @TODO: Either make it or excise it
    * LGraphShaderGraph.prototype.onDrawSubgraphBackground = function () {};
    */
    getExtraMenuOptions() {
        var that = this;
        var options = [
            {
                content: "Print Code",
                callback: function () {
                    var code = that._context.computeShaderCode();
                    console.log?.(code.vs_code, code.fs_code);
                },
            },
        ];

        return options;
    }
}
LiteGraph.registerNodeType("texture/shaderGraph", LGraphShaderGraph);

/*
    * @TODO: Either write it or excise it.
    * function shaderNodeFromFunction() {};
    */

// applies a shader graph to a code
class LGraphShaderUniform {
    constructor() {
        this.addOutput("out", "");
        this.properties = { name: "", type: "" };
    }

    static title = "Uniform";
    static desc = "Input data for the shader";

    getTitle() {
        if (this.properties.name && this.flags.collapsed)
            return this.properties.type + " " + this.properties.name;
        return "Uniform";
    }

    onPropertyChanged() {
        this.outputs[0].name =
            this.properties.type + " " + this.properties.name;
    }

    onGetCode(context) {
        if (!this.shader_destination) return;

        var type = this.properties.type;
        if (!type) {
            if (!context.onGetPropertyInfo) return;
            var info = context.onGetPropertyInfo(this.property.name);
            if (!info) return;
            type = info.type;
        }
        if (type == "number") type = "float";
        else if (type == "texture") type = "sampler2D";
        if (LGShaders.GLSL_types.indexOf(type) == -1) return;

        context.addUniform("u_" + this.properties.name, type);
        this.setOutputData(0, type);
    }

    getOutputVarName() {
        return "u_" + this.properties.name;
    }
}
registerShaderNode("input/uniform", LGraphShaderUniform);


class LGraphShaderAttribute {
    constructor () {
        this.addOutput("out", "vec2");
        this.properties = { name: "coord", type: "vec2" };
    }

    static title = "Attribute";
    static desc = "Input data from mesh attribute";

    getTitle() {
        return "att. " + this.properties.name;
    }

    onGetCode(context) {
        if (!this.shader_destination) return;

        var type = this.properties.type;
        if (!type || LGShaders.GLSL_types.indexOf(type) == -1) return;
        if (type == "number") type = "float";
        if (this.properties.name != "coord") {
            context.addCode(
                "varying",
                " varying " + type + " v_" + this.properties.name + ";",
            );
            // if( !context.varyings[ this.properties.name ] )
            // context.addCode( "vs_code", "v_" + this.properties.name + " = " + input_name + ";" );
        }
        this.setOutputData(0, type);
    }

    getOutputVarName() {
        return "v_" + this.properties.name;
    }
}
registerShaderNode("input/attribute", LGraphShaderAttribute);


class LGraphShaderSampler2D {
    constructor() {
        this.addInput("tex", "sampler2D");
        this.addInput("uv", "vec2");
        this.addOutput("rgba", "vec4");
        this.addOutput("rgb", "vec3");
    }

    static title = "Sampler2D";
    static desc = "Reads a pixel from a texture";

    onGetCode(context) {
        if (!this.shader_destination) return;

        var texname = getInputLinkID(this, 0);
        var varname = getShaderNodeVarName(this);
        var code = "vec4 " + varname + " = vec4(0.0);\n";
        if (texname) {
            var uvname = getInputLinkID(this, 1) || context.buffer_names.uvs;
            code += varname + " = texture2D(" + texname + "," + uvname + ");\n";
        }

        var link0 = getOutputLinkID(this, 0);
        if (link0)
            code +=
                "vec4 " + getOutputLinkID(this, 0) + " = " + varname + ";\n";

        var link1 = getOutputLinkID(this, 1);
        if (link1)
            code +=
                "vec3 " +
                getOutputLinkID(this, 1) +
                " = " +
                varname +
                ".xyz;\n";

        context.addCode("code", code, this.shader_destination);
        this.setOutputData(0, "vec4");
        this.setOutputData(1, "vec3");
    }
}
registerShaderNode("texture/sampler2D", LGraphShaderSampler2D);


class LGraphShaderConstant {
    constructor() {
        this.addOutput("", "float");

        this.properties = {
            type: "float",
            value: 0,
        };

        this.addWidget("combo", "type", "float", null, {
            values: GLSL_types_const,
            property: "type",
        });
        this.updateWidgets();
    }

    static title = "const";

    getTitle() {
        if (this.flags.collapsed)
            return valueToGLSL(this.properties.value, this.properties.type, 2);
        return "Const";
    }

    onPropertyChanged(name, value) {
        if (name == "type") {
            if (this.outputs[0].type != value) {
                this.disconnectOutput(0);
                this.outputs[0].type = value;
            }
            this.widgets.length = 1; // remove extra widgets
            this.updateWidgets();
        }
        if (name == "value") {
            if (!value.length) this.widgets[1].value = value;
            else {
                this.widgets[1].value = value[1];
                if (value.length > 2) this.widgets[2].value = value[2];
                if (value.length > 3) this.widgets[3].value = value[3];
            }
        }
    }

    updateWidgets(old_value) {
        var that = this;
        old_value = this.properties.value;
        var options = { step: 0.01 };
        switch (this.properties.type) {
            case "float":
                this.properties.value = 0;
                this.addWidget("number", "v", 0, {
                    step: 0.01,
                    property: "value",
                });
                break;
            case "vec2":
                this.properties.value =
                    old_value && old_value.length == 2
                        ? [old_value[0], old_value[1]]
                        : [0, 0, 0];
                this.addWidget(
                    "number",
                    "x",
                    this.properties.value[0],
                    function (v) {
                        that.properties.value[0] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "y",
                    this.properties.value[1],
                    function (v) {
                        that.properties.value[1] = v;
                    },
                    options,
                );
                break;
            case "vec3":
                this.properties.value =
                    old_value && old_value.length == 3
                        ? [old_value[0], old_value[1], old_value[2]]
                        : [0, 0, 0];
                this.addWidget(
                    "number",
                    "x",
                    this.properties.value[0],
                    function (v) {
                        that.properties.value[0] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "y",
                    this.properties.value[1],
                    function (v) {
                        that.properties.value[1] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "z",
                    this.properties.value[2],
                    function (v) {
                        that.properties.value[2] = v;
                    },
                    options,
                );
                break;
            case "vec4":
                this.properties.value =
                    old_value && old_value.length == 4
                        ? [
                            old_value[0],
                            old_value[1],
                            old_value[2],
                            old_value[3],
                        ]
                        : [0, 0, 0, 0];
                this.addWidget(
                    "number",
                    "x",
                    this.properties.value[0],
                    function (v) {
                        that.properties.value[0] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "y",
                    this.properties.value[1],
                    function (v) {
                        that.properties.value[1] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "z",
                    this.properties.value[2],
                    function (v) {
                        that.properties.value[2] = v;
                    },
                    options,
                );
                this.addWidget(
                    "number",
                    "w",
                    this.properties.value[3],
                    function (v) {
                        that.properties.value[3] = v;
                    },
                    options,
                );
                break;
            default:
                console.error?.("unknown type for constant");
        }
    }

    onGetCode(context) {
        if (!this.shader_destination) return;

        var value = valueToGLSL(this.properties.value, this.properties.type);
        var link_name = getOutputLinkID(this, 0);
        if (!link_name)
            // not connected
            return;

        var code =
            "	" + this.properties.type + " " + link_name + " = " + value + ";";
        context.addCode("code", code, this.shader_destination);

        this.setOutputData(0, this.properties.type);
    }
}
registerShaderNode("const/const", LGraphShaderConstant);


class LGraphShaderVec2 {
    constructor() {
        this.addInput("xy", "vec2");
        this.addInput("x", "float");
        this.addInput("y", "float");
        this.addOutput("xy", "vec2");
        this.addOutput("x", "float");
        this.addOutput("y", "float");

        this.properties = { x: 0, y: 0 };
    }

    static title = "vec2";
    static varmodes = ["xy", "x", "y"];

    onPropertyChanged() {
        if (this.graph)
            this.graph._version++;
    }

    onGetCode(context) {
        if (!this.shader_destination) return;

        var props = this.properties;

        var varname = getShaderNodeVarName(this);
        var code =
            "	vec2 " + varname + " = " + valueToGLSL([props.x, props.y]) + ";\n";

        for (let i = 0; i < LGraphShaderVec2.varmodes.length; ++i) {
            let varmode = LGraphShaderVec2.varmodes[i];
            var inlink = getInputLinkID(this, i);
            if (!inlink) continue;
            code += "	" + varname + "." + varmode + " = " + inlink + ";\n";
        }

        for (let i = 0; i < LGraphShaderVec2.varmodes.length; ++i) {
            let varmode = LGraphShaderVec2.varmodes[i];
            var outlink = getOutputLinkID(this, i);
            if (!outlink) continue;
            var type = GLSL_types_const[varmode.length - 1];
            code +=
                "	" +
                type +
                " " +
                outlink +
                " = " +
                varname +
                "." +
                varmode +
                ";\n";
            this.setOutputData(i, type);
        }

        context.addCode("code", code, this.shader_destination);
    }
}
registerShaderNode("const/vec2", LGraphShaderVec2);


class LGraphShaderVec3 {
    constructor() {
        this.addInput("xyz", "vec3");
        this.addInput("x", "float");
        this.addInput("y", "float");
        this.addInput("z", "float");
        this.addInput("xy", "vec2");
        this.addInput("xz", "vec2");
        this.addInput("yz", "vec2");
        this.addOutput("xyz", "vec3");
        this.addOutput("x", "float");
        this.addOutput("y", "float");
        this.addOutput("z", "float");
        this.addOutput("xy", "vec2");
        this.addOutput("xz", "vec2");
        this.addOutput("yz", "vec2");

        this.properties = { x: 0, y: 0, z: 0 };
    }

    static title = "vec3";
    static varmodes = ["xyz", "x", "y", "z", "xy", "xz", "yz"];

    onPropertyChanged() {
        if (this.graph) {
            this.graph._version++;
        }
    }

    onGetCode(context) {
        if (!this.shader_destination) {
            return;
        }

        var props = this.properties;

        var varname = getShaderNodeVarName(this);
        var code =
            "vec3 " +
            varname +
            " = " +
            valueToGLSL([props.x, props.y, props.z]) +
            ";\n";

        for (let i = 0; i < LGraphShaderVec3.varmodes.length; ++i) {
            let varmode = LGraphShaderVec3.varmodes[i];
            let inlink = getInputLinkID(this, i);
            if (!inlink) continue;
            code += "	" + varname + "." + varmode + " = " + inlink + ";\n";
        }

        for (let i = 0; i < LGraphShaderVec3.varmodes.length; ++i) {
            let varmode = LGraphShaderVec3.varmodes[i];
            let outlink = getOutputLinkID(this, i);
            if (!outlink) continue;
            var type = GLSL_types_const[varmode.length - 1];
            code +=
                "	" +
                type +
                " " +
                outlink +
                " = " +
                varname +
                "." +
                varmode +
                ";\n";
            this.setOutputData(i, type);
        }

        context.addCode("code", code, this.shader_destination);
    }
}
registerShaderNode("const/vec3", LGraphShaderVec3);


class LGraphShaderVec4 {
    constructor() {
        this.addInput("xyzw", "vec4");
        this.addInput("xyz", "vec3");
        this.addInput("x", "float");
        this.addInput("y", "float");
        this.addInput("z", "float");
        this.addInput("w", "float");
        this.addInput("xy", "vec2");
        this.addInput("yz", "vec2");
        this.addInput("zw", "vec2");
        this.addOutput("xyzw", "vec4");
        this.addOutput("xyz", "vec3");
        this.addOutput("x", "float");
        this.addOutput("y", "float");
        this.addOutput("z", "float");
        this.addOutput("xy", "vec2");
        this.addOutput("yz", "vec2");
        this.addOutput("zw", "vec2");

        this.properties = { x: 0, y: 0, z: 0, w: 0 };
    }

    static title = "vec4";
    static varmodes = [
        "xyzw",
        "xyz",
        "x",
        "y",
        "z",
        "w",
        "xy",
        "yz",
        "zw",
    ];

    onPropertyChanged() {
        if (this.graph) {
            this.graph._version++;
        }
    }

    onGetCode(context) {
        if (!this.shader_destination) {
            return;
        }

        var props = this.properties;

        var varname = getShaderNodeVarName(this);
        var code =
            "vec4 " +
            varname +
            " = " +
            valueToGLSL([props.x, props.y, props.z, props.w]) +
            ";\n";

        for (let i = 0; i < LGraphShaderVec4.varmodes.length; ++i) {
            let varmode = LGraphShaderVec4.varmodes[i];
            let inlink = getInputLinkID(this, i);
            if (!inlink) continue;
            code += "	" + varname + "." + varmode + " = " + inlink + ";\n";
        }

        for (let i = 0; i < LGraphShaderVec4.varmodes.length; ++i) {
            let varmode = LGraphShaderVec4.varmodes[i];
            let outlink = getOutputLinkID(this, i);
            if (!outlink) continue;
            var type = GLSL_types_const[varmode.length - 1];
            code +=
                "	" +
                type +
                " " +
                outlink +
                " = " +
                varname +
                "." +
                varmode +
                ";\n";
            this.setOutputData(i, type);
        }
        context.addCode("code", code, this.shader_destination);
    }
}
registerShaderNode("const/vec4", LGraphShaderVec4);


class LGraphShaderFragColor {
    constructor() {
        this.addInput("color", LGShaders.ALL_TYPES);
        this.block_delete = true;
    }

    static title = "FragColor";
    static desc = "Pixel final color";

    onGetCode(context) {
        var link_name = getInputLinkID(this, 0);
        if (!link_name) {
            return;
        }
        var type = this.getInputData(0);
        var code = varToTypeGLSL(link_name, type, "vec4");
        context.addCode("fs_code", "fragcolor = " + code + ";");
    }
}
registerShaderNode("output/fragcolor", LGraphShaderFragColor);


/*
function LGraphShaderDiscard()
{
    this.addInput("v","T");
    this.addInput("min","T");
    this.properties = { min_value: 0.0 };
    this.addWidget("number","min",0,{ step: 0.01, property: "min_value" });
}

LGraphShaderDiscard.title = "Discard";

LGraphShaderDiscard.prototype.onGetCode = function( context )
{
    if(!this.isOutputConnected(0))
        return;

    var inlink = getInputLinkID(this,0);
    var inlink1 = getInputLinkID(this,1);

    if(!inlink && !inlink1) //not connected
        return;
    context.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );
    this.setOutputData( 0, return_type );
}

registerShaderNode( "output/discard", LGraphShaderDiscard );
*/


class LGraphShaderOperation {
    constructor() {
        this.addInput("A", LGShaders.ALL_TYPES);
        this.addInput("B", LGShaders.ALL_TYPES);
        this.addOutput("out", "");
        this.properties = {operation: "*"};
        this.addWidget("combo", "op.", this.properties.operation, {
            property: "operation",
            values: LGraphShaderOperation.operations,
        });
    }

    static title = "Operation";
    static operations = ["+", "-", "*", "/"];

    getTitle() {
        if (this.flags.collapsed)
            return "A" + this.properties.operation + "B";
        else
            return "Operation";
    }

    onGetCode(context) {
        if (!this.shader_destination)
            return;

        if (!this.isOutputConnected(0))
            return;

        var inlinks = [];
        for (let i = 0; i < 3; ++i)
            inlinks.push({
                name: getInputLinkID(this, i),
                type: this.getInputData(i) || "float",
            });

        var outlink = getOutputLinkID(this, 0);
        if (!outlink)
            // not connected
            return;

        // func_desc
        var base_type = inlinks[0].type;
        var return_type = base_type;
        var op = this.properties.operation;

        var params = [];
        for (let i = 0; i < 2; ++i) {
            var param_code = inlinks[i].name;
            if (param_code == null) {
                // not plugged
                param_code = p.value != null ? p.value : "(1.0)";
                inlinks[i].type = "float";
            }

            // convert
            if (inlinks[i].type != base_type) {
                if (inlinks[i].type == "float" && (op == "*" || op == "/")) {
                    // I find hard to create the opposite condition now, so I prefeer an else
                } else
                    param_code = convertVarToGLSLType(
                        param_code,
                        inlinks[i].type,
                        base_type,
                    );
            }
            params.push(param_code);
        }

        context.addCode(
            "code",
            return_type +
                " " +
                outlink +
                " = " +
                params[0] +
                op +
                params[1] +
                ";",
            this.shader_destination,
        );
        this.setOutputData(0, return_type);
    }
}
registerShaderNode("math/operation", LGraphShaderOperation);


class LGraphShaderFunc {
    constructor() {
        this.addInput("A", LGShaders.ALL_TYPES);
        this.addInput("B", LGShaders.ALL_TYPES);
        this.addOutput("out", "");
        this.properties = {func: "floor"};
        this._current = "floor";
        this.addWidget(
            "combo",
            "func",
            this.properties.func, {
                property: "func",
                values: GLSL_functions_name,
            },
        );
    }

    static title = "Func";

    onPropertyChanged(name, value) {
        if (this.graph) {
            this.graph._version++;
        }
        if (name == "func") {
            var func_desc = GLSL_functions[value];
            if (!func_desc)
                return;

            // remove extra inputs
            for (let i = func_desc.params.length; i < this.inputs.length; ++i)
                this.removeInput(i);

            // add and update inputs
            for (let i = 0; i < func_desc.params.length; ++i) {
                var p = func_desc.params[i];
                if (this.inputs[i])
                    this.inputs[i].name =
                        p.name + (p.value ? " (" + p.value + ")" : "");
                else this.addInput(p.name, LGShaders.ALL_TYPES);
            }
        }
    }

    getTitle() {
        if (this.flags.collapsed)
            return this.properties.func;
        else
            return "Func";
    }

    onGetCode(context) {
        if (!this.shader_destination)
            return;

        if (!this.isOutputConnected(0))
            return;

        var inlinks = [];
        for (let i = 0; i < 3; ++i)
            inlinks.push({
                name: getInputLinkID(this, i),
                type: this.getInputData(i) || "float",
            });

        var outlink = getOutputLinkID(this, 0);
        if (!outlink)
            // not connected
            return;

        var func_desc = GLSL_functions[this.properties.func];
        if (!func_desc)
            return;

        // func_desc
        var base_type = inlinks[0].type;
        var return_type = func_desc.return_type;
        if (return_type == "T")
            return_type = base_type;

        var params = [];
        for (let i = 0; i < func_desc.params.length; ++i) {
            var p = func_desc.params[i];
            var param_code = inlinks[i].name;
            if (param_code == null) {
                // not plugged
                param_code = p.value != null ? p.value : "(1.0)";
                inlinks[i].type = "float";
            }
            if (
                (p.type == "T" && inlinks[i].type != base_type) ||
                (p.type != "T" && inlinks[i].type != base_type)
            )
                param_code = convertVarToGLSLType(
                    param_code,
                    inlinks[i].type,
                    base_type,
                );
            params.push(param_code);
        }
        context.addFunction(
            "round",
            "float round(float v){ return floor(v+0.5); }\nvec2 round(vec2 v){ return floor(v+vec2(0.5));}\nvec3 round(vec3 v){ return floor(v+vec3(0.5));}\nvec4 round(vec4 v){ return floor(v+vec4(0.5)); }\n",
        );
        context.addCode(
            "code",
            return_type +
                " " +
                outlink +
                " = " +
                func_desc.func +
                "(" +
                params.join(",") +
                ");",
            this.shader_destination,
        );

        this.setOutputData(0, return_type);
    }
}
registerShaderNode("math/func", LGraphShaderFunc);


class LGraphShaderSnippet {
    constructor() {
        this.addInput("A", LGShaders.ALL_TYPES);
        this.addInput("B", LGShaders.ALL_TYPES);
        this.addOutput("C", "vec4");
        this.properties = {
            code: "C = A+B",
            type: "vec4",
        };
        this.addWidget("text", "code", this.properties.code, {property: "code"});
        this.addWidget("combo", "type", this.properties.type, {
            values: ["float", "vec2", "vec3", "vec4"],
            property: "type",
        });
    }

    static title = "Snippet";

    onPropertyChanged(name, value) {
        if (this.graph)
            this.graph._version++;

        if (name == "type" && this.outputs[0].type != value) {
            this.disconnectOutput(0);
            this.outputs[0].type = value;
        }
    }

    getTitle() {
        if (this.flags.collapsed)
            return this.properties.code;
        else
            return "Snippet";
    }

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var inlinkA = getInputLinkID(this, 0);
        if (!inlinkA)
            inlinkA = "1.0";
        var inlinkB = getInputLinkID(this, 1);
        if (!inlinkB)
            inlinkB = "1.0";
        var outlink = getOutputLinkID(this, 0);
        if (!outlink)
            // not connected
            return;

        var inA_type = this.getInputData(0) || "float";
        var inB_type = this.getInputData(1) || "float";
        var return_type = this.properties.type;

        // cannot resolve input
        if (inA_type == "T" || inB_type == "T") {
            return null;
        }

        var funcname = "funcSnippet" + this.id;

        var func_code =
            "\n" +
            return_type +
            " " +
            funcname +
            "( " +
            inA_type +
            " A, " +
            inB_type +
            " B) {\n";
        func_code += "	" + return_type + " C = " + return_type + "(0.0);\n";
        func_code += "	" + this.properties.code + ";\n";
        func_code += "	return C;\n}\n";

        context.addCode("functions", func_code, this.shader_destination);
        context.addCode(
            "code",
            return_type +
                " " +
                outlink +
                " = " +
                funcname +
                "(" +
                inlinkA +
                "," +
                inlinkB +
                ");",
            this.shader_destination,
        );

        this.setOutputData(0, return_type);
    }
}
registerShaderNode("utils/snippet", LGraphShaderSnippet);


class LGraphShaderRand {
    constructor() {
        this.addOutput("out", "float");
    }

    static title = "Rand";

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var outlink = getOutputLinkID(this, 0);

        context.addUniform("u_rand" + this.id, "float", function () {
            return Math.random();
        });
        context.addCode(
            "code",
            "float " + outlink + " = u_rand" + this.id + ";",
            this.shader_destination,
        );
        this.setOutputData(0, "float");
    }
}
registerShaderNode("input/rand", LGraphShaderRand);


// noise
// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
class LGraphShaderNoise {
    constructor() {
        this.addInput("out", LGShaders.ALL_TYPES);
        this.addInput("scale", "float");
        this.addOutput("out", "float");
        this.properties = {
            type: "noise",
            scale: 1,
        };
        this.addWidget("combo", "type", this.properties.type, {
            property: "type",
            values: LGraphShaderNoise.NOISE_TYPES,
        });
        this.addWidget("number", "scale", this.properties.scale, {property: "scale"});
    }

    static NOISE_TYPES = ["noise", "rand"];

    static title = "noise";

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var inlink = getInputLinkID(this, 0);
        var outlink = getOutputLinkID(this, 0);

        var intype = this.getInputData(0);
        if (!inlink) {
            intype = "vec2";
            inlink = context.buffer_names.uvs;
        }

        context.addFunction("noise", LGraphShaderNoise.shader_functions);
        context.addUniform(
            "u_noise_scale" + this.id,
            "float",
            this.properties.scale,
        );
        if (intype == "float")
            context.addCode(
                "code",
                "float " +
                    outlink +
                    " = snoise( vec2(" +
                    inlink +
                    ") * u_noise_scale" +
                    this.id +
                    ");",
                this.shader_destination,
            );
        else if (intype == "vec2" || intype == "vec3")
            context.addCode(
                "code",
                "float " +
                    outlink +
                    " = snoise(" +
                    inlink +
                    " * u_noise_scale" +
                    this.id +
                    ");",
                this.shader_destination,
            );
        else if (intype == "vec4")
            context.addCode(
                "code",
                "float " +
                    outlink +
                    " = snoise(" +
                    inlink +
                    ".xyz * u_noise_scale" +
                    this.id +
                    ");",
                this.shader_destination,
            );
        this.setOutputData(0, "float");
    }

    static shader_functions = `
        vec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }

        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
            m = m * m ;
            m = m * m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
            vec3 g;
            g.x = a0.x  * x0.x + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }

        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);

            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);

            vec3 x1 = x0 - i1 + 1.0 * C.xxx;
            vec3 x2 = x0 - i2 + 2.0 * C.xxx;
            vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

            i = mod(i, 289.0);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));

            float n_ = 1.0 / 7.0;
            vec3 ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            
            return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }

        vec3 hash3(vec2 p) {
            vec3 q = vec3(dot(p, vec2(127.1, 311.7)),
                        dot(p, vec2(269.5, 183.3)),
                        dot(p, vec2(419.2, 371.9)));
            return fract(sin(q) * 43758.5453);
        }

        vec4 hash4(vec3 p) {
            vec4 q = vec4(dot(p, vec3(127.1, 311.7, 257.3)),
                        dot(p, vec3(269.5, 183.3, 335.1)),
                        dot(p, vec3(314.5, 235.1, 467.3)),
                        dot(p, vec3(419.2, 371.9, 114.9)));
            return fract(sin(q) * 43758.5453);
        }

        float iqnoise(in vec2 x, float u, float v) {
            vec2 p = floor(x);
            vec2 f = fract(x);
            
            float k = 1.0 + 63.0 * pow(1.0 - v, 4.0);
            
            float va = 0.0;
            float wt = 0.0;
            for (int j = -2; j <= 2; j++)
                for (int i = -2; i <= 2; i++) {
                    vec2 g = vec2(float(i), float(j));
                    vec3 o = hash3(p + g) * vec3(u, u, 1.0);
                    vec2 r = g - f + o.xy;
                    float d = dot(r, r);
                    float ww = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), k);
                    va += o.z * ww;
                    wt += ww;
                }
            
            return va / wt;
        }
    `;
}
registerShaderNode("math/noise", LGraphShaderNoise);


class LGraphShaderTime {
    constructor() {
        this.addOutput("out", "float");
    }

    static title = "Time";

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var outlink = getOutputLinkID(this, 0);

        context.addUniform("u_time" + this.id, "float", function () {
            return getTime() * 0.001;
        });
        context.addCode(
            "code",
            "float " + outlink + " = u_time" + this.id + ";",
            this.shader_destination,
        );
        this.setOutputData(0, "float");
    }
}
registerShaderNode("input/time", LGraphShaderTime);


class LGraphShaderDither {
    constructor() {
        this.addInput("in", "T");
        this.addOutput("out", "float");
    }

    static title = "Dither";

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var inlink = getInputLinkID(this, 0);
        var return_type = "float";
        var outlink = getOutputLinkID(this, 0);
        var intype = this.getInputData(0);
        inlink = varToTypeGLSL(inlink, intype, "float");
        context.addFunction("dither8x8", LGraphShaderDither.dither_func);
        context.addCode(
            "code",
            return_type + " " + outlink + " = dither8x8(" + inlink + ");",
            this.shader_destination,
        );
        this.setOutputData(0, return_type);
    }

    static dither_values = [
        0.515625, 0.140625, 0.640625, 0.046875, 0.546875, 0.171875, 0.671875,
        0.765625, 0.265625, 0.890625, 0.390625, 0.796875, 0.296875, 0.921875,
        0.421875, 0.203125, 0.703125, 0.078125, 0.578125, 0.234375, 0.734375,
        0.109375, 0.609375, 0.953125, 0.453125, 0.828125, 0.328125, 0.984375,
        0.484375, 0.859375, 0.359375, 0.0625, 0.5625, 0.1875, 0.6875, 0.03125,
        0.53125, 0.15625, 0.65625, 0.8125, 0.3125, 0.9375, 0.4375, 0.78125,
        0.28125, 0.90625, 0.40625, 0.25, 0.75, 0.125, 0.625, 0.21875, 0.71875,
        0.09375, 0.59375, 1.0001, 0.5, 0.875, 0.375, 0.96875, 0.46875, 0.84375,
        0.34375,
    ];

    static dither_func = `
        float dither8x8(float brightness) {
            vec2 position = vec2(0.0);
            #ifdef FRAGMENT
            position = gl_FragCoord.xy;
            #endif
            int x = int(mod(position.x, 8.0));
            int y = int(mod(position.y, 8.0));
            int index = x + y * 8;
            float limit = 0.0;
            if (x < 8) {
                if (index == 0) limit = 0.015625;
                // Add more conditions or code here if needed
                // Example: if (condition) { ... }
            }
            ${LGraphShaderDither.dither_values.map((v, i) => `else if (index == ${i + 1}) limit = ${v};`).join("\n")}
            return brightness < limit ? 0.0 : 1.0;
        }
    `;
}
registerShaderNode("math/dither", LGraphShaderDither);


class LGraphShaderRemap {
    constructor() {
        this.addInput("", LGShaders.ALL_TYPES);
        this.addOutput("", "");
        this.properties = {
            min_value: 0,
            max_value: 1,
            min_value2: 0,
            max_value2: 1,
        };
        this.addWidget("number", "min", 0, {
            step: 0.1,
            property: "min_value",
        });
        this.addWidget("number", "max", 1, {
            step: 0.1,
            property: "max_value",
        });
        this.addWidget("number", "min2", 0, {
            step: 0.1,
            property: "min_value2",
        });
        this.addWidget("number", "max2", 1, {
            step: 0.1,
            property: "max_value2",
        });
    }

    static title = "Remap";

    onPropertyChanged() {
        if (this.graph)
            this.graph._version++;
    }

    onConnectionsChange() {
        var return_type = this.getInputDataType(0);
        this.outputs[0].type = return_type || "T";
    }

    onGetCode(context) {
        if (!this.shader_destination || !this.isOutputConnected(0))
            return;

        var inlink = getInputLinkID(this, 0);
        var outlink = getOutputLinkID(this, 0);
        if (!inlink && !outlink)
            // not connected
            return;

        var return_type = this.getInputDataType(0);
        this.outputs[0].type = return_type;
        if (return_type == "T") {
            console.warn?.("node type is T and cannot be resolved");
            return;
        }

        if (!inlink) {
            context.addCode(
                "code",
                "	" +
                    return_type +
                    " " +
                    outlink +
                    " = " +
                    return_type +
                    "(0.0);\n",
            );
            return;
        }

        var minv = valueToGLSL(this.properties.min_value);
        var maxv = valueToGLSL(this.properties.max_value);
        var minv2 = valueToGLSL(this.properties.min_value2);
        var maxv2 = valueToGLSL(this.properties.max_value2);

        context.addCode(
            "code",
            `${return_type} ${outlink} = ( (${inlink} - ${minv}) / (${maxv} - ${minv}) ) * (${maxv2} - ${minv2}) + ${minv2};`,
            this.shader_destination,
        );

        this.setOutputData(0, return_type);
    }
}
registerShaderNode("math/remap", LGraphShaderRemap);


// @BUG: Gotta finish cleaning the file up so this doesn't cause the whole thing to crash
// 
var view_matrix = new Float32Array(16);
var projection_matrix = new Float32Array(16);
var viewprojection_matrix = new Float32Array(16);
var model_matrix = new Float32Array(16);
var global_uniforms = {
    u_view: view_matrix,
    u_projection: projection_matrix,
    u_viewprojection: viewprojection_matrix,
    u_model: model_matrix,
};

// overwrite with your 3D engine specifics, it will receive (view_matrix, projection_matrix,viewprojection_matrix) and must be filled
const LGraphRender = { onRequestCameraMatrices: null };

function generateGeometryId() {
    return (Math.random() * 100000) | 0;
}

class LGraphPoints3D {
    constructor() {
        this.addInput("obj", "");
        this.addInput("radius", "number");

        this.addOutput("out", "geometry");
        this.addOutput("points", "[vec3]");
        this.properties = {
            radius: 1,
            num_points: 4096,
            generate_normals: true,
            regular: false,
            mode: LGraphPoints3D.SPHERE,
            force_update: false,
        };

        this.points = new Float32Array(this.properties.num_points * 3);
        this.normals = new Float32Array(this.properties.num_points * 3);
        this.must_update = true;
        this.version = 0;

        var that = this;
        this.addWidget("button", "update", null, function () {
            that.must_update = true;
        });

        this.geometry = {
            vertices: null,
            _id: generateGeometryId(),
        };

        this._old_obj = null;
        this._last_radius = null;
    }

    onPropertyChanged(_name, _value) {
        this.must_update = true;
    }

    onExecute() {
        var obj = this.getInputData(0);
        if (
            obj != this._old_obj ||
            (obj && obj._version != this._old_obj_version)
        ) {
            this._old_obj = obj;
            this.must_update = true;
        }

        var radius = this.getInputData(1);
        if (radius == null) radius = this.properties.radius;
        if (this._last_radius != radius) {
            this._last_radius = radius;
            this.must_update = true;
        }

        if (this.must_update || this.properties.force_update) {
            this.must_update = false;
            this.updatePoints();
        }

        this.geometry.vertices = this.points;
        this.geometry.normals = this.normals;
        this.geometry._version = this.version;

        this.setOutputData(0, this.geometry);
    }

    updatePoints() {
        var num_points = this.properties.num_points | 0;
        if (num_points < 1) num_points = 1;

        if (!this.points || this.points.length != num_points * 3)
            this.points = new Float32Array(num_points * 3);

        if (this.properties.generate_normals) {
            if (!this.normals || this.normals.length != this.points.length)
                this.normals = new Float32Array(this.points.length);
        } else this.normals = null;

        var radius = this._last_radius || this.properties.radius;
        var mode = this.properties.mode;

        var obj = this.getInputData(0);
        this._old_obj_version = obj ? obj._version : null;

        this.points = LGraphPoints3D.generatePoints(
            radius,
            num_points,
            mode,
            this.points,
            this.normals,
            this.properties.regular,
            obj,
        );

        this.version++;
    }

    static generatePoints(radius, num_points, mode, points, normals, regular, obj) {
        var size = num_points * 3;
        if (!points || points.length != size) points = new Float32Array(size);
        var temp = new Float32Array(3);
        var UP = new Float32Array([0, 1, 0]);

        if (regular) {
            if (mode == LGraphPoints3D.RECTANGLE) {
                let side = Math.floor(Math.sqrt(num_points));
                for (let i = 0; i < side; ++i)
                    for (let j = 0; j < side; ++j) {
                        let pos = i * 3 + j * 3 * side;
                        points[pos] = (i / side - 0.5) * radius * 2;
                        points[pos + 1] = 0;
                        points[pos + 2] = (j / side - 0.5) * radius * 2;
                    }
                points = new Float32Array(points.subarray(0, side * side * 3));
                if (normals) {
                    for (let i = 0; i < normals.length; i += 3)
                        normals.set(UP, i);
                }
            } else if (mode == LGraphPoints3D.SPHERE) {
                let side = Math.floor(Math.sqrt(num_points));
                for (let i = 0; i < side; ++i)
                    for (let j = 0; j < side; ++j) {
                        let pos = i * 3 + j * 3 * side;
                        GL.polarToCartesian(
                            temp,
                            (i / side) * 2 * Math.PI,
                            (j / side - 0.5) * 2 * Math.PI,
                            radius,
                        );
                        points[pos] = temp[0];
                        points[pos + 1] = temp[1];
                        points[pos + 2] = temp[2];
                    }
                points = new Float32Array(points.subarray(0, side * side * 3));
                if (normals)
                    LGraphPoints3D.generateSphericalNormals(points, normals);
            } else if (mode == LGraphPoints3D.CIRCLE) {
                for (let i = 0; i < size; i += 3) {
                    let angle = 2 * Math.PI * (i / size);
                    points[i] = Math.cos(angle) * radius;
                    points[i + 1] = 0;
                    points[i + 2] = Math.sin(angle) * radius;
                }
                if (normals) {
                    for (let i = 0; i < normals.length; i += 3)
                        normals.set(UP, i);
                }
            }
        } else { // non regular
            if (mode == LGraphPoints3D.RECTANGLE) {
                for (let i = 0; i < size; i += 3) {
                    points[i] = (Math.random() - 0.5) * radius * 2;
                    points[i + 1] = 0;
                    points[i + 2] = (Math.random() - 0.5) * radius * 2;
                }
                if (normals) {
                    for (let i = 0; i < normals.length; i += 3)
                        normals.set(UP, i);
                }
            } else if (mode == LGraphPoints3D.CUBE) {
                for (let i = 0; i < size; i += 3) {
                    points[i] = (Math.random() - 0.5) * radius * 2;
                    points[i + 1] = (Math.random() - 0.5) * radius * 2;
                    points[i + 2] = (Math.random() - 0.5) * radius * 2;
                }
                if (normals) {
                    for (let i = 0; i < normals.length; i += 3)
                        normals.set(UP, i);
                }
            } else if (mode == LGraphPoints3D.SPHERE) {
                LGraphPoints3D.generateSphere(points, size, radius);
                if (normals)
                    LGraphPoints3D.generateSphericalNormals(points, normals);
            } else if (mode == LGraphPoints3D.HEMISPHERE) {
                LGraphPoints3D.generateHemisphere(points, size, radius);
                if (normals)
                    LGraphPoints3D.generateSphericalNormals(points, normals);
            } else if (mode == LGraphPoints3D.CIRCLE) {
                LGraphPoints3D.generateInsideCircle(points, size, radius);
                if (normals)
                    LGraphPoints3D.generateSphericalNormals(points, normals);
            } else if (mode == LGraphPoints3D.INSIDE_SPHERE) {
                LGraphPoints3D.generateInsideSphere(points, size, radius);
                if (normals)
                    LGraphPoints3D.generateSphericalNormals(points, normals);
            } else if (mode == LGraphPoints3D.OBJECT) {
                LGraphPoints3D.generateFromObject(
                    points,
                    normals,
                    size,
                    obj,
                    false,
                );
            } else if (mode == LGraphPoints3D.OBJECT_UNIFORMLY) {
                LGraphPoints3D.generateFromObject(points, normals, size, obj, true);
            } else if (mode == LGraphPoints3D.OBJECT_INSIDE) {
                LGraphPoints3D.generateFromInsideObject(points, size, obj);
                // if(normals)
                //	LGraphPoints3D.generateSphericalNormals( points, normals );
            } else console.warn?.("wrong mode in LGraphPoints3D");
        }
        return points;
    }

    static generateSphericalNormals(points, normals) {
        var temp = new Float32Array(3);
        for (var i = 0; i < normals.length; i += 3) {
            temp[0] = points[i];
            temp[1] = points[i + 1];
            temp[2] = points[i + 2];
            vec3.normalize(temp, temp);
            normals.set(temp, i);
        }
    }

    static generateSphere(points, size, radius) {
        for (var i = 0; i < size; i += 3) {
            var r1 = Math.random();
            var r2 = Math.random();
            var x = 2 * Math.cos(2 * Math.PI * r1) * Math.sqrt(r2 * (1 - r2));
            var y = 1 - 2 * r2;
            var z = 2 * Math.sin(2 * Math.PI * r1) * Math.sqrt(r2 * (1 - r2));
            points[i] = x * radius;
            points[i + 1] = y * radius;
            points[i + 2] = z * radius;
        }
    }

    static generateHemisphere(points, size, radius) {
        for (var i = 0; i < size; i += 3) {
            var r1 = Math.random();
            var r2 = Math.random();
            var x = Math.cos(2 * Math.PI * r1) * Math.sqrt(1 - r2 * r2);
            var y = r2;
            var z = Math.sin(2 * Math.PI * r1) * Math.sqrt(1 - r2 * r2);
            points[i] = x * radius;
            points[i + 1] = y * radius;
            points[i + 2] = z * radius;
        }
    }

    static generateInsideCircle(points, size, radius) {
        for (var i = 0; i < size; i += 3) {
            var r1 = Math.random();
            var r2 = Math.random();
            var x = Math.cos(2 * Math.PI * r1) * Math.sqrt(1 - r2 * r2);
            var z = Math.sin(2 * Math.PI * r1) * Math.sqrt(1 - r2 * r2);
            points[i] = x * radius;
            points[i + 1] = 0;
            points[i + 2] = z * radius;
        }
    }

    static generateInsideSphere(points, size, radius) {
        for (var i = 0; i < size; i += 3) {
            var u = Math.random();
            var v = Math.random();
            var theta = u * 2.0 * Math.PI;
            var phi = Math.acos(2.0 * v - 1.0);
            var r = Math.cbrt(Math.random()) * radius;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);
            points[i] = r * sinPhi * cosTheta;
            points[i + 1] = r * sinPhi * sinTheta;
            points[i + 2] = r * cosPhi;
        }
    }

    static generateFromObject(points, normals, size, obj, evenly) {
        if (!obj) return;

        var vertices = null;
        var mesh_normals = null;
        var indices = null;
        var areas = null;

        function findRandomTriangle(areas, f) {
            var l = areas.length;
            var imin = 0;
            var imid = 0;
            var imax = l;

            if (l == 0) return -1;
            if (l == 1) return 0;
            // dichotomic search
            while (imax >= imin) {
                imid = ((imax + imin) * 0.5) | 0;
                var t = areas[imid];
                if (t == f) return imid;
                if (imin == imax - 1) return imin;
                if (t < f) imin = imid;
                else imax = imid;
            }
            return imid;
        }

        if (obj.constructor === GL.Mesh) {
            vertices = obj.vertexBuffers.vertices.data;
            mesh_normals = obj.vertexBuffers.normals
                ? obj.vertexBuffers.normals.data
                : null;
            indices = obj.indexBuffers.indices
                ? obj.indexBuffers.indices.data
                : null;
            if (!indices)
                indices = obj.indexBuffers.triangles
                    ? obj.indexBuffers.triangles.data
                    : null;
        }
        if (!vertices) return null;
        var num_triangles = indices
            ? indices.length / 3
            : vertices.length / (3 * 3);
        var total_area = 0; // sum of areas of all triangles

        if (evenly) {
            areas = new Float32Array(num_triangles); // accum
            for (let i = 0; i < num_triangles; ++i) {
                if (indices) {
                    a = indices[i * 3] * 3;
                    b = indices[i * 3 + 1] * 3;
                    c = indices[i * 3 + 2] * 3;
                } else {
                    a = i * 9;
                    b = i * 9 + 3;
                    c = i * 9 + 6;
                }
                var P1 = vertices.subarray(a, a + 3);
                var P2 = vertices.subarray(b, b + 3);
                var P3 = vertices.subarray(c, c + 3);
                var aL = vec3.distance(P1, P2);
                var bL = vec3.distance(P2, P3);
                var cL = vec3.distance(P3, P1);
                var s = (aL + bL + cL) / 2;
                total_area += Math.sqrt(s * (s - aL) * (s - bL) * (s - cL));
                areas[i] = total_area;
            }
            for (let i = 0; i < num_triangles; ++i) // normalize
                areas[i] /= total_area;
        }

        for (let i = 0; i < size; i += 3) {
            var r = Math.random();
            var index = evenly
                ? findRandomTriangle(areas, r)
                : Math.floor(r * num_triangles);
            // get random triangle
            var a = 0;
            var b = 0;
            var c = 0;
            if (indices) {
                a = indices[index * 3] * 3;
                b = indices[index * 3 + 1] * 3;
                c = indices[index * 3 + 2] * 3;
            } else {
                a = index * 9;
                b = index * 9 + 3;
                c = index * 9 + 6;
            }
            var s = Math.random();
            var t = Math.random();
            var sqrt_s = Math.sqrt(s);
            var af = 1 - sqrt_s;
            var bf = sqrt_s * (1 - t);
            var cf = t * sqrt_s;
            points[i] = af * vertices[a] + bf * vertices[b] + cf * vertices[c];
            points[i + 1] =
                af * vertices[a + 1] + bf * vertices[b + 1] + cf * vertices[c + 1];
            points[i + 2] =
                af * vertices[a + 2] + bf * vertices[b + 2] + cf * vertices[c + 2];
            if (normals && mesh_normals) {
                normals[i] =
                    af * mesh_normals[a] +
                    bf * mesh_normals[b] +
                    cf * mesh_normals[c];
                normals[i + 1] =
                    af * mesh_normals[a + 1] +
                    bf * mesh_normals[b + 1] +
                    cf * mesh_normals[c + 1];
                normals[i + 2] =
                    af * mesh_normals[a + 2] +
                    bf * mesh_normals[b + 2] +
                    cf * mesh_normals[c + 2];
                var N = normals.subarray(i, i + 3);
                vec3.normalize(N, N);
            }
        }
    }

    static generateFromInsideObject(points, size, mesh) {
        if (!mesh || mesh.constructor !== GL.Mesh)
            return;

        var aabb = mesh.getBoundingBox();
        if (!mesh.octree)
            mesh.octree = new GL.Octree(mesh);
        var octree = mesh.octree;
        var origin = vec3.create();
        var direction = vec3.fromValues(1, 0, 0);
        var temp = vec3.create();
        var i = 0;
        var tries = 0;
        while (i < size && tries < points.length * 10) {
            // limit to avoid problems
            tries += 1;
            var r = vec3.random(temp); // random point inside the aabb
            r[0] = (r[0] * 2 - 1) * aabb[3] + aabb[0];
            r[1] = (r[1] * 2 - 1) * aabb[4] + aabb[1];
            r[2] = (r[2] * 2 - 1) * aabb[5] + aabb[2];
            origin.set(r);
            var hit = octree.testRay(
                origin,
                direction,
                0,
                10000,
                true,
                GL.Octree.ALL,
            );
            if (!hit || hit.length % 2 == 0)
                // not inside
                continue;
            points.set(r, i);
            i += 3;
        }
    }

    static RECTANGLE = 1;
    static CIRCLE = 2;

    static CUBE = 10;
    static SPHERE = 11;
    static HEMISPHERE = 12;
    static INSIDE_SPHERE = 13;

    static OBJECT = 20;
    static OBJECT_UNIFORMLY = 21;
    static OBJECT_INSIDE = 22;

    static MODE_VALUES = {
        rectangle: LGraphPoints3D.RECTANGLE,
        circle: LGraphPoints3D.CIRCLE,
        cube: LGraphPoints3D.CUBE,
        sphere: LGraphPoints3D.SPHERE,
        hemisphere: LGraphPoints3D.HEMISPHERE,
        inside_sphere: LGraphPoints3D.INSIDE_SPHERE,
        object: LGraphPoints3D.OBJECT,
        object_uniformly: LGraphPoints3D.OBJECT_UNIFORMLY,
        object_inside: LGraphPoints3D.OBJECT_INSIDE,
    };

    static widgets_info = {
        mode: {
            widget: "combo",
            values: LGraphPoints3D.MODE_VALUES,
        },
    };

    static title = "list of points";
    static desc = "returns an array of points";
}
LiteGraph.registerNodeType("geometry/points3D", LGraphPoints3D);


class LGraphPointsToInstances {
    constructor() {
        this.addInput("points", "geometry");
        this.addOutput("instances", "[mat4]");
        this.properties = {
            mode: 1,
            autoupdate: true,
        };

        this.must_update = true;
        this.matrices = [];
        this.first_time = true;
    }

    onExecute() {
        var geo = this.getInputData(0);
        if (!geo) {
            this.setOutputData(0, null);
            return;
        }

        if (!this.isOutputConnected(0)) return;

        var has_changed =
            geo._version != this._version || geo._id != this._geometry_id;

        if ((has_changed && this.properties.autoupdate) || this.first_time) {
            this.first_time = false;
            this.updateInstances(geo);
        }

        this.setOutputData(0, this.matrices);
    }

    updateInstances(geometry) {
        var vertices = geometry.vertices;
        if (!vertices) return null;
        var normals = geometry.normals;

        var matrices = this.matrices;
        var num_points = vertices.length / 3;
        if (matrices.length != num_points) matrices.length = num_points;
        var identity = mat4.create();
        var temp = vec3.create();
        var UP = vec3.fromValues(0, 1, 0);
        var FRONT = vec3.fromValues(0, 0, -1);
        var R = quat.create();

        var front = vec3.create();
        var right = vec3.create();
        var top = vec3.create();

        for (var i = 0; i < vertices.length; i += 3) {
            var index = i / 3;
            var m = matrices[index];
            if (!m) m = matrices[index] = mat4.create();
            m.set(identity);
            var point = vertices.subarray(i, i + 3);

            switch (this.properties.mode) {
                case LGraphPointsToInstances.NORMAL:
                    mat4.setTranslation(m, point);
                    if (normals) {
                        var normal = normals.subarray(i, i + 3);
                        top.set(normal);
                        vec3.normalize(top, top);
                        vec3.cross(right, FRONT, top);
                        vec3.normalize(right, right);
                        vec3.cross(front, right, top);
                        vec3.normalize(front, front);
                        m.set(right, 0);
                        m.set(top, 4);
                        m.set(front, 8);
                        mat4.setTranslation(m, point);
                    }
                    break;
                case LGraphPointsToInstances.VERTICAL:
                    mat4.setTranslation(m, point);
                    break;
                case LGraphPointsToInstances.SPHERICAL:
                    front.set(point);
                    vec3.normalize(front, front);
                    vec3.cross(right, UP, front);
                    vec3.normalize(right, right);
                    vec3.cross(top, front, right);
                    vec3.normalize(top, top);
                    m.set(right, 0);
                    m.set(top, 4);
                    m.set(front, 8);
                    mat4.setTranslation(m, point);
                    break;
                case LGraphPointsToInstances.RANDOM:
                    temp[0] = Math.random() * 2 - 1;
                    temp[1] = Math.random() * 2 - 1;
                    temp[2] = Math.random() * 2 - 1;
                    vec3.normalize(temp, temp);
                    quat.setAxisAngle(R, temp, Math.random() * 2 * Math.PI);
                    mat4.fromQuat(m, R);
                    mat4.setTranslation(m, point);
                    break;
                case LGraphPointsToInstances.RANDOM_VERTICAL:
                    quat.setAxisAngle(R, UP, Math.random() * 2 * Math.PI);
                    mat4.fromQuat(m, R);
                    mat4.setTranslation(m, point);
                    break;
            }
        }

        this._version = geometry._version;
        this._geometry_id = geometry._id;
    }

    static NORMAL = 0;
    static VERTICAL = 1;
    static SPHERICAL = 2;
    static RANDOM = 3;
    static RANDOM_VERTICAL = 4;

    static modes = {
        normal: 0,
        vertical: 1,
        spherical: 2,
        random: 3,
        random_vertical: 4,
    };
    static widgets_info = {
        mode: {
            widget: "combo",
            values: LGraphPointsToInstances.modes,
        },
    };

    static title = "points to inst";
}
LiteGraph.registerNodeType("geometry/points_to_instances", LGraphPointsToInstances);


class LGraphGeometryTransform {
    constructor() {
        this.addInput("in", "geometry,[mat4]");
        this.addInput("mat4", "mat4");
        this.addOutput("out", "geometry");
        this.properties = {};

        this.geometry = {
            type: "triangles",
            vertices: null,
            _id: generateGeometryId(),
            _version: 0,
        };

        this._last_geometry_id = -1;
        this._last_version = -1;
        this._last_key = "";

        this.must_update = true;
    }

    onExecute() {
        var input = this.getInputData(0);
        var model = this.getInputData(1);

        if (!input) return;

        // array of matrices
        if (input.constructor === Array) {
            if (input.length == 0) return;
            this.outputs[0].type = "[mat4]";
            if (!this.isOutputConnected(0)) return;

            if (!model) {
                this.setOutputData(0, input);
                return;
            }

            if (!this._output)
                this._output = new Array();
            if (this._output.length != input.length)
                this._output.length = input.length;
            for (var i = 0; i < input.length; ++i) {
                var m = this._output[i];
                if (!m) m = this._output[i] = mat4.create();
                mat4.multiply(m, input[i], model);
            }
            this.setOutputData(0, this._output);
            return;
        }

        // geometry
        if (!input.vertices || !input.vertices.length)
            return;
        var geo = input;
        this.outputs[0].type = "geometry";
        if (!this.isOutputConnected(0))
            return;
        if (!model) {
            this.setOutputData(0, geo);
            return;
        }

        var key = Array.from(model).join(",");

        if (
            this.must_update ||
            geo._id != this._last_geometry_id ||
            geo._version != this._last_version ||
            key != this._last_key
        ) {
            this.updateGeometry(geo, model);
            this._last_key = key;
            this._last_version = geo._version;
            this._last_geometry_id = geo._id;
            this.must_update = false;
        }

        this.setOutputData(0, this.geometry);
    }

    updateGeometry(geometry, model) {
        var old_vertices = geometry.vertices;
        var vertices = this.geometry.vertices;
        if (!vertices || vertices.length != old_vertices.length)
            vertices = this.geometry.vertices = new Float32Array(old_vertices.length);
        var temp = vec3.create();

        for (let i = 0, l = vertices.length; i < l; i += 3) {
            temp[0] = old_vertices[i];
            temp[1] = old_vertices[i + 1];
            temp[2] = old_vertices[i + 2];
            mat4.multiplyVec3(temp, model, temp);
            vertices[i] = temp[0];
            vertices[i + 1] = temp[1];
            vertices[i + 2] = temp[2];
        }

        if (geometry.normals) {
            if (
                !this.geometry.normals ||
                this.geometry.normals.length != geometry.normals.length
            )
                this.geometry.normals = new Float32Array(geometry.normals.length);
            var normals = this.geometry.normals;
            var normal_model = mat4.invert(mat4.create(), model);
            if (normal_model) mat4.transpose(normal_model, normal_model);
            var old_normals = geometry.normals;
            for (let i = 0, l = normals.length; i < l; i += 3) {
                temp[0] = old_normals[i];
                temp[1] = old_normals[i + 1];
                temp[2] = old_normals[i + 2];
                mat4.multiplyVec3(temp, normal_model, temp);
                normals[i] = temp[0];
                normals[i + 1] = temp[1];
                normals[i + 2] = temp[2];
            }
        }

        this.geometry.type = geometry.type;
        this.geometry._version++;
    }

    static title = "Transform";
}
LiteGraph.registerNodeType("geometry/transform", LGraphGeometryTransform);


class LGraphGeometryPolygon {
    constructor() {
        this.addInput("sides", "number");
        this.addInput("radius", "number");
        this.addOutput("out", "geometry");
        this.properties = { sides: 6, radius: 1, uvs: false };

        this.geometry = {
            type: "line_loop",
            vertices: null,
            _id: generateGeometryId(),
        };
        this.geometry_id = -1;
        this.version = -1;
        this.must_update = true;

        this.last_info = { sides: -1, radius: -1 };
    }

    onExecute() {
        if (!this.isOutputConnected(0)) return;

        var sides = this.getInputOrProperty("sides");
        var radius = this.getInputOrProperty("radius");
        sides = Math.max(3, sides) | 0;

        // update
        if (this.last_info.sides != sides || this.last_info.radius != radius)
            this.updateGeometry(sides, radius);

        this.setOutputData(0, this.geometry);
    }

    updateGeometry(sides, radius) {
        var num = 3 * sides;
        var vertices = this.geometry.vertices;
        if (!vertices || vertices.length != num)
            vertices = this.geometry.vertices = new Float32Array(3 * sides);
        var delta = (Math.PI * 2) / sides;
        var gen_uvs = this.properties.uvs;
        if (gen_uvs) {
            uvs = this.geometry.coords = new Float32Array(3 * sides);
        }

        for (var i = 0; i < sides; ++i) {
            var angle = delta * -i;
            var x = Math.cos(angle) * radius;
            var y = 0;
            var z = Math.sin(angle) * radius;
            vertices[i * 3] = x;
            vertices[i * 3 + 1] = y;
            vertices[i * 3 + 2] = z;
        }
        this.geometry._id = ++this.geometry_id;
        this.geometry._version = ++this.version;
        this.last_info.sides = sides;
        this.last_info.radius = radius;
    }
    static title = "Polygon";
}
LiteGraph.registerNodeType("geometry/polygon", LGraphGeometryPolygon);


class LGraphGeometryExtrude {
    constructor() {
        this.addInput("", "geometry");
        this.addOutput("", "geometry");
        this.properties = {
            top_cap: true,
            bottom_cap: true,
            offset: [0, 100, 0],
        };
        this.version = -1;

        this._last_geo_version = -1;
        this._must_update = true;
    }

    onPropertyChanged(_name, _value) {
        this._must_update = true;
    }

    onExecute() {
        var geo = this.getInputData(0);
        if (!geo || !this.isOutputConnected(0)) return;

        if (geo.version != this._last_geo_version || this._must_update) {
            this._geo = this.extrudeGeometry(geo, this._geo);
            if (this._geo) this._geo.version = this.version++;
            this._must_update = false;
        }

        this.setOutputData(0, this._geo);
    }

    extrudeGeometry(geo) {
        // for every pair of vertices
        var vertices = geo.vertices;
        var num_points = vertices.length / 3;

        var tempA = vec3.create();
        var tempB = vec3.create();
        var tempC = vec3.create();
        var tempD = vec3.create();
        var offset = new Float32Array(this.properties.offset);

        if (geo.type == "line_loop") {
            var new_vertices = new Float32Array(num_points * 6 * 3); // every points become 6 ( caps not included )
            var npos = 0;
            for (var i = 0, l = vertices.length; i < l; i += 3) {
                tempA[0] = vertices[i];
                tempA[1] = vertices[i + 1];
                tempA[2] = vertices[i + 2];

                if (i + 3 < l) {
                    // loop
                    tempB[0] = vertices[i + 3];
                    tempB[1] = vertices[i + 4];
                    tempB[2] = vertices[i + 5];
                } else {
                    tempB[0] = vertices[0];
                    tempB[1] = vertices[1];
                    tempB[2] = vertices[2];
                }

                vec3.add(tempC, tempA, offset);
                vec3.add(tempD, tempB, offset);

                new_vertices.set(tempA, npos);
                npos += 3;
                new_vertices.set(tempB, npos);
                npos += 3;
                new_vertices.set(tempC, npos);
                npos += 3;

                new_vertices.set(tempB, npos);
                npos += 3;
                new_vertices.set(tempD, npos);
                npos += 3;
                new_vertices.set(tempC, npos);
                npos += 3;
            }
        }

        var out_geo = {
            _id: generateGeometryId(),
            type: "triangles",
            vertices: new_vertices,
        };

        return out_geo;
    }
    static title = "extrude";
}
LiteGraph.registerNodeType("geometry/extrude", LGraphGeometryExtrude);


class LGraphGeometryEval {
    constructor() {
        this.addInput("in", "geometry");
        this.addOutput("out", "geometry");

        this.properties = {
            code: "V[1] += 0.01 * Math.sin(I + T*0.001);",
            execute_every_frame: false,
        };

        this.geometry = null;
        this.geometry_id = -1;
        this.version = -1;
        this.must_update = true;

        this.vertices = null;
        this.func = null;
    }

    onConfigure() {
        this.compileCode();
    }

    compileCode() {
        if (!this.properties.code) return;

        try {
            this.func = new Function("V", "I", "T", this.properties.code);
            this.boxcolor = "#AFA";
            this.must_update = true;
        } catch (err) {
            this.boxcolor = "red";
        }
    }

    onPropertyChanged(name, value) {
        if (name == "code") {
            this.properties.code = value;
            this.compileCode();
        }
    }

    onExecute() {
        var geometry = this.getInputData(0);
        if (!geometry) return;

        if (!this.func) {
            this.setOutputData(0, geometry);
            return;
        }

        if (
            this.geometry_id != geometry._id ||
            this.version != geometry._version ||
            this.must_update ||
            this.properties.execute_every_frame
        ) {
            this.must_update = false;
            this.geometry_id = geometry._id;
            if (this.properties.execute_every_frame) this.version++;
            else this.version = geometry._version;
            var func = this.func;
            var T = getTime();

            // clone
            if (!this.geometry) this.geometry = {};
            for (let i in geometry) {
                if (geometry[i] == null) continue;
                if (geometry[i].constructor == Float32Array)
                    this.geometry[i] = new Float32Array(geometry[i]);
                else this.geometry[i] = geometry[i];
            }
            this.geometry._id = geometry._id;
            if (this.properties.execute_every_frame)
                this.geometry._version = this.version;
            else this.geometry._version = geometry._version + 1;

            var V = vec3.create();
            var vertices = this.vertices;
            if (!vertices || this.vertices.length != geometry.vertices.length)
                vertices = this.vertices = new Float32Array(geometry.vertices);
            else vertices.set(geometry.vertices);
            for (let i = 0; i < vertices.length; i += 3) {
                V[0] = vertices[i];
                V[1] = vertices[i + 1];
                V[2] = vertices[i + 2];
                func(V, i / 3, T);
                vertices[i] = V[0];
                vertices[i + 1] = V[1];
                vertices[i + 2] = V[2];
            }
            this.geometry.vertices = vertices;
        }

        this.setOutputData(0, this.geometry);
    }

    static title = "geoeval";
    static desc = "eval code";
    static widgets_info = { code: { widget: "code" } };
}
LiteGraph.registerNodeType("geometry/eval", LGraphGeometryEval);


/*
function LGraphGeometryDisplace() {
    this.addInput("in", "geometry");
    this.addInput("img", "image");
    this.addOutput("out", "geometry");

    this.properties = {
        grid_size: 1
    };

    this.geometry = null;
    this.geometry_id = -1;
    this.version = -1;
    this.must_update = true;

    this.vertices = null;
}

LGraphGeometryDisplace.title = "displace";
LGraphGeometryDisplace.desc = "displace points";

LGraphGeometryDisplace.prototype.onExecute = function() {
    var geometry = this.getInputData(0);
    var image = this.getInputData(1);
    if(!geometry)
        return;

    if(!image)
    {
        this.setOutputData(0,geometry);
        return;
    }

    if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )
    {
        this.must_update = false;
        this.geometry_id = geometry._id;
        this.version = geometry._version;

        //copy
        this.geometry = {};
        for(var i in geometry)
            this.geometry[i] = geometry[i];
        this.geometry._id = geometry._id;
        this.geometry._version = geometry._version + 1;

        var grid_size = this.properties.grid_size;
        if(grid_size != 0)
        {
            var vertices = this.vertices;
            if(!vertices || this.vertices.length != this.geometry.vertices.length)
                vertices = this.vertices = new Float32Array( this.geometry.vertices );
            for(var i = 0; i < vertices.length; i+=3)
            {
                vertices[i] = Math.round(vertices[i]/grid_size) * grid_size;
                vertices[i+1] = Math.round(vertices[i+1]/grid_size) * grid_size;
                vertices[i+2] = Math.round(vertices[i+2]/grid_size) * grid_size;
            }
            this.geometry.vertices = vertices;
        }
    }

    this.setOutputData(0,this.geometry);
}

LiteGraph.registerNodeType( "geometry/displace", LGraphGeometryDisplace );
*/

class LGraphConnectPoints {
    constructor() {
        this.addInput("in", "geometry");
        this.addOutput("out", "geometry");

        this.properties = {
            min_dist: 0.4,
            max_dist: 0.5,
            max_connections: 0,
            probability: 1,
        };

        this.geometry_id = -1;
        this.version = -1;
        this.my_version = 1;
        this.must_update = true;
    }

    onPropertyChanged(_name, _value) {
        this.must_update = true;
    }

    onExecute() {
        var geometry = this.getInputData(0);
        if (!geometry) return;

        if (
            this.geometry_id != geometry._id ||
            this.version != geometry._version ||
            this.must_update
        ) {
            this.must_update = false;
            this.geometry_id = geometry._id;
            this.version = geometry._version;

            // copy
            this.geometry = {};
            for (let i in geometry)
                this.geometry[i] = geometry[i];
            this.geometry._id = generateGeometryId();
            this.geometry._version = this.my_version++;

            var vertices = geometry.vertices;
            var l = vertices.length;
            var min_dist = this.properties.min_dist;
            var max_dist = this.properties.max_dist;
            var probability = this.properties.probability;
            var max_connections = this.properties.max_connections;
            var indices = [];

            for (let i = 0; i < l; i += 3) {
                var x = vertices[i];
                var y = vertices[i + 1];
                var z = vertices[i + 2];
                var connections = 0;
                for (let j = i + 3; j < l; j += 3) {
                    var x2 = vertices[j];
                    var y2 = vertices[j + 1];
                    var z2 = vertices[j + 2];
                    var dist = Math.sqrt((x - x2) * (x - x2) +
                            (y - y2) * (y - y2) +
                            (z - z2) * (z - z2));
                    if (
                        dist > max_dist ||
                        dist < min_dist ||
                        (probability < 1 && probability < Math.random())
                    )
                        continue;
                    indices.push(i / 3, j / 3);
                    connections += 1;
                    if (max_connections && connections > max_connections) break;
                }
            }
            this.geometry.indices = this.indices = new Uint32Array(indices);
        }

        if (this.indices && this.indices.length) {
            this.geometry.indices = this.indices;
            this.setOutputData(0, this.geometry);
        } else this.setOutputData(0, null);
    }

    static title = "connect points";
    static desc = "adds indices between near points";
}
LiteGraph.registerNodeType("geometry/connectPoints", LGraphConnectPoints);


// Works with Litegl.js to create WebGL nodes
if (typeof GL != "undefined") {

    class LGraphToGeometry {
        constructor() {
            this.addInput("mesh", "mesh");
            this.addOutput("out", "geometry");

            this.geometry = {};
            this.last_mesh = null;
        }

        onExecute() {
            var mesh = this.getInputData(0);
            if (!mesh) return;

            if (mesh != this.last_mesh) {
                this.last_mesh = mesh;
                for (i in mesh.vertexBuffers) {
                    var buffer = mesh.vertexBuffers[i];
                    this.geometry[i] = buffer.data;
                }
                if (mesh.indexBuffers["triangles"])
                    this.geometry.indices = mesh.indexBuffers["triangles"].data;

                this.geometry._id = generateGeometryId();
                this.geometry._version = 0;
            }

            this.setOutputData(0, this.geometry);
            if (this.geometry) this.setOutputData(1, this.geometry.vertices);
        }

        static title = "to geometry";
        static desc = "converts a mesh to geometry";
    }
    LiteGraph.registerNodeType("geometry/toGeometry", LGraphToGeometry);


    class LGraphGeometryToMesh {
        constructor() {
            this.addInput("in", "geometry");
            this.addOutput("mesh", "mesh");
            this.properties = {};
            this.version = -1;
            this.mesh = null;
        }

        updateMesh(geometry) {
            if (!this.mesh) this.mesh = new GL.Mesh();

            for (let i in geometry) {
                if (i[0] == "_") continue;

                var buffer_data = geometry[i];

                var info = GL.Mesh.common_buffers[i];
                if (!info && i != "indices")
                    // unknown buffer
                    continue;
                var spacing = info ? info.spacing : 3;
                var mesh_buffer = this.mesh.vertexBuffers[i];

                if (!mesh_buffer || mesh_buffer.data.length != buffer_data.length) {
                    mesh_buffer = new GL.Buffer(
                        i == "indices" ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,
                        buffer_data,
                        spacing,
                        GL.DYNAMIC_DRAW,
                    );
                } else {
                    mesh_buffer.data.set(buffer_data);
                    mesh_buffer.upload(GL.DYNAMIC_DRAW);
                }

                this.mesh.addBuffer(i, mesh_buffer);
            }

            if (
                this.mesh.vertexBuffers.normals &&
                this.mesh.vertexBuffers.normals.data.length !=
                    this.mesh.vertexBuffers.vertices.data.length
            ) {
                var n = new Float32Array([0, 1, 0]);
                var normals = new Float32Array(this.mesh.vertexBuffers.vertices.data.length);
                for (let i = 0; i < normals.length; i += 3) normals.set(n, i);
                mesh_buffer = new GL.Buffer(GL.ARRAY_BUFFER, normals, 3);
                this.mesh.addBuffer("normals", mesh_buffer);
            }

            this.mesh.updateBoundingBox();
            this.geometry_id = this.mesh.id = geometry._id;
            this.version = this.mesh.version = geometry._version;
            return this.mesh;
        }

        onExecute() {
            var geometry = this.getInputData(0);
            if (!geometry) return;
            if (
                this.version != geometry._version ||
                this.geometry_id != geometry._id
            )
                this.updateMesh(geometry);
            this.setOutputData(0, this.mesh);
        }
        static title = "Geo to Mesh";
    }
    LiteGraph.registerNodeType("geometry/toMesh", LGraphGeometryToMesh);


    class LGraphRenderMesh {
        constructor() {
            this.addInput("mesh", "mesh");
            this.addInput("mat4", "mat4");
            this.addInput("tex", "texture");

            this.properties = {
                enabled: true,
                primitive: GL.TRIANGLES,
                additive: false,
                color: [1, 1, 1],
                opacity: 1,
            };

            this.color = vec4.create([1, 1, 1, 1]);
            this.model_matrix = mat4.create();
            this.uniforms = {
                u_color: this.color,
                u_model: this.model_matrix,
            };
        }

        onExecute() {
            if (!this.properties.enabled) return;

            var mesh = this.getInputData(0);
            if (!mesh) return;

            if (!LGraphRender.onRequestCameraMatrices) {
                console.warn?.("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
                return;
            }

            LGraphRender.onRequestCameraMatrices(
                view_matrix,
                projection_matrix,
                viewprojection_matrix,
            );
            var shader = null;
            var texture = this.getInputData(2);
            if (texture) {
                shader = gl.shaders["textured"];
                if (!shader)
                    shader = gl.shaders["textured"] = new GL.Shader(
                        LGraphRenderPoints.vertex_shader_code,
                        LGraphRenderPoints.fragment_shader_code,
                        { USE_TEXTURE: "" },
                    );
            } else {
                shader = gl.shaders["flat"];
                if (!shader)
                    shader = gl.shaders["flat"] = new GL.Shader(
                        LGraphRenderPoints.vertex_shader_code,
                        LGraphRenderPoints.fragment_shader_code,
                    );
            }

            this.color.set(this.properties.color);
            this.color[3] = this.properties.opacity;

            var model_matrix = this.model_matrix;
            var m = this.getInputData(1);
            if (m) model_matrix.set(m);
            else mat4.identity(model_matrix);

            this.uniforms.u_point_size = 1;
            var primitive = this.properties.primitive;

            shader.uniforms(global_uniforms);
            shader.uniforms(this.uniforms);

            if (this.properties.opacity >= 1) gl.disable(gl.BLEND);
            else gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            if (this.properties.additive) {
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                gl.depthMask(false);
            } else gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            var indices = "indices";
            if (mesh.indexBuffers.triangles) indices = "triangles";
            shader.draw(mesh, primitive, indices);
            gl.disable(gl.BLEND);
            gl.depthMask(true);
        }

        static title = "Render Mesh";
        static desc = "renders a mesh flat";

        static PRIMITIVE_VALUES = {
            points: GL.POINTS,
            lines: GL.LINES,
            line_loop: GL.LINE_LOOP,
            line_strip: GL.LINE_STRIP,
            triangles: GL.TRIANGLES,
            triangle_fan: GL.TRIANGLE_FAN,
            triangle_strip: GL.TRIANGLE_STRIP,
        };

        static widgets_info = {
            primitive: {
                widget: "combo",
                values: LGraphRenderMesh.PRIMITIVE_VALUES,
            },
            color: { widget: "color" },
        };
    }
    LiteGraph.registerNodeType("geometry/render_mesh", LGraphRenderMesh);


    class LGraphGeometryPrimitive {
        constructor() {
            this.addInput("size", "number");
            this.addOutput("out", "mesh");
            this.properties = { type: 1, size: 1, subdivisions: 32 };

            this.version = (Math.random() * 100000) | 0;
            this.last_info = { type: -1, size: -1, subdivisions: -1 };
        }

        onExecute() {
            if (!this.isOutputConnected(0)) return;

            var size = this.getInputOrProperty("size");

            // update
            if (
                this.last_info.type != this.properties.type ||
                this.last_info.size != size ||
                this.last_info.subdivisions != this.properties.subdivisions
            )
                this.updateMesh(
                    this.properties.type,
                    size,
                    this.properties.subdivisions,
                );

            this.setOutputData(0, this._mesh);
        }

        updateMesh(type, size, subdivisions) {
            subdivisions = Math.max(0, subdivisions) | 0;

            switch (type) {
                case 1: // CUBE:
                    this._mesh = GL.Mesh.cube({
                        size: size,
                        normals: true,
                        coords: true,
                    });
                    break;
                case 2: // PLANE:
                    this._mesh = GL.Mesh.plane({
                        size: size,
                        xz: true,
                        detail: subdivisions,
                        normals: true,
                        coords: true,
                    });
                    break;
                case 3: // CYLINDER:
                    this._mesh = GL.Mesh.cylinder({
                        size: size,
                        subdivisions: subdivisions,
                        normals: true,
                        coords: true,
                    });
                    break;
                case 4: // SPHERE:
                    this._mesh = GL.Mesh.sphere({
                        size: size,
                        long: subdivisions,
                        lat: subdivisions,
                        normals: true,
                        coords: true,
                    });
                    break;
                case 5: // CIRCLE:
                    this._mesh = GL.Mesh.circle({
                        size: size,
                        slices: subdivisions,
                        normals: true,
                        coords: true,
                    });
                    break;
                case 6: // HEMISPHERE:
                    this._mesh = GL.Mesh.sphere({
                        size: size,
                        long: subdivisions,
                        lat: subdivisions,
                        normals: true,
                        coords: true,
                        hemi: true,
                    });
                    break;
                case 7: // ICOSAHEDRON:
                    this._mesh = GL.Mesh.icosahedron({
                        size: size,
                        subdivisions: subdivisions,
                    });
                    break;
                case 8: // CONE:
                    this._mesh = GL.Mesh.cone({
                        radius: size,
                        height: size,
                        subdivisions: subdivisions,
                    });
                    break;
                case 9: // QUAD:
                    this._mesh = GL.Mesh.plane({
                        size: size,
                        xz: false,
                        detail: subdivisions,
                        normals: true,
                        coords: true,
                    });
                    break;
            }

            this.last_info.type = type;
            this.last_info.size = size;
            this.last_info.subdivisions = subdivisions;
            this._mesh.version = this.version++;
        }

        static title = "Primitive";
        static VALID = {
            CUBE: 1,
            PLANE: 2,
            CYLINDER: 3,
            SPHERE: 4,
            CIRCLE: 5,
            HEMISPHERE: 6,
            ICOSAHEDRON: 7,
            CONE: 8,
            QUAD: 9,
        };

        static widgets_info = {
            type: {
                widget: "combo",
                values: LGraphGeometryPrimitive.VALID,
            },
        };
    }
    LiteGraph.registerNodeType("geometry/mesh_primitive", LGraphGeometryPrimitive);


    class LGraphRenderPoints {
        constructor() {
            this.addInput("in", "geometry");
            this.addInput("mat4", "mat4");
            this.addInput("tex", "texture");
            this.properties = {
                enabled: true,
                point_size: 0.1,
                fixed_size: false,
                additive: true,
                color: [1, 1, 1],
                opacity: 1,
            };

            this.color = vec4.create([1, 1, 1, 1]);

            this.uniforms = {
                u_point_size: 1,
                u_perspective: 1,
                u_point_perspective: 1,
                u_color: this.color,
            };

            this.geometry_id = -1;
            this.version = -1;
            this.mesh = null;
        }

        updateMesh(geometry) {
            if (
                !this.buffer ||
                !this.buffer.data ||
                this.buffer.data.length != geometry.vertices.length
            )
                this.buffer = new GL.Buffer(
                    GL.ARRAY_BUFFER,
                    geometry.vertices,
                    3,
                    GL.DYNAMIC_DRAW,
                );
            else {
                this.buffer.data.set(geometry.vertices);
                this.buffer.upload(GL.DYNAMIC_DRAW);
            }

            if (!this.mesh) this.mesh = new GL.Mesh();

            this.mesh.addBuffer("vertices", this.buffer);
            this.geometry_id = this.mesh.id = geometry._id;
            this.version = this.mesh.version = geometry._version;
        }

        onExecute() {
            if (!this.properties.enabled) return;

            var geometry = this.getInputData(0);
            if (!geometry) return;
            if (
                this.version != geometry._version ||
                this.geometry_id != geometry._id
            )
                this.updateMesh(geometry);

            if (!LGraphRender.onRequestCameraMatrices) {
                console.warn?.("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
                return;
            }

            LGraphRender.onRequestCameraMatrices(
                view_matrix,
                projection_matrix,
                viewprojection_matrix,
            );
            var shader = null;

            var texture = this.getInputData(2);

            if (texture) {
                shader = gl.shaders["textured_points"];
                if (!shader)
                    shader = gl.shaders["textured_points"] = new GL.Shader(
                        LGraphRenderPoints.vertex_shader_code,
                        LGraphRenderPoints.fragment_shader_code,
                        { USE_TEXTURED_POINTS: "" },
                    );
            } else {
                shader = gl.shaders["points"];
                if (!shader)
                    shader = gl.shaders["points"] = new GL.Shader(
                        LGraphRenderPoints.vertex_shader_code,
                        LGraphRenderPoints.fragment_shader_code,
                        { USE_POINTS: "" },
                    );
            }

            this.color.set(this.properties.color);
            this.color[3] = this.properties.opacity;

            var m = this.getInputData(1);
            if (m) model_matrix.set(m);
            else mat4.identity(model_matrix);

            this.uniforms.u_point_size = this.properties.point_size;
            this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
            this.uniforms.u_perspective =
                gl.viewport_data[3] * projection_matrix[5];

            shader.uniforms(global_uniforms);
            shader.uniforms(this.uniforms);

            if (this.properties.opacity >= 1) gl.disable(gl.BLEND);
            else gl.enable(gl.BLEND);

            gl.enable(gl.DEPTH_TEST);
            if (this.properties.additive) {
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                gl.depthMask(false);
            } else gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            shader.draw(this.mesh, GL.POINTS);

            gl.disable(gl.BLEND);
            gl.depthMask(true);
        }

        static title = "renderPoints";
        static desc = "render points with a texture";
        static widgets_info = { color: { widget: "color" } };

        static vertex_shader_code = `
            precision mediump float;
            attribute vec3 a_vertex;
            varying vec3 v_vertex;
            attribute vec3 a_normal;
            varying vec3 v_normal;
            #ifdef USE_COLOR
                attribute vec4 a_color;
                varying vec4 v_color;
            #endif
            attribute vec2 a_coord;
            varying vec2 v_coord;
            #ifdef USE_SIZE
                attribute float a_extra;
            #endif
            #ifdef USE_INSTANCING
                attribute mat4 u_model;
            #else
                uniform mat4 u_model;
            #endif
            uniform mat4 u_viewprojection;
            uniform float u_point_size;
            uniform float u_perspective;
            uniform float u_point_perspective;
            float computePointSize(float radius, float w)
            {
                if(radius < 0.0)
                    return -radius;
                return u_perspective * radius / w;
            }
            void main() {
                v_coord = a_coord;
                #ifdef USE_COLOR
                    v_color = a_color;
                #endif
                v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;
                v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;
                gl_Position = u_viewprojection * vec4(v_vertex,1.0);
                gl_PointSize = u_point_size;
                #ifdef USE_SIZE
                    gl_PointSize = a_extra;
                #endif
                if(u_point_perspective != 0.0)
                    gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );
            }
        `;

        static fragment_shader_code = `
            precision mediump float;
            uniform vec4 u_color;
            #ifdef USE_COLOR
                varying vec4 v_color;
            #endif
            varying vec2 v_coord;
            uniform sampler2D u_texture;
            void main() {
                vec4 color = u_color;
                #ifdef USE_TEXTURED_POINTS
                    color *= texture2D(u_texture, gl_PointCoord.xy);
                #else
                    #ifdef USE_TEXTURE
                        color *= texture2D(u_texture, v_coord);
                        if(color.a < 0.1)
                            discard;
                    #endif
                    #ifdef USE_POINTS
                        float dist = length( gl_PointCoord.xy - vec2(0.5) );
                        if( dist > 0.45 )
                            discard;
                    #endif
                #endif
                #ifdef USE_COLOR
                    color *= v_color;
                #endif
                gl_FragColor = color;
            }
        `;
    }
    LiteGraph.registerNodeType("geometry/render_points", LGraphRenderPoints);


    // based on https://inconvergent.net/2019/depth-of-field/
    /*
	function LGraphRenderGeometryDOF() {
		this.addInput("in", "geometry");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");
		this.properties = {
			enabled: true,
			lines: true,
			point_size: 0.1,
			fixed_size: false,
			additive: true,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);

		this.uniforms = {
			u_point_size: 1,
			u_perspective: 1,
			u_point_perspective: 1,
			u_color: this.color
		};

		this.geometry_id = -1;
		this.version = -1;
		this.mesh = null;
	}

	LGraphRenderGeometryDOF.widgets_info = {
		color: { widget: "color" }
	};

	LGraphRenderGeometryDOF.prototype.updateMesh = function(geometry)
	{
		var buffer = this.buffer;
		if(!this.buffer || this.buffer.data.length != geometry.vertices.length)
			this.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);
		else
		{
			this.buffer.data.set( geometry.vertices );
			this.buffer.upload(GL.DYNAMIC_DRAW);
		}

		if(!this.mesh)
			this.mesh = new GL.Mesh();

		this.mesh.addBuffer("vertices",this.buffer);
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
	}

	LGraphRenderGeometryDOF.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if(this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );

		if(!LGraphRender.onRequestCameraMatrices)
		{
			console.warn?.("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;

		var texture = this.getInputData(2);

		if(texture)
		{
			shader = gl.shaders["textured_points"];
			if(!shader)
				shader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_TEXTURED_POINTS:"" });
		}
		else
		{
			shader = gl.shaders["points"];
			if(!shader)
				shader = gl.shaders["points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_POINTS: "" });
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = this.properties.point_size;
		this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
		this.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );

		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		shader.draw( this.mesh, GL.POINTS );

		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_dof", LGraphRenderGeometryDOF );

	LGraphRenderGeometryDOF.vertex_shader_code = '\
		precision mediump float;\n\
		attribute vec3 a_vertex;\n\
		varying vec3 v_vertex;\n\
		attribute vec3 a_normal;\n\
		varying vec3 v_normal;\n\
		#ifdef USE_COLOR\n\
			attribute vec4 a_color;\n\
			varying vec4 v_color;\n\
		#endif\n\
		attribute vec2 a_coord;\n\
		varying vec2 v_coord;\n\
		#ifdef USE_SIZE\n\
			attribute float a_extra;\n\
		#endif\n\
		#ifdef USE_INSTANCING\n\
			attribute mat4 u_model;\n\
		#else\n\
			uniform mat4 u_model;\n\
		#endif\n\
		uniform mat4 u_viewprojection;\n\
		uniform float u_point_size;\n\
		uniform float u_perspective;\n\
		uniform float u_point_perspective;\n\
		float computePointSize(float radius, float w)\n\
		{\n\
			if(radius < 0.0)\n\
				return -radius;\n\
			return u_perspective * radius / w;\n\
		}\n\
		void main() {\n\
			v_coord = a_coord;\n\
			#ifdef USE_COLOR\n\
				v_color = a_color;\n\
			#endif\n\
			v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\
			v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\
			gl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\
			gl_PointSize = u_point_size;\n\
			#ifdef USE_SIZE\n\
				gl_PointSize = a_extra;\n\
			#endif\n\
			if(u_point_perspective != 0.0)\n\
				gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\
		}\
	';

	LGraphRenderGeometryDOF.fragment_shader_code = '\
		precision mediump float;\n\
		uniform vec4 u_color;\n\
		#ifdef USE_COLOR\n\
			varying vec4 v_color;\n\
		#endif\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		void main() {\n\
			vec4 color = u_color;\n\
			#ifdef USE_TEXTURED_POINTS\n\
				color *= texture2D(u_texture, gl_PointCoord.xy);\n\
			#else\n\
				#ifdef USE_TEXTURE\n\
				  color *= texture2D(u_texture, v_coord);\n\
				  if(color.a < 0.1)\n\
					discard;\n\
				#endif\n\
				#ifdef USE_POINTS\n\
					float dist = length( gl_PointCoord.xy - vec2(0.5) );\n\
					if( dist > 0.45 )\n\
						discard;\n\
				#endif\n\
			#endif\n\
			#ifdef USE_COLOR\n\
				color *= v_color;\n\
			#endif\n\
			gl_FragColor = color;\n\
		}\
	';
	*/
}


// Works with Litegl.js to create WebGL nodes

// Texture Lens
class LGraphFXLens {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("Aberration", "number");
        this.addInput("Distortion", "number");
        this.addInput("Blur", "number");
        this.addOutput("Texture", "Texture");
        this.properties = {
            aberration: 1.0,
            distortion: 1.0,
            blur: 1.0,
            precision: LGraphTexture.DEFAULT,
        };

        if (!LGraphFXLens._shader) {
            LGraphFXLens._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphFXLens.pixel_shader,
            );
            LGraphFXLens._texture = new GL.Texture(3, 1, {
                format: gl.RGB,
                wrap: gl.CLAMP_TO_EDGE,
                magFilter: gl.LINEAR,
                minFilter: gl.LINEAR,
                pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255],
            });
        }
    }

    static title = "Lens";
    static desc = "Camera Lens distortion";
    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        var tex = this.getInputData(0);
        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        var aberration = this.properties.aberration;
        if (this.isInputConnected(1)) {
            aberration = this.getInputData(1);
            this.properties.aberration = aberration;
        }

        var distortion = this.properties.distortion;
        if (this.isInputConnected(2)) {
            distortion = this.getInputData(2);
            this.properties.distortion = distortion;
        }

        var blur = this.properties.blur;
        if (this.isInputConnected(3)) {
            blur = this.getInputData(3);
            this.properties.blur = blur;
        }

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var mesh = Mesh.getScreenQuad();
        var shader = LGraphFXLens._shader;
        // var camera = LS.Renderer._current_camera;

        this._tex.drawTo(function () {
            tex.bind(0);
            shader
                .uniforms({
                    u_texture: 0,
                    u_aberration: aberration,
                    u_distortion: distortion,
                    u_blur: blur,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform float u_aberration;
        uniform float u_distortion;
        uniform float u_blur;
        
        void main() {
            vec2 coord = v_coord;
            float dist = distance(vec2(0.5), coord);
            vec2 dist_coord = coord - vec2(0.5);
            float percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;
            dist_coord *= percent;
            coord = dist_coord + vec2(0.5);
            vec4 color = texture2D(u_texture, coord, u_blur * dist);
            color.r = texture2D(u_texture, vec2(0.5) + dist_coord * (1.0 + 0.01 * u_aberration), u_blur * dist).r;
            color.b = texture2D(u_texture, vec2(0.5) + dist_coord * (1.0 - 0.01 * u_aberration), u_blur * dist).b;
            gl_FragColor = color;
        }
    `;

/*
    float normalized_tunable_sigmoid(float xs, float k)\n\
    {\n\
        xs = xs * 2.0 - 1.0;\n\
        float signx = sign(xs);\n\
        float absx = abs(xs);\n\
        return signx * ((-k - 1.0)*absx)/(2.0*(-2.0*k*absx+k-1.0)) + 0.5;\n\
    }\n\
*/
}
LiteGraph.registerNodeType("fx/lens", LGraphFXLens);

/* not working yet
function LGraphDepthOfField()
{
this.addInput("Color","Texture");
this.addInput("Linear Depth","Texture");
this.addInput("Camera","camera");
this.addOutput("Texture","Texture");
this.properties = { high_precision: false };
}

LGraphDepthOfField.title = "Depth Of Field";
LGraphDepthOfField.desc = "Applies a depth of field effect";

LGraphDepthOfField.prototype.onExecute = function()
{
var tex = this.getInputData(0);
var depth = this.getInputData(1);
var camera = this.getInputData(2);

if(!tex || !depth || !camera)
{
    this.setOutputData(0, tex);
    return;
}

var precision = gl.UNSIGNED_BYTE;
if(this.properties.high_precision)
    precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
if(!this._temp_texture || this._temp_texture.type != precision ||
    this._temp_texture.width != tex.width || this._temp_texture.height != tex.height)
    this._temp_texture = new GL.Texture( tex.width, tex.height, { type: precision, format: gl.RGBA, filter: gl.LINEAR });

var shader = LGraphDepthOfField._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphDepthOfField._pixel_shader );

var screen_mesh = Mesh.getScreenQuad();

gl.disable( gl.DEPTH_TEST );
gl.disable( gl.BLEND );

var camera_position = camera.getEye();
var focus_point = camera.getCenter();
var distance = vec3.distance( camera_position, focus_point );
var far = camera.far;
var focus_range = distance * 0.5;

this._temp_texture.drawTo( function() {
    tex.bind(0);
    depth.bind(1);
    shader.uniforms({u_texture:0, u_depth_texture:1, u_resolution: [1/tex.width, 1/tex.height], u_far: far, u_focus_point: distance, u_focus_scale: focus_range }).draw(screen_mesh);
});

this.setOutputData(0, this._temp_texture);
}

//from http://tuxedolabs.blogspot.com.es/2018/05/bokeh-depth-of-field-in-single-pass.html
LGraphDepthOfField._pixel_shader = "\n\
precision highp float;\n\
varying vec2 v_coord;\n\
uniform sampler2D u_texture; //Image to be processed\n\
uniform sampler2D u_depth_texture; //Linear depth, where 1.0 == far plane\n\
uniform vec2 u_iresolution; //The size of a pixel: vec2(1.0/width, 1.0/height)\n\
uniform float u_far; // Far plane\n\
uniform float u_focus_point;\n\
uniform float u_focus_scale;\n\
\n\
const float GOLDEN_ANGLE = 2.39996323;\n\
const float MAX_BLUR_SIZE = 20.0;\n\
const float RAD_SCALE = 0.5; // Smaller = nicer blur, larger = faster\n\
\n\
float getBlurSize(float depth, float focusPoint, float focusScale)\n\
{\n\
    float coc = LiteGraph.clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\
    return abs(coc) * MAX_BLUR_SIZE;\n\
}\n\
\n\
vec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n\
{\n\
    float centerDepth = texture2D(u_depth_texture, texCoord).r * u_far;\n\
    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n\
    vec3 color = texture2D(u_texture, v_coord).rgb;\n\
    float tot = 1.0;\n\
\n\
    float radius = RAD_SCALE;\n\
    for (float ang = 0.0; ang < 100.0; ang += GOLDEN_ANGLE)\n\
    {\n\
    vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * u_iresolution * radius;\n\
    \n\
    vec3 sampleColor = texture2D(u_texture, tc).rgb;\n\
    float sampleDepth = texture2D(u_depth_texture, tc).r * u_far;\n\
    float sampleSize = getBlurSize( sampleDepth, focusPoint, focusScale );\n\
    if (sampleDepth > centerDepth)\n\
    sampleSize = LiteGraph.clamp(sampleSize, 0.0, centerSize*2.0);\n\
    \n\
    float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n\
    color += mix(color/tot, sampleColor, m);\n\
    tot += 1.0;\n\
    radius += RAD_SCALE/radius;\n\
    if(radius>=MAX_BLUR_SIZE)\n\
        return color / tot;\n\
    }\n\
    return color / tot;\n\
}\n\
void main()\n\
{\n\
    gl_FragColor = vec4( depthOfField( v_coord, u_focus_point, u_focus_scale ), 1.0 );\n\
    //gl_FragColor = vec4( texture2D(u_depth_texture, v_coord).r );\n\
}\n\
";

LiteGraph.registerNodeType("fx/DOF", LGraphDepthOfField );
*/

//* ******************************************************

class LGraphFXBokeh {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("Blurred", "Texture");
        this.addInput("Mask", "Texture");
        this.addInput("Threshold", "number");
        this.addOutput("Texture", "Texture");
        this.properties = {
            shape: "",
            size: 10,
            alpha: 1.0,
            threshold: 1.0,
            high_precision: false,
        };
    }

    static title = "Bokeh";
    static desc = "applies an Bokeh effect";
    static widgets_info = { shape: { widget: "texture" } };

    onExecute() {
        var tex = this.getInputData(0);
        var blurred_tex = this.getInputData(1);
        var mask_tex = this.getInputData(2);
        if (!tex || !mask_tex || !this.properties.shape) {
            this.setOutputData(0, tex);
            return;
        }

        if (!blurred_tex) {
            blurred_tex = tex;
        }

        var shape_tex = LGraphTexture.getTexture(this.properties.shape);
        if (!shape_tex) {
            return;
        }

        var threshold = this.properties.threshold;
        if (this.isInputConnected(3)) {
            threshold = this.getInputData(3);
            this.properties.threshold = threshold;
        }

        var precision = gl.UNSIGNED_BYTE;
        if (this.properties.high_precision) {
            precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
        }
        if (
            !this._temp_texture ||
            this._temp_texture.type != precision ||
            this._temp_texture.width != tex.width ||
            this._temp_texture.height != tex.height
        ) {
            this._temp_texture = new GL.Texture(tex.width, tex.height, {
                type: precision,
                format: gl.RGBA,
                filter: gl.LINEAR,
            });
        }

        var first_shader = LGraphFXBokeh._first_shader;
        if (!first_shader) {
            first_shader = LGraphFXBokeh._first_shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphFXBokeh._first_pixel_shader,
            );
        }

        var second_shader = LGraphFXBokeh._second_shader;
        if (!second_shader) {
            second_shader = LGraphFXBokeh._second_shader = new GL.Shader(
                LGraphFXBokeh._second_vertex_shader,
                LGraphFXBokeh._second_pixel_shader,
            );
        }

        var points_mesh = this._points_mesh;
        if (
            !points_mesh ||
            points_mesh._width != tex.width ||
            points_mesh._height != tex.height ||
            points_mesh._spacing != 2
        ) {
            points_mesh = this.createPointsMesh(tex.width, tex.height, 2);
        }

        var screen_mesh = Mesh.getScreenQuad();

        var point_size = this.properties.size;
        var alpha = this.properties.alpha;

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        this._temp_texture.drawTo(function () {
            tex.bind(0);
            blurred_tex.bind(1);
            mask_tex.bind(2);
            first_shader
                .uniforms({
                    u_texture: 0,
                    u_texture_blur: 1,
                    u_mask: 2,
                    u_texsize: [tex.width, tex.height],
                })
                .draw(screen_mesh);
        });

        this._temp_texture.drawTo(function () {
            // clear because we use blending
            // gl.clearColor(0.0,0.0,0.0,1.0);
            // gl.clear( gl.COLOR_BUFFER_BIT );
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);

            tex.bind(0);
            shape_tex.bind(3);
            second_shader
                .uniforms({
                    u_texture: 0,
                    u_mask: 2,
                    u_shape: 3,
                    u_alpha: alpha,
                    u_threshold: threshold,
                    u_pointSize: point_size,
                    u_itexsize: [1.0 / tex.width, 1.0 / tex.height],
                })
                .draw(points_mesh, gl.POINTS);
        });

        this.setOutputData(0, this._temp_texture);
    }

    createPointsMesh(width, height, spacing) {
        var nwidth = Math.round(width / spacing);
        var nheight = Math.round(height / spacing);

        var vertices = new Float32Array(nwidth * nheight * 2);

        var ny = -1;
        var dx = (2 / width) * spacing;
        var dy = (2 / height) * spacing;
        for (var y = 0; y < nheight; ++y) {
            var nx = -1;
            for (var x = 0; x < nwidth; ++x) {
                var pos = y * nwidth * 2 + x * 2;
                vertices[pos] = nx;
                vertices[pos + 1] = ny;
                nx += dx;
            }
            ny += dy;
        }

        this._points_mesh = GL.Mesh.load({ vertices2D: vertices });
        this._points_mesh._width = width;
        this._points_mesh._height = height;
        this._points_mesh._spacing = spacing;

        return this._points_mesh;
    }

    /*
    LGraphTextureBokeh._pixel_shader = "precision highp float;\n\
            varying vec2 a_coord;\n\
            uniform sampler2D u_texture;\n\
            uniform sampler2D u_shape;\n\
            \n\
            void main() {\n\
                vec4 color = texture2D( u_texture, gl_PointCoord );\n\
                color *= v_color * u_alpha;\n\
                gl_FragColor = color;\n\
            }\n";
    */

    static _first_pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_texture_blur;
        uniform sampler2D u_mask;

        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            vec4 blurred_color = texture2D(u_texture_blur, v_coord);
            float mask = texture2D(u_mask, v_coord).x;
            gl_FragColor = mix(color, blurred_color, mask);
        }
    `;


    static _second_vertex_shader = `
        precision highp float;
        attribute vec2 a_vertex2D;
        varying vec4 v_color;
        uniform sampler2D u_texture;
        uniform sampler2D u_mask;
        uniform vec2 u_itexsize;
        uniform float u_pointSize;
        uniform float u_threshold;
        
        void main() {
            vec2 coord = a_vertex2D * 0.5 + 0.5;
            v_color = texture2D(u_texture, coord);
            v_color += texture2D(u_texture, coord + vec2(u_itexsize.x, 0.0));
            v_color += texture2D(u_texture, coord + vec2(0.0, u_itexsize.y));
            v_color += texture2D(u_texture, coord + u_itexsize);
            v_color *= 0.25;
            float mask = texture2D(u_mask, coord).x;
            float luminance = length(v_color) * mask;
            // luminance /= (u_pointSize * u_pointSize) * 0.01;
            luminance -= u_threshold;
            if (luminance < 0.0) {
                gl_Position.x = -100.0;
                return;
            }
            gl_PointSize = u_pointSize;
            gl_Position = vec4(a_vertex2D, 0.0, 1.0);
        }
    `;


    static _second_pixel_shader = `
        precision highp float;
        varying vec4 v_color;
        uniform sampler2D u_shape;
        uniform float u_alpha;
        
        void main() {
            vec4 color = texture2D(u_shape, gl_PointCoord);
            color *= v_color * u_alpha;
            gl_FragColor = color;
        }
    `;
}
LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);


class LGraphFXGeneric {
    constructor() {
        this.addInput("Texture", "Texture");
        this.addInput("value1", "number");
        this.addInput("value2", "number");
        this.addOutput("Texture", "Texture");
        this.properties = {
            fx: "halftone",
            value1: 1,
            value2: 1,
            precision: LGraphTexture.DEFAULT,
        };
    }

    static title = "FX";
    static desc = "applies an FX from a list";
    static widgets_info = {
        fx: {
            widget: "combo",
            values: ["halftone", "pixelate", "lowpalette", "noise", "gamma"],
        },
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    static shaders = {};

    onExecute() {
        if (!this.isOutputConnected(0)) {
            return;
        } // saves work

        var tex = this.getInputData(0);
        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        // iterations
        var value1 = this.properties.value1;
        if (this.isInputConnected(1)) {
            value1 = this.getInputData(1);
            this.properties.value1 = value1;
        }

        var value2 = this.properties.value2;
        if (this.isInputConnected(2)) {
            value2 = this.getInputData(2);
            this.properties.value2 = value2;
        }

        var fx = this.properties.fx;
        var shader = LGraphFXGeneric.shaders[fx];
        if (!shader) {
            var pixel_shader_code = LGraphFXGeneric["pixel_shader_" + fx];
            if (!pixel_shader_code) {
                return;
            }

            shader = LGraphFXGeneric.shaders[fx] = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                pixel_shader_code,
            );
        }

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var mesh = Mesh.getScreenQuad();
        var camera = LS ? LS.Renderer._current_camera : null;
        var camera_planes;
        if (camera) {
            camera_planes = [
                LS.Renderer._current_camera.near,
                LS.Renderer._current_camera.far,
            ];
        } else {
            camera_planes = [1, 100];
        }

        var noise = null;
        if (fx == "noise") {
            noise = LGraphTexture.getNoiseTexture();
        }

        this._tex.drawTo(function () {
            tex.bind(0);
            if (fx == "noise") {
                noise.bind(1);
            }

            shader
                .uniforms({
                    u_texture: 0,
                    u_noise: 1,
                    u_size: [tex.width, tex.height],
                    u_rand: [Math.random(), Math.random()],
                    u_value1: value1,
                    u_value2: value2,
                    u_camera_planes: camera_planes,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader_halftone = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        float pattern() {
            float s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);
            vec2 tex = v_coord * u_size.xy;
            vec2 point = vec2(
                c * tex.x - s * tex.y ,
                s * tex.x + c * tex.y
            ) * u_value2;
            return (sin(point.x) * sin(point.y)) * 4.0;
        }
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            float average = (color.r + color.g + color.b) / 3.0;
            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);
        }
    `;

    static pixel_shader_pixelate = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        void main() {
            vec2 coord = vec2(floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2);
            vec4 color = texture2D(u_texture, coord);
            gl_FragColor = color;
        }
    `;

    static pixel_shader_lowpalette = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            gl_FragColor = floor(color * u_value1) / u_value1;
        }
    `;

    static pixel_shader_noise = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_noise;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        uniform vec2 u_rand;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            vec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);
            gl_FragColor = vec4(color.xyz + noise * u_value1, color.a);
        }
    `;

    static pixel_shader_gamma = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_value1;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            float gamma = 1.0 / u_value1;
            gl_FragColor = vec4(pow(color.xyz, vec3(gamma)), color.a);
        }
    `;
}
LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);


class LGraphFXVigneting {
    constructor() {
        this.addInput("Tex.", "Texture");
        this.addInput("intensity", "number");

        this.addOutput("Texture", "Texture");
        this.properties = {
            intensity: 1,
            invert: false,
            precision: LGraphTexture.DEFAULT,
        };

        if (!LGraphFXVigneting._shader) {
            LGraphFXVigneting._shader = new GL.Shader(
                GL.Shader.SCREEN_VERTEX_SHADER,
                LGraphFXVigneting.pixel_shader,
            );
        }
    }

    static title = "Vigneting";
    static desc = "Vigneting";
    static widgets_info = {
        precision: {
            widget: "combo",
            values: LGraphTexture.MODE_VALUES,
        },
    };

    onExecute() {
        var tex = this.getInputData(0);

        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
            this.setOutputData(0, tex);
            return;
        }

        if (!tex) {
            return;
        }

        this._tex = LGraphTexture.getTargetTexture(
            tex,
            this._tex,
            this.properties.precision,
        );

        var intensity = this.properties.intensity;
        if (this.isInputConnected(1)) {
            intensity = this.getInputData(1);
            this.properties.intensity = intensity;
        }

        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        var mesh = Mesh.getScreenQuad();
        var shader = LGraphFXVigneting._shader;
        var invert = this.properties.invert;

        this._tex.drawTo(function () {
            tex.bind(0);
            shader
                .uniforms({
                    u_texture: 0,
                    u_intensity: intensity,
                    u_isize: [1 / tex.width, 1 / tex.height],
                    u_invert: invert ? 1 : 0,
                })
                .draw(mesh);
        });

        this.setOutputData(0, this._tex);
    }

    static pixel_shader = `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_intensity;
        uniform int u_invert;
        
        void main() {
            float luminance = 1.0 - length(v_coord - vec2(0.5)) * 1.414;
            vec4 color = texture2D(u_texture, v_coord);
            
            if (u_invert == 1) {
                luminance = 1.0 - luminance;
            }
            
            luminance = mix(1.0, luminance, u_intensity);
            gl_FragColor = vec4(luminance * color.xyz, color.a);
        }
    `;
}
LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);


var MIDI_COLOR = "#243";

class MIDIEvent {
    constructor(data) {
        this.channel = 0;
        this.cmd = 0;
        this.data = new Uint32Array(3);

        if (data) {
            this.setup(data);
        }
    }

    fromJSON(o) {
        this.setup(o.data);
    }

    setup(data) {
        var raw_data = data;
        if (data.constructor === Object) {
            raw_data = data.data;
        }

        this.data.set(raw_data);

        var midiStatus = raw_data[0];
        this.status = midiStatus;

        var midiCommand = midiStatus & 0xf0;

        if (midiStatus >= 0xf0) {
            this.cmd = midiStatus;
        } else {
            this.cmd = midiCommand;
        }

        if (this.cmd == MIDIEvent.NOTEON && this.velocity == 0) {
            this.cmd = MIDIEvent.NOTEOFF;
        }

        this.cmd_str = MIDIEvent.commands[this.cmd] || "";

        if (midiCommand >= MIDIEvent.NOTEON || midiCommand <= MIDIEvent.NOTEOFF) {
            this.channel = midiStatus & 0x0f;
        }
    }

    get velocity() {
        if (this.cmd == MIDIEvent.NOTEON) {
            return this.data[2];
        }
        return -1;
    }

    set velocity(v) {
        this.data[2] = v; //  v / 127;
    }

    get note() {
        if (this.cmd != MIDIEvent.NOTEON) {
            return -1;
        }
        return MIDIEvent.toNoteString(this.data[1], true);
    }

    set note(v) {
        throw new Error("notes cannot be assigned this way, must modify the data[1]");
    }

    get octave() {
        if (this.cmd != MIDIEvent.NOTEON) {
            return -1;
        }
        var octave = this.data[1] - 24;
        return Math.floor(octave / 12 + 1);
    }

    set octave(v) {
        throw new Error("octave cannot be assigned this way, must modify the data[1]");
    }

    // returns HZs
    getPitch() {
        return Math.pow(2, (this.data[1] - 69) / 12) * 440;
    }

    static computePitch(note) {
        return Math.pow(2, (note - 69) / 12) * 440;
    }

    getCC() {
        return this.data[1];
    }

    getCCValue() {
        return this.data[2];
    }

    // not tested, there is a formula missing here
    getPitchBend() {
        return this.data[1] + (this.data[2] << 7) - 8192;
    }

    static computePitchBend(v1, v2) {
        return v1 + (v2 << 7) - 8192;
    }

    setCommandFromString(str) {
        this.cmd = MIDIEvent.computeCommandFromString(str);
    }

    static computeCommandFromString(str) {
        if (!str) {
            return 0;
        }

        if (str && str.constructor === Number) {
            return str;
        }

        str = str.toUpperCase();
        switch (str) {
            case "NOTE ON":
            case "NOTEON":
                return MIDIEvent.NOTEON;
            case "NOTE OFF":
            case "NOTEOFF":
                return MIDIEvent.NOTEON;
            case "KEY PRESSURE":
            case "KEYPRESSURE":
                return MIDIEvent.KEYPRESSURE;
            case "CONTROLLER CHANGE":
            case "CONTROLLERCHANGE":
            case "CC":
                return MIDIEvent.CONTROLLERCHANGE;
            case "PROGRAM CHANGE":
            case "PROGRAMCHANGE":
            case "PC":
                return MIDIEvent.PROGRAMCHANGE;
            case "CHANNEL PRESSURE":
            case "CHANNELPRESSURE":
                return MIDIEvent.CHANNELPRESSURE;
            case "PITCH BEND":
            case "PITCHBEND":
                return MIDIEvent.PITCHBEND;
            case "TIME TICK":
            case "TIMETICK":
                return MIDIEvent.TIMETICK;
            default:
                return Number(str); // assume its a hex code
        }
    }

    // transform from a pitch number to string like "C4"
    static toNoteString(d, skip_octave) {
        d = Math.round(d); // in case it has decimals
        var note = d - 21;
        var octave = Math.floor((d - 24) / 12 + 1);
        note = note % 12;
        if (note < 0) {
            note = 12 + note;
        }
        return MIDIEvent.notes[note] + (skip_octave ? "" : octave);
    }

    static NoteStringToPitch(str) {
        str = str.toUpperCase();
        var note = str[0];
        var octave = 4;

        if (str[1] == "#") {
            note += "#";
            if (str.length > 2) {
                octave = Number(str[2]);
            }
        } else {
            if (str.length > 1) {
                octave = Number(str[1]);
            }
        }
        var pitch = MIDIEvent.note_to_index[note];
        if (pitch == null) {
            return null;
        }
        return (octave - 1) * 12 + pitch + 21;
    }

    toString() {
        var str = "" + this.channel + ". ";
        switch (this.cmd) {
            case MIDIEvent.NOTEON:
                str += "NOTEON " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.NOTEOFF:
                str += "NOTEOFF " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                str += "CC " + this.data[1] + " " + this.data[2];
                break;
            case MIDIEvent.PROGRAMCHANGE:
                str += "PC " + this.data[1];
                break;
            case MIDIEvent.PITCHBEND:
                str += "PITCHBEND " + this.getPitchBend();
                break;
            case MIDIEvent.KEYPRESSURE:
                str += "KEYPRESS " + this.data[1];
                break;
        }

        return str;
    }

    toHexString() {
        return this.data.map((byte) => byte.toString(16)).join(' ');
    }

    toJSON() {
        return {
            data: [this.data[0], this.data[1], this.data[2]],
            object_class: "MIDIEvent",
        };
    }

    static notes = [
        "A",
        "A#",
        "B",
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
    ];

    static note_to_index = {
        A: 0,
        "A#": 1,
        B: 2,
        C: 3,
        "C#": 4,
        D: 5,
        "D#": 6,
        E: 7,
        F: 8,
        "F#": 9,
        G: 10,
        "G#": 11,
    };

    static commands = {
        0x80: "note off",
        0x90: "note on",
        0xa0: "key pressure",
        0xb0: "controller change",
        0xc0: "program change",
        0xd0: "channel pressure",
        0xe0: "pitch bend",
        0xf0: "system",
        0xf2: "Song pos",
        0xf3: "Song select",
        0xf6: "Tune request",
        0xf8: "time tick",
        0xfa: "Start Song",
        0xfb: "Continue Song",
        0xfc: "Stop Song",
        0xfe: "Sensing",
        0xff: "Reset",
    };

    static commands_short = {
        0x80: "NOTEOFF",
        0x90: "NOTEOFF",
        0xa0: "KEYP",
        0xb0: "CC",
        0xc0: "PC",
        0xd0: "CP",
        0xe0: "PB",
        0xf0: "SYS",
        0xf2: "POS",
        0xf3: "SELECT",
        0xf6: "TUNEREQ",
        0xf8: "TT",
        0xfa: "START",
        0xfb: "CONTINUE",
        0xfc: "STOP",
        0xfe: "SENS",
        0xff: "RESET",
    };

    static commands_reversed = {};
}
// @TODO: Enum
MIDIEvent.NOTEOFF = 0x80;
MIDIEvent.NOTEON = 0x90;
MIDIEvent.KEYPRESSURE = 0xa0;
MIDIEvent.CONTROLLERCHANGE = 0xb0;
MIDIEvent.PROGRAMCHANGE = 0xc0;
MIDIEvent.CHANNELPRESSURE = 0xd0;
MIDIEvent.PITCHBEND = 0xe0;
MIDIEvent.TIMETICK = 0xf8;

LiteGraph.MIDIEvent = MIDIEvent;
for (var i in MIDIEvent.commands) {
    MIDIEvent.commands_reversed[MIDIEvent.commands[i]] = i;
}

// MIDI wrapper, instantiate by MIDIIn and MIDIOut
class MIDIInterface {
    constructor(on_ready, on_error) {
        if (!navigator.requestMIDIAccess) {
            this.error = "not suppoorted";
            if (on_error) {
                on_error("Not supported");
            } else {
                console.error?.("MIDI NOT SUPPORTED, enable by chrome://flags");
            }
            return;
        }

        this.on_ready = on_ready;

        this.state = {
            note: [],
            cc: [],
        };

        this.input_ports = null;
        this.input_ports_info = [];
        this.output_ports = null;
        this.output_ports_info = [];

        navigator
            .requestMIDIAccess()
            .then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));
    }

    onMIDISuccess(midiAccess) {
        console.log?.("MIDI ready!");
        if(LiteGraph.debug)
            console.log?.(midiAccess);
        this.midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
        this.updatePorts();

        if (this.on_ready) {
            this.on_ready(this);
        }
    }

    updatePorts() {
        var midi = this.midi;
        this.input_ports = midi.inputs;
        this.input_ports_info = [];
        this.output_ports = midi.outputs;
        this.output_ports_info = [];

        var num = 0;

        var it = this.input_ports.values();
        var it_value = it.next();
        while (it_value && it_value.done === false) {
            let port_info = it_value.value;
            this.input_ports_info.push(port_info);
            if(LiteGraph.debug)
                console.log?.("Input port [type:'" +
                    port_info.type +
                    "'] id:'" +
                    port_info.id +
                    "' manufacturer:'" +
                    port_info.manufacturer +
                    "' name:'" +
                    port_info.name +
                    "' version:'" +
                    port_info.version +
                    "'");
            num++;
            it_value = it.next();
        }
        this.num_input_ports = num;

        num = 0;
        it = this.output_ports.values();
        it_value = it.next();
        while (it_value && it_value.done === false) {
            let port_info = it_value.value;
            this.output_ports_info.push(port_info);
            if(LiteGraph.debug)
                console.log?.("Output port [type:'" +
                    port_info.type +
                    "'] id:'" +
                    port_info.id +
                    "' manufacturer:'" +
                    port_info.manufacturer +
                    "' name:'" +
                    port_info.name +
                    "' version:'" +
                    port_info.version +
                    "'");
            num++;
            it_value = it.next();
        }
        this.num_output_ports = num;
    }

    onMIDIFailure(msg) {
        console.error?.("Failed to get MIDI access - " + msg);
    }

    openInputPort(port, callback) {
        var input_port = this.input_ports.get("input-" + port);
        if (!input_port) {
            return false;
        }
        MIDIInterface.input = this;
        var that = this;

        input_port.onmidimessage = function (a) {
            var midi_event = new MIDIEvent(a.data);
            that.updateState(midi_event);
            if (callback) {
                callback(a.data, midi_event);
            }
            if (MIDIInterface.on_message) {
                MIDIInterface.on_message(a.data, midi_event);
            }
        };
        console.log?.("port open: ", input_port);
        return true;
    }

    updateState(midi_event) {
        switch (midi_event.cmd) {
            case MIDIEvent.NOTEON:
                this.state.note[midi_event.value1 | 0] = midi_event.value2;
                break;
            case MIDIEvent.NOTEOFF:
                this.state.note[midi_event.value1 | 0] = 0;
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                this.state.cc[midi_event.getCC()] = midi_event.getCCValue();
                break;
        }
    }

    sendMIDI(port, midi_data) {
        if (!midi_data) {
            return;
        }

        var output_port = this.output_ports_info[port]; // this.output_ports.get("output-" + port);
        if (!output_port) {
            return;
        }

        MIDIInterface.output = this;

        if (midi_data.constructor === MIDIEvent) {
            output_port.send(midi_data.data);
        } else {
            output_port.send(midi_data);
        }
    }

    static input = null;
}
MIDIInterface.MIDIEvent = MIDIEvent;


class LGMIDIIn {

    static title = "MIDI Input";
    static desc = "Reads MIDI from a input port";

    constructor() {
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.addOutput("out", "midi");
        this.properties = { port: 0 };
        this._last_midi_event = null;
        this._current_midi_event = null;
        this.boxcolor = "#AAA";
        this._last_time = 0;

        var that = this;
        new MIDIInterface(function (midi) {
            // open
            that._midi = midi;
            if (that._waiting) {
                that.onStart();
            }
            that._waiting = false;
        });
    }

    getPropertyInfo(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
            var values = {};
            for (var i = 0; i < this._midi.input_ports_info.length; ++i) {
                var input = this._midi.input_ports_info[i];
                values[i] = i + ".- " + input.name + " version:" + input.version;
            }
            return { type: "enum", values: values };
        }
    }

    onStart() {
        if (this._midi) {
            this._midi.openInputPort(
                this.properties.port,
                this.onMIDIEvent.bind(this),
            );
        } else {
            this._waiting = true;
        }
    }

    onMIDIEvent(data, midi_event) {
        this._last_midi_event = midi_event;
        this.boxcolor = "#AFA";
        this._last_time = LiteGraph.getTime();
        this.trigger("on_midi", midi_event);
        if (midi_event.cmd == MIDIEvent.NOTEON) {
            this.trigger("on_noteon", midi_event);
        } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
            this.trigger("on_noteoff", midi_event);
        } else if (midi_event.cmd == MIDIEvent.CONTROLLERCHANGE) {
            this.trigger("on_cc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PROGRAMCHANGE) {
            this.trigger("on_pc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PITCHBEND) {
            this.trigger("on_pitchbend", midi_event);
        }
    }

    onDrawBackground(ctx) {
        this.boxcolor = "#AAA";
        if (!this.flags.collapsed && this._last_midi_event) {
            ctx.fillStyle = "white";
            var now = LiteGraph.getTime();
            var f = 1.0 - Math.max(0, (now - this._last_time) * 0.001);
            if (f > 0) {
                var t = ctx.globalAlpha;
                ctx.globalAlpha *= f;
                ctx.font = "12px Tahoma";
                ctx.fillText(
                    this._last_midi_event.toString(),
                    2,
                    this.size[1] * 0.5 + 3,
                );
                // ctx.fillRect(0,0,this.size[0],this.size[1]);
                ctx.globalAlpha = t;
            }
        }
    }

    onExecute() {
        if (this.outputs) {
            var last = this._last_midi_event;
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                var v = null;
                switch (output.name) {
                    case "midi":
                        v = this._midi;
                        break;
                    case "last_midi":
                        v = last;
                        break;
                    default:
                        continue;
                }
                this.setOutputData(i, v);
            }
        }
    }

    onGetOutputs() {
        return [
            ["last_midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["on_noteon", LiteGraph.EVENT],
            ["on_noteoff", LiteGraph.EVENT],
            ["on_cc", LiteGraph.EVENT],
            ["on_pc", LiteGraph.EVENT],
            ["on_pitchbend", LiteGraph.EVENT],
        ];
    }

    static color = MIDI_COLOR;
}
LGMIDIIn.MIDIInterface = MIDIInterface;
LiteGraph.registerNodeType("midi/input", LGMIDIIn);


class LGMIDIOut {

    static title = "MIDI Output";
    static desc = "Sends MIDI to output channel";

    constructor() {
        this.addInput("send", LiteGraph.EVENT);
        this.properties = { port: 0 };

        var that = this;
        new MIDIInterface(function (midi) {
            that._midi = midi;
            that.widget.options.values = that.getMIDIOutputs();
        });
        this.widget = this.addWidget("combo", "Device", this.properties.port, {
            property: "port",
            values: this.getMIDIOutputs.bind(this),
        });
        this.size = [340, 60];
    }

    onGetPropertyInfo(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
            var values = this.getMIDIOutputs();
            return { type: "enum", values: values };
        }
    }

    getMIDIOutputs() {
        var values = {};
        if (!this._midi) return LGMIDIOut.default_ports;
        if (this._midi.output_ports_info)
            for (var i = 0; i < this._midi.output_ports_info.length; ++i) {
                var output = this._midi.output_ports_info[i];
                if (!output) continue;
                var name = i + ".- " + output.name + " version:" + output.version;
                values[i] = name;
            }
        return values;
    }

    onAction(event, midi_event) {
        // console.log?.(midi_event);
        if (!this._midi) {
            return;
        }
        if (event == "send") {
            this._midi.sendMIDI(this.properties.port, midi_event);
        }
        this.trigger("midi", midi_event);
    }

    onGetInputs() {
        return [["send", LiteGraph.ACTION]];
    }

    onGetOutputs() {
        return [["on_midi", LiteGraph.EVENT]];
    }

    static color = MIDI_COLOR;
    static default_ports = { 0: "unknown" };
}
LGMIDIOut.MIDIInterface = MIDIInterface;
LiteGraph.registerNodeType("midi/output", LGMIDIOut);


class LGMIDIShow {

    static title = "MIDI Show";
    static desc = "Shows MIDI in the graph";

    constructor() {
        this.addInput("on_midi", LiteGraph.EVENT);
        this._str = "";
        this.size = [200, 40];
    }

    getTitle() {
        if (this.flags.collapsed) {
            return this._str;
        }
        return this.title;
    }

    onAction(event, midi_event) {
        if (!midi_event) {
            return;
        }
        if (midi_event.constructor === MIDIEvent) {
            this._str = midi_event.toString();
        } else {
            this._str = "???";
        }
    }

    onDrawForeground(ctx) {
        if (!this._str || this.flags.collapsed) {
            return;
        }

        ctx.font = "30px Arial";
        ctx.fillText(this._str, 10, this.size[1] * 0.8);
    }

    onGetInputs() {
        return [["in", LiteGraph.ACTION]];
    }

    onGetOutputs() {
        return [["on_midi", LiteGraph.EVENT]];
    }

    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/show", LGMIDIShow);


class LGMIDIFilter {

    static title = "MIDI Filter";
    static desc = "Filters MIDI messages";

    constructor() {
        this.properties = {
            channel: -1,
            cmd: -1,
            min_value: -1,
            max_value: -1,
        };

        var that = this;
        this._learning = false;
        this.addWidget("button", "Learn", "", function () {
            that._learning = true;
            that.boxcolor = "#FA3";
        });

        this.addInput("in", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.boxcolor = "#AAA";
    }

    getTitle() {
        var str = null;
        if (this.properties.cmd == -1) {
            str = "Nothing";
        } else {
            str = MIDIEvent.commands_short[this.properties.cmd] || "Unknown";
        }

        if (this.properties.min_value != -1 && this.properties.max_value != -1) {
            str +=
                " " +
                (this.properties.min_value == this.properties.max_value
                    ? this.properties.max_value
                    : this.properties.min_value + ".." + this.properties.max_value);
        }

        return "Filter: " + str;
    }

    onPropertyChanged(name, value) {
        if (name == "cmd") {
            var num = Number(value);
            if (isNaN(num)) {
                num = MIDIEvent.commands[value] || 0;
            }
            this.properties.cmd = num;
        }
    }

    onAction(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this._learning) {
            this._learning = false;
            this.boxcolor = "#AAA";
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.min_value = this.properties.max_value =
                midi_event.data[1];
        } else {
            if (
                this.properties.channel != -1 &&
                midi_event.channel != this.properties.channel
            ) {
                return;
            }
            if (
                this.properties.cmd != -1 &&
                midi_event.cmd != this.properties.cmd
            ) {
                return;
            }
            if (
                this.properties.min_value != -1 &&
                midi_event.data[1] < this.properties.min_value
            ) {
                return;
            }
            if (
                this.properties.max_value != -1 &&
                midi_event.data[1] > this.properties.max_value
            ) {
                return;
            }
        }

        this.trigger("on_midi", midi_event);
    }
    static color = MIDI_COLOR;
    static "@cmd" = {
        type: "enum",
        title: "Command",
        values: MIDIEvent.commands_reversed,
    };
}
LiteGraph.registerNodeType("midi/filter", LGMIDIFilter);


class LGMIDIEvent {

    static title = "MIDIEvent";
    static desc = "Create a MIDI Event";

    constructor() {
        this.properties = {
            channel: 0,
            cmd: 144, // 0x90
            value1: 1,
            value2: 1,
        };

        this.addInput("send", LiteGraph.EVENT);
        this.addInput("assign", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
        this.gate = false;
    }

    onAction(event, midi_event) {
        if (event == "assign") {
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.value1 = midi_event.data[1];
            this.properties.value2 = midi_event.data[2];
            if (midi_event.cmd == MIDIEvent.NOTEON) {
                this.gate = true;
            } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
                this.gate = false;
            }
            return;
        }

        // send
        midi_event = this.midi_event;
        midi_event.channel = this.properties.channel;
        if (this.properties.cmd && this.properties.cmd.constructor === String) {
            midi_event.setCommandFromString(this.properties.cmd);
        } else {
            midi_event.cmd = this.properties.cmd;
        }
        midi_event.data[0] = midi_event.cmd | midi_event.channel;
        midi_event.data[1] = Number(this.properties.value1);
        midi_event.data[2] = Number(this.properties.value2);

        this.trigger("on_midi", midi_event);
    }

    onExecute() {
        var props = this.properties;

        if (this.inputs) {
            for (let i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == -1) {
                    continue;
                }
                let v;
                switch (input.name) {
                    case "note":
                        v = this.getInputData(i);
                        if (v != null) {
                            if (v.constructor === String) {
                                v = MIDIEvent.NoteStringToPitch(v);
                            }
                            this.properties.value1 = (v | 0) % 255;
                        }
                        break;
                    case "cmd":
                        v = this.getInputData(i);
                        if (v != null) {
                            this.properties.cmd = v;
                        }
                        break;
                    case "value1":
                        v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value1 = LiteGraph.clamp(v | 0, 0, 127);
                        }
                        break;
                    case "value2":
                        v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value2 = LiteGraph.clamp(v | 0, 0, 127);
                        }
                        break;
                }
            }
        }

        if (this.outputs) {
            for (let i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                let v = null;
                switch (output.name) {
                    case "midi":
                        v = new MIDIEvent();
                        v.setup([props.cmd, props.value1, props.value2]);
                        v.channel = props.channel;
                        break;
                    case "command":
                        v = props.cmd;
                        break;
                    case "cc":
                        v = props.value1;
                        break;
                    case "cc_value":
                        v = props.value2;
                        break;
                    case "note":
                        v =
                            props.cmd == MIDIEvent.NOTEON ||
                            props.cmd == MIDIEvent.NOTEOFF
                                ? props.value1
                                : null;
                        break;
                    case "velocity":
                        v = props.cmd == MIDIEvent.NOTEON ? props.value2 : null;
                        break;
                    case "pitch":
                        v =
                            props.cmd == MIDIEvent.NOTEON
                                ? MIDIEvent.computePitch(props.value1)
                                : null;
                        break;
                    case "pitchbend":
                        v =
                            props.cmd == MIDIEvent.PITCHBEND
                                ? MIDIEvent.computePitchBend(
                                    props.value1,
                                    props.value2,
                                )
                                : null;
                        break;
                    case "gate":
                        v = this.gate;
                        break;
                    default:
                        continue;
                }
                if (v !== null) {
                    this.setOutputData(i, v);
                }
            }
        }
    }

    onPropertyChanged(name, value) {
        if (name == "cmd") {
            this.properties.cmd = MIDIEvent.computeCommandFromString(value);
        }
    }

    onGetInputs() {
        return [
            ["cmd", "number"],
            ["note", "number"],
            ["value1", "number"],
            ["value2", "number"],
        ];
    }

    onGetOutputs() {
        return [
            ["midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["command", "number"],
            ["note", "number"],
            ["velocity", "number"],
            ["cc", "number"],
            ["cc_value", "number"],
            ["pitch", "number"],
            ["gate", "bool"],
            ["pitchbend", "number"],
        ];
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/event", LGMIDIEvent);


class LGMIDICC {

    static title = "MIDICC";
    static desc = "gets a Controller Change";

    constructor() {
        this.properties = {
            //		channel: 0,
            cc: 1,
            value: 0,
        };

        this.addOutput("value", "number");
    }

    onExecute() {
        if (MIDIInterface.input) {
            this.properties.value =
                MIDIInterface.input.state.cc[this.properties.cc];
        }
        this.setOutputData(0, this.properties.value);
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/cc", LGMIDICC);


class LGMIDIGenerator {

    static title = "MIDI Generator";
    static desc = "Generates a random MIDI note";

    constructor() {
        this.addInput("generate", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addInput("octave", "number");
        this.addOutput("note", LiteGraph.EVENT);
        this.properties = {
            notes: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#",
            octave: 2,
            duration: 0.5,
            mode: "sequence",
        };

        this.notes_pitches = LGMIDIGenerator.processScale(this.properties.notes);
        this.sequence_index = 0;
    }

    static processScale(scale) {
        var notes = scale.split(",");
        for (var i = 0; i < notes.length; ++i) {
            var n = notes[i];
            if ((n.length == 2 && n[1] != "#") || n.length > 2) {
                notes[i] = -LiteGraph.MIDIEvent.NoteStringToPitch(n);
            } else {
                notes[i] = MIDIEvent.note_to_index[n] || 0;
            }
        }
        return notes;
    }

    onPropertyChanged(name, value) {
        if (name == "notes") {
            this.notes_pitches = LGMIDIGenerator.processScale(value);
        }
    }

    onExecute() {
        var octave = this.getInputData(2);
        if (octave != null) {
            this.properties.octave = octave;
        }

        var scale = this.getInputData(1);
        if (scale) {
            this.notes_pitches = LGMIDIGenerator.processScale(scale);
        }
    }

    onAction(event, midi_event) {
        // var range = this.properties.max - this.properties.min;
        // var pitch = this.properties.min + ((Math.random() * range)|0);
        var pitch = 0;
        var range = this.notes_pitches.length;
        var index = 0;

        if (this.properties.mode == "sequence") {
            index = this.sequence_index = (this.sequence_index + 1) % range;
        } else if (this.properties.mode == "random") {
            index = Math.floor(Math.random() * range);
        }

        var note = this.notes_pitches[index];
        if (note >= 0) {
            pitch = note + (this.properties.octave - 1) * 12 + 33;
        } else {
            pitch = -note;
        }

        midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 10]);
        var duration = this.properties.duration || 1;
        this.trigger("note", midi_event);

        // noteoff
        setTimeout(
            function () {
                var midi_event = new MIDIEvent();
                midi_event.setup([MIDIEvent.NOTEOFF, pitch, 0]);
                this.trigger("note", midi_event);
            }.bind(this),
            duration * 1000,
        );
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/generator", LGMIDIGenerator);


class LGMIDITranspose {

    static title = "MIDI Transpose";
    static desc = "Transpose a MIDI note";

    constructor() {
        this.properties = {amount: 0};
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("amount", "number");
        this.addOutput("out", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
    }

    onAction(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            this.midi_event.data[1] = Math.round(this.midi_event.data[1] + this.properties.amount);
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    }

    onExecute() {
        var amount = this.getInputData(1);
        if (amount != null) {
            this.properties.amount = amount;
        }
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/transpose", LGMIDITranspose);


class LGMIDIQuantize {

    static title = "MIDI Quantize Pitch";
    static desc = "Transpose a MIDI note tp fit an scale";

    constructor() {
        this.properties = {scale: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#"};
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addOutput("out", LiteGraph.EVENT);

        this.valid_notes = new Array(12);
        this.offset_notes = new Array(12);
        this.processScale(this.properties.scale);
    }

    onPropertyChanged(name, value) {
        if (name == "scale") {
            this.processScale(value);
        }
    }

    processScale(scale) {
        this._current_scale = scale;
        this.notes_pitches = LGMIDIGenerator.processScale(scale);
        for (let i = 0; i < 12; ++i) {
            this.valid_notes[i] = this.notes_pitches.indexOf(i) != -1;
        }
        for (let i = 0; i < 12; ++i) {
            if (this.valid_notes[i]) {
                this.offset_notes[i] = 0;
                continue;
            }
            for (var j = 1; j < 12; ++j) {
                if (this.valid_notes[(i - j) % 12]) {
                    this.offset_notes[i] = -j;
                    break;
                }
                if (this.valid_notes[(i + j) % 12]) {
                    this.offset_notes[i] = j;
                    break;
                }
            }
        }
    }

    onAction(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            var note = midi_event.note;
            var index = MIDIEvent.note_to_index[note];
            var offset = this.offset_notes[index];
            this.midi_event.data[1] += offset;
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    }

    onExecute() {
        var scale = this.getInputData(1);
        if (scale != null && scale != this._current_scale) {
            this.processScale(scale);
        }
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/quantize", LGMIDIQuantize);


class LGMIDIFromFile {

    static title = "MIDI fromFile";
    static desc = "Plays a MIDI file";

    constructor() {
        this.properties = {
            url: "",
            autoplay: true,
        };

        this.addInput("play", LiteGraph.ACTION);
        this.addInput("pause", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
        this._midi = null;
        this._current_time = 0;
        this._playing = false;

        if (typeof MidiParser == "undefined") {
            console.error?.("midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js");
            this.boxcolor = "red";
        }
    }

    onAction(name) {
        if (name == "play") this.play();
        else if (name == "pause") this._playing = !this._playing;
    }

    onPropertyChanged(name, value) {
        if (name == "url") this.loadMIDIFile(value);
    }

    onExecute() {
        if (!this._midi) return;

        if (!this._playing) return;

        this._current_time += this.graph.elapsed_time;
        var current_time = this._current_time * 100;

        for (var i = 0; i < this._midi.tracks; ++i) {
            var track = this._midi.track[i];
            if (!track._last_pos) {
                track._last_pos = 0;
                track._time = 0;
            }

            var elem = track.event[track._last_pos];
            if (elem && track._time + elem.deltaTime <= current_time) {
                track._last_pos++;
                track._time += elem.deltaTime;

                if (elem.data) {
                    var midi_cmd = elem.type << (4 + elem.channel);
                    var midi_event = new MIDIEvent();
                    midi_event.setup([midi_cmd, elem.data[0], elem.data[1]]);
                    this.trigger("note", midi_event);
                }
            }
        }
    }

    play() {
        this._playing = true;
        this._current_time = 0;
        if (!this._midi) return;

        for (var i = 0; i < this._midi.tracks; ++i) {
            var track = this._midi.track[i];
            track._last_pos = 0;
            track._time = 0;
        }
    }

    loadMIDIFile(url) {
        LiteGraph.fetchFile(
            url,
            "arraybuffer",
            (data) => {
                this.boxcolor = "#AFA";
                this._midi = MidiParser.parse(new Uint8Array(data));
                if (this.properties.autoplay)
                    this.play();
            },
            () => {
                this.boxcolor = "#FAA";
                this._midi = null;
            },
        );
    }

    onDropFile(file) {
        this.properties.url = "";
        this.loadMIDIFile(file);
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/fromFile", LGMIDIFromFile);


class LGMIDIPlay {

    static title = "MIDI Play";
    static desc = "Plays a MIDI note";

    constructor() {
        this.properties = {
            volume: 0.5,
            duration: 1,
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("volume", "number");
        this.addInput("duration", "number");
        this.addOutput("note", LiteGraph.EVENT);

        if (typeof AudioSynth == "undefined") {
            console.error?.("Audiosynth.js not included, LGMidiPlay requires that library");
            this.boxcolor = "red";
        } else {
            var Synth = (this.synth = new AudioSynth());
            this.instrument = Synth.createInstrument("piano");
        }
    }

    onAction(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this.instrument && midi_event.data[0] == MIDIEvent.NOTEON) {
            var note = midi_event.note; // C#
            if (!note || note == "undefined" || note.constructor !== String) {
                return;
            }
            this.instrument.play(
                note,
                midi_event.octave,
                this.properties.duration,
                this.properties.volume,
            );
        }
        this.trigger("note", midi_event);
    }

    onExecute() {
        var volume = this.getInputData(1);
        if (volume != null) {
            this.properties.volume = volume;
        }

        var duration = this.getInputData(2);
        if (duration != null) {
            this.properties.duration = duration;
        }
    }
    static color = MIDI_COLOR;
}
LiteGraph.registerNodeType("midi/play", LGMIDIPlay);


class LGMIDIKeys {

    static title = "MIDI Keys";
    static desc = "Keyboard to play notes";

    constructor() {
        this.properties = {
            num_octaves: 2,
            start_octave: 2,
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
        this.size = [400, 100];
        this.keys = [];
        this._last_key = -1;
    }

    onDrawForeground(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var num_keys = this.properties.num_octaves * 12;
        this.keys.length = num_keys;
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        ctx.globalAlpha = 1;

        for (
            var k = 0;
            k < 2;
            k++ // draw first whites (0) then blacks (1)
        ) {
            for (var i = 0; i < num_keys; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                if (k == 0) {
                    ctx.fillStyle = this.keys[i] ? "#CCC" : "white";
                } else {
                    ctx.fillStyle = this.keys[i] ? "#333" : "black";
                }
                ctx.fillRect(
                    x + 1,
                    0,
                    key_width * key_info.w - 2,
                    key_height * key_info.h,
                );
            }
        }
    }

    getKeyIndex(pos) {
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        for (
            var k = 1;
            k >= 0;
            k-- // test blacks first (1) then whites (0)
        ) {
            for (var i = 0; i < this.keys.length; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                var w = key_width * key_info.w;
                var h = key_height * key_info.h;
                if (pos[0] < x || pos[0] > x + w || pos[1] > h) {
                    continue;
                }
                return i;
            }
        }
        return -1;
    }

    onAction(event, params) {
        if (event == "reset") {
            for (var i = 0; i < this.keys.length; ++i) {
                this.keys[i] = false;
            }
            return;
        }

        if (!params || params.constructor !== MIDIEvent) {
            return;
        }
        var midi_event = params;
        var start_note = (this.properties.start_octave - 1) * 12 + 29;
        var index = midi_event.data[1] - start_note;
        if (index >= 0 && index < this.keys.length) {
            if (midi_event.data[0] == MIDIEvent.NOTEON) {
                this.keys[index] = true;
            } else if (midi_event.data[0] == MIDIEvent.NOTEOFF) {
                this.keys[index] = false;
            }
        }

        this.trigger("note", midi_event);
    }

    onMouseDown(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = true;
        this._last_key = index;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    }

    onMouseMove(e, pos) {
        if (pos[1] < 0 || this._last_key == -1) {
            return;
        }
        this.setDirtyCanvas(true);
        var index = this.getKeyIndex(pos);
        if (this._last_key == index) {
            return true;
        }
        this.keys[this._last_key] = false;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + this._last_key;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);

        this.keys[index] = true;
        pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);

        this._last_key = index;
        return true;
    }

    onMouseUp(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = false;
        this._last_key = -1;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    }
    static color = MIDI_COLOR;

    static keys = [
        { x: 0, w: 1, h: 1, t: 0 },
        { x: 0.75, w: 0.5, h: 0.6, t: 1 },
        { x: 1, w: 1, h: 1, t: 0 },
        { x: 1.75, w: 0.5, h: 0.6, t: 1 },
        { x: 2, w: 1, h: 1, t: 0 },
        { x: 2.75, w: 0.5, h: 0.6, t: 1 },
        { x: 3, w: 1, h: 1, t: 0 },
        { x: 4, w: 1, h: 1, t: 0 },
        { x: 4.75, w: 0.5, h: 0.6, t: 1 },
        { x: 5, w: 1, h: 1, t: 0 },
        { x: 5.75, w: 0.5, h: 0.6, t: 1 },
        { x: 6, w: 1, h: 1, t: 0 },
    ];
}
LiteGraph.registerNodeType("midi/keys", LGMIDIKeys);


class LGAudio {

    static audios_connected = {};

    static getAudioContext() {
        if (!this._audio_context) {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            console.debug("LGAudio","init _audio_context",window.AudioContext);
            if (!window.AudioContext) {
                console.error?.("AudioContext not supported by browser");
                return null;
            }
            try {
                this._audio_context = new AudioContext();
            }catch(e){
                console.error("LGAudio","_audio_context failed",this._audio_context);
                this._audio_context = false;
            }
            if(this._audio_context) {
                this._audio_context.onmessage = function (msg) {
                    console.log?.("msg", msg);
                };
                this._audio_context.onended = function (msg) {
                    console.log?.("ended", msg);
                };
                this._audio_context.oncomplete = function (msg) {
                    console.log?.("complete", msg);
                };
            }
        }

        // in case it crashes
        // if(this._audio_context.state == "suspended")
        //	this._audio_context.resume();
        return this._audio_context;
    }

    static connect(audionodeA, audionodeB) {
        try {
            audionodeA.connect(audionodeB);
            this.audios_connected[audionodeA] = audionodeB;
            console.debug("LGraphAudio:","audioNodesConnected", audionodeA, audionodeB);
        } catch (err) {
            console.warn?.("LGraphAudio:","connect", err);
        }
    }

    static disconnect(audionodeA, audionodeB) {
        try {
            if(this.audios_connected[audionodeA]){
                audionodeA.disconnect(audionodeB);
                this.audios_connected[audionodeA] = false;
                console.debug("LGraphAudio:","audioNodesDisconnected", audionodeA, audionodeB);
            }else{
                console.debug("LGraphAudio:","Not disconnecting unexisting connection",this.audios_connected, audionodeA, audionodeB);
            }
        } catch (err) {
            console.warn?.("LGraphAudio:","disconnect", err);
        }
    }

    static changeAllAudiosConnections(node, connect) {
        if (node.inputs) {
            for (let i = 0; i < node.inputs.length; ++i) {
                let input = node.inputs[i];
                let link_info = node.graph.links[input.link];
                if (!link_info) {
                    continue;
                }

                let origin_node = node.graph.getNodeById(link_info.origin_id);
                let origin_audionode = null;
                if (origin_node.getAudioNodeInOutputSlot) {
                    origin_audionode = origin_node.getAudioNodeInOutputSlot(link_info.origin_slot);
                } else {
                    origin_audionode = origin_node.audionode;
                }

                let target_audionode = null;
                if (node.getAudioNodeInInputSlot) {
                    target_audionode = node.getAudioNodeInInputSlot(i);
                } else {
                    target_audionode = node.audionode;
                }

                if (connect) {
                    LGAudio.connect(origin_audionode, target_audionode);
                } else {
                    LGAudio.disconnect(origin_audionode, target_audionode);
                }
            }
        }

        if (node.outputs) {
            for (let i = 0; i < node.outputs.length; ++i) {
                let output = node.outputs[i];
                for (let j = 0; j < output.links.length; ++j) {
                    let link_info = node.graph.links[output.links[j]];
                    if (!link_info) {
                        continue;
                    }

                    let origin_audionode = null;
                    if (node.getAudioNodeInOutputSlot) {
                        origin_audionode = node.getAudioNodeInOutputSlot(i);
                    } else {
                        origin_audionode = node.audionode;
                    }

                    let target_node = node.graph.getNodeById(link_info.target_id);
                    let target_audionode = null;
                    if (target_node.getAudioNodeInInputSlot) {
                        target_audionode = target_node.getAudioNodeInInputSlot(link_info.target_slot);
                    } else {
                        target_audionode = target_node.audionode;
                    }

                    if (connect) {
                        LGAudio.connect(origin_audionode, target_audionode);
                    } else {
                        LGAudio.disconnect(origin_audionode, target_audionode);
                    }
                }
            }
        }
    }


    // used by many nodes
    static onConnectionsChange(connection, slot, connected, link_info) {
        console.debug("LGAudio","onConnectionsChange",connection, slot, connected, link_info);

        // only process the outputs events
        if (connection != LiteGraph.OUTPUT) {
            console.warn("LGAudio","onConnectionsChange","skip cheking INPUT");
            return;
        }

        var target_node = null;
        if (link_info) {
            target_node = this.graph.getNodeById(link_info.target_id);
        }

        if (!target_node) {
            console.warn("LGAudio","onConnectionsChange","no target_node");
            return;
        }

        // get origin audionode
        var local_audionode = null;
        if (this.getAudioNodeInOutputSlot) {
            local_audionode = this.getAudioNodeInOutputSlot(slot);
        } else {
            local_audionode = this.audionode;
        }

        // get target audionode
        var target_audionode = null;
        if (target_node.getAudioNodeInInputSlot) {
            target_audionode = target_node.getAudioNodeInInputSlot(link_info.target_slot);
        } else {
            target_audionode = target_node.audionode;
        }

        // do the connection/disconnection
        if (connected) {
            LGAudio.connect(local_audionode, target_audionode);
            console.debug("LGAudio","onConnectionsChange","CONNECT");
        } else {
            LGAudio.disconnect(local_audionode, target_audionode);
            console.debug("LGAudio","onConnectionsChange","DISCONNECT");
        }
    }

    // this function helps creating wrappers to existing classes
    static createAudioNodeWrapper(class_object) {
        var old_func = class_object.prototype.onPropertyChanged;

        class_object.prototype.onPropertyChanged = function (name, value) {
            if (old_func) {
                old_func.call(this, name, value);
            }

            if (!this.audionode) {
                return;
            }

            if (this.audionode[name] === undefined) {
                return;
            }

            if (this.audionode[name].value !== undefined) {
                this.audionode[name].value = value;
            } else {
                this.audionode[name] = value;
            }
        };

        class_object.prototype.onConnectionsChange = LGAudio.onConnectionsChange;
        class_object.prototype.onConfigure = function(that){
            console.debug(that.type,that.id,"audio node configured");
        };
    }

    // contains the samples decoded of the loaded audios in AudioBuffer format
    static cached_audios = {};

    static loadSound(url, on_complete, on_error) {
        if (LGAudio.cached_audios[url] && url.includes("blob:")) {
            if (on_complete) {
                on_complete(LGAudio.cached_audios[url]);
            }
            return;
        }

        if (LGAudio.onProcessAudioURL) {
            url = LGAudio.onProcessAudioURL(url);
        }

        // load new sample
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";

        var context = LGAudio.getAudioContext();

        // Decode asynchronously
        request.onload = function () {
            console.log?.("AudioSource loaded");
            context.decodeAudioData(
                request.response,
                function (buffer) {
                    console.log?.("AudioSource decoded");
                    LGAudio.cached_audios[url] = buffer;
                    if (on_complete) {
                        on_complete(buffer);
                    }
                },
                onError,
            );
        };
        request.send();

        function onError(err) {
            console.log?.("Audio loading sample error:", err);
            if (on_error) {
                on_error(err);
            }
        }

        return request;
    }
}


class LGAudioSource {

    static title = "Source";
    static desc = "Plays an audio file";

    constructor() {
        this.properties = {
            src: "",
            gain: 0.5,
            loop: true,
            autoplay: true,
            playbackRate: 1,
        };

        this._loading_audio = false;
        this._audiobuffer = null; // points to AudioBuffer with the audio samples decoded
        this._audionodes = [];
        this._last_sourcenode = null; // the last AudioBufferSourceNode (there could be more if there are several sounds playing)

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        // init context
        var context = LGAudio.getAudioContext();

        // create gain node to control volume
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;

        // debug
        if (this.properties.src) {
            this.loadSound(this.properties.src);
        }
    }

    onAdded(graph) {
        if (graph.status === LiteGraph.LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    }

    onStart() {
        if (!this._audiobuffer) {
            return;
        }

        if (this.properties.autoplay) {
            this.playBuffer(this._audiobuffer);
        }
    }

    onStop() {
        this.stopAllSounds();
    }

    onPause() {
        this.pauseAllSounds();
    }

    onUnpause() {
        this.unpauseAllSounds();
        // this.onStart();
    }

    onRemoved() {
        this.stopAllSounds();
        if (this._dropped_url) {
            URL.revokeObjectURL(this._url);
        }
    }

    stopAllSounds() {
        // iterate and stop
        for (var i = 0; i < this._audionodes.length; ++i) {
            if (this._audionodes[i].started) {
                this._audionodes[i].started = false;
                this._audionodes[i].stop();
            }
            // this._audionodes[i].disconnect( this.audionode );
        }
        this._audionodes.length = 0;
    }

    pauseAllSounds() {
        LGAudio.getAudioContext().suspend();
    }

    unpauseAllSounds() {
        LGAudio.getAudioContext().resume();
    }

    onExecute() {
        if (this.inputs) {
            for (let i = 0; i < this.inputs.length; ++i) {
                let input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                let v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain") this.audionode.gain.value = v;
                else if (input.name == "src") {
                    this.setProperty("src", v);
                } else if (input.name == "playbackRate") {
                    this.properties.playbackRate = v;
                    for (let j = 0; j < this._audionodes.length; ++j) {
                        this._audionodes[j].playbackRate.value = v;
                    }
                }
            }
        }

        if (this.outputs) {
            for (let i = 0; i < this.outputs.length; ++i) {
                let output = this.outputs[i];
                if (output.name == "buffer" && this._audiobuffer) {
                    this.setOutputData(i, this._audiobuffer);
                }
            }
        }
    }

    onAction(event) {
        if (this._audiobuffer) {
            if (event == "Play") {
                this.playBuffer(this._audiobuffer);
            } else if (event == "Stop") {
                this.stopAllSounds();
            }
        }
    }

    onPropertyChanged(name, value) {
        if (name == "src") {
            this.loadSound(value);
        } else if (name == "gain") {
            this.audionode.gain.value = value;
        } else if (name == "playbackRate") {
            for (var j = 0; j < this._audionodes.length; ++j) {
                this._audionodes[j].playbackRate.value = value;
            }
        }
    }

    playBuffer(buffer) {
        var that = this;
        var context = LGAudio.getAudioContext();

        // create a new audionode (this is mandatory, AudioAPI doesnt like to reuse old ones)
        var audionode = context.createBufferSource(); // create a AudioBufferSourceNode
        this._last_sourcenode = audionode;
        audionode.graphnode = this;
        audionode.buffer = buffer;
        audionode.loop = this.properties.loop;
        audionode.playbackRate.value = this.properties.playbackRate;
        this._audionodes.push(audionode);
        audionode.connect(this.audionode); // connect to gain

        this._audionodes.push(audionode);

        this.trigger("start");

        audionode.onended = function () {
            // console.log?.("ended!");
            that.trigger("ended");
            // remove
            var index = that._audionodes.indexOf(audionode);
            if (index != -1) {
                that._audionodes.splice(index, 1);
            }
        };

        if (!audionode.started) {
            audionode.started = true;
            audionode.start();
        }
        return audionode;
    }

    loadSound(url) {
        var that = this;

        // kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._audiobuffer = null; // points to the audiobuffer once the audio is loaded
        this._loading_audio = false;

        if (!url) {
            return;
        }

        this._request = LGAudio.loadSound(url, (buffer) => {
            this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR;
            that._audiobuffer = buffer;
            that._loading_audio = false;
            // if is playing, then play it
            if (that.graph && that.graph.status === LiteGraph.LGraph.STATUS_RUNNING) {
                that.onStart();
            } // this controls the autoplay already
        });

        this._loading_audio = true;
        this.boxcolor = "#AA4";
    }

    onGetInputs() {
        return [
            ["playbackRate", "number"],
            ["src", "string"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION],
        ];
    }

    onGetOutputs() {
        return [
            ["buffer", "audiobuffer"],
            ["start", LiteGraph.EVENT],
            ["ended", LiteGraph.EVENT],
        ];
    }

    onDropFile(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        var url = URL.createObjectURL(file);
        this.properties.src = url;
        this.loadSound(url);
        this._dropped_url = url;
    }

    static supported_extensions = ["wav", "ogg", "mp3"];
    static "@src" = { widget: "resource" };
}
// Helps connect/disconnect AudioNodes when new connections are made in the node
LGAudioSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;
LiteGraph.registerNodeType("audio/source", LGAudioSource);

//* ***************************************************

class LGAudioMediaSource {

    static title = "MediaSource";
    static desc = "Plays microphone";

    constructor() {
        this.properties = { gain: 0.5 };

        this._audionodes = [];
        this._media_stream = null;

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        // create gain node to control volume
        var context = LGAudio.getAudioContext();
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;
    }

    onAdded(graph) {
        if (graph.status === LiteGraph.LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    }

    onStart() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }
    }

    onStop() {
        this.audionode.gain.value = 0;
    }

    onPause() {
        this.audionode.gain.value = 0;
    }

    onUnpause() {
        this.audionode.gain.value = this.properties.gain;
    }

    onRemoved() {
        this.audionode.gain.value = 0;
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
            this.audiosource_node = null;
        }
        if (this._media_stream) {
            var tracks = this._media_stream.getTracks();
            if (tracks.length) {
                tracks[0].stop();
            }
        }
    }

    openStream() {
        if (!navigator.mediaDevices) {
            console.log?.("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        navigator.mediaDevices
            .getUserMedia({ audio: true, video: false })
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(err) {
            console.log?.("Media rejected", err);
            that._media_stream = false;
            that.boxcolor = "red";
        }
    }

    streamReady(localMediaStream) {
        this._media_stream = localMediaStream;
        // this._waiting_confirmation = false;

        // init context
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
        }
        var context = LGAudio.getAudioContext();
        this.audiosource_node = context.createMediaStreamSource(localMediaStream);
        this.audiosource_node.graphnode = this;
        this.audiosource_node.connect(this.audionode);
        this.boxcolor = "white";
    }

    onExecute() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain") {
                    this.audionode.gain.value = this.properties.gain = v;
                }
            }
        }
    }

    onAction(event) {
        if (event == "Play") {
            this.audionode.gain.value = this.properties.gain;
        } else if (event == "Stop") {
            this.audionode.gain.value = 0;
        }
    }

    onPropertyChanged(name, value) {
        if (name == "gain") {
            this.audionode.gain.value = value;
        }
    }

    onGetInputs() {
        return [
            ["playbackRate", "number"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION],
        ];
    }
}
// Helps connect/disconnect AudioNodes when new connections are made in the node
LGAudioMediaSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;
LiteGraph.registerNodeType("audio/media_source", LGAudioMediaSource);


class LGAudioAnalyser {

    static title = "Analyser";
    static desc = "Audio Analyser";

    constructor() {
        this.properties = {
            fftSize: 2048,
            minDecibels: -100,
            maxDecibels: -10,
            smoothingTimeConstant: 0.5,
        };

        var context = LGAudio.getAudioContext();

        this.audionode = context.createAnalyser();
        this.audionode.graphnode = this;
        this.audionode.fftSize = this.properties.fftSize;
        this.audionode.minDecibels = this.properties.minDecibels;
        this.audionode.maxDecibels = this.properties.maxDecibels;
        this.audionode.smoothingTimeConstant =
            this.properties.smoothingTimeConstant;

        this.addInput("in", "audio");
        this.addOutput("freqs", "array");
        this.addOutput("samples", "array");

        this._freq_bin = null;
        this._time_bin = null;
    }

    onPropertyChanged(name, value) {
        this.audionode[name] = value;
    }

    onExecute() {
        let bufferLength;
        if (this.isOutputConnected(0)) {
            // send FFT
            bufferLength = this.audionode.frequencyBinCount;
            if (!this._freq_bin || this._freq_bin.length != bufferLength) {
                this._freq_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteFrequencyData(this._freq_bin);
            this.setOutputData(0, this._freq_bin);
        }

        // send analyzer
        if (this.isOutputConnected(1)) {
            // send Samples
            bufferLength = this.audionode.frequencyBinCount;
            if (!this._time_bin || this._time_bin.length != bufferLength) {
                this._time_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteTimeDomainData(this._time_bin);
            this.setOutputData(1, this._time_bin);
        }

        // properties
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }

        // time domain
        // this.audionode.getFloatTimeDomainData( dataArray );
    }

    onGetInputs() {
        return [
            ["minDecibels", "number"],
            ["maxDecibels", "number"],
            ["smoothingTimeConstant", "number"],
        ];
    }

    onGetOutputs() {
        return [
            ["freqs", "array"],
            ["samples", "array"],
        ];
    }
}
LiteGraph.registerNodeType("audio/analyser", LGAudioAnalyser);


class LGAudioGain {

    static title = "Gain";
    static desc = "Audio gain";

    constructor() {
        // default
        this.properties = { gain: 1 };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.addInput("in", "audio");
        this.addInput("gain", "number");
        this.addOutput("out", "audio");
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    }
}
LGAudio.createAudioNodeWrapper(LGAudioGain);
LiteGraph.registerNodeType("audio/gain", LGAudioGain);


class LGAudioConvolver {

    static title = "Convolver";
    static desc = "Convolves the signal (used for reverb)";

    constructor() {
        // default
        this.properties = {
            impulse_src: "",
            normalize: true,
        };

        this.audionode = LGAudio.getAudioContext().createConvolver();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    onRemove() {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
    }

    onPropertyChanged(name, value) {
        if (name == "impulse_src") {
            this.loadImpulse(value);
        } else if (name == "normalize") {
            this.audionode.normalize = value;
        }
    }

    onDropFile(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        this._dropped_url = URL.createObjectURL(file);
        this.properties.impulse_src = this._dropped_url;
        this.loadImpulse(this._dropped_url);
    }

    loadImpulse(url) {
        var that = this;

        // kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._impulse_buffer = null;
        this._loading_impulse = false;

        if (!url) {
            return;
        }

        // load new sample
        this._request = LGAudio.loadSound(url, inner);
        this._loading_impulse = true;

        // Decode asynchronously
        function inner(buffer) {
            that._impulse_buffer = buffer;
            that.audionode.buffer = buffer;
            console.log?.("Impulse signal set");
            that._loading_impulse = false;
        }
    }
}
LGAudio.createAudioNodeWrapper(LGAudioConvolver);
LiteGraph.registerNodeType("audio/convolver", LGAudioConvolver);


class LGAudioDynamicsCompressor {

    static title = "DynamicsCompressor";
    static desc = "Dynamics Compressor";

    constructor() {
        // default
        this.properties = {
            threshold: -50,
            knee: 40,
            ratio: 12,
            reduction: -20,
            attack: 0,
            release: 0.25,
        };

        this.audionode = LGAudio.getAudioContext().createDynamicsCompressor();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    }

    onGetInputs() {
        return [
            ["threshold", "number"],
            ["knee", "number"],
            ["ratio", "number"],
            ["reduction", "number"],
            ["attack", "number"],
            ["release", "number"],
        ];
    }
}
LGAudio.createAudioNodeWrapper(LGAudioDynamicsCompressor);
LiteGraph.registerNodeType("audio/dynamicsCompressor", LGAudioDynamicsCompressor);


class LGAudioWaveShaper {

    static title = "WaveShaper";
    static desc = "Distortion using wave shape";

    constructor() {
        // default
        this.properties = {};

        this.audionode = LGAudio.getAudioContext().createWaveShaper();
        this.addInput("in", "audio");
        this.addInput("shape", "waveshape");
        this.addOutput("out", "audio");
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        var v = this.getInputData(1);
        if (v === undefined) {
            return;
        }
        this.audionode.curve = v;
    }

    setWaveShape(shape) {
        this.audionode.curve = shape;
    }
}
LGAudio.createAudioNodeWrapper(LGAudioWaveShaper);
// disabled till I dont find a way to do a wave shape
// LiteGraph.registerNodeType("audio/waveShaper", LGAudioWaveShaper);


class LGAudioMixer {

    static title = "Mixer";
    static desc = "Audio mixer";

    constructor() {
        // default
        this.properties = {
            gain1: 0.5,
            gain2: 0.5,
        };

        this.audionode = LGAudio.getAudioContext().createGain();

        this.audionode1 = LGAudio.getAudioContext().createGain();
        this.audionode1.gain.value = this.properties.gain1;
        this.audionode2 = LGAudio.getAudioContext().createGain();
        this.audionode2.gain.value = this.properties.gain2;

        this.audionode1.connect(this.audionode);
        this.audionode2.connect(this.audionode);

        this.addInput("in1", "audio");
        this.addInput("in1 gain", "number");
        this.addInput("in2", "audio");
        this.addInput("in2 gain", "number");

        this.addOutput("out", "audio");
    }

    getAudioNodeInInputSlot(slot) {
        if (slot == 0) {
            return this.audionode1;
        } else if (slot == 2) {
            return this.audionode2;
        }
    }

    onPropertyChanged(name, value) {
        if (name == "gain1") {
            this.audionode1.gain.value = value;
        } else if (name == "gain2") {
            this.audionode2.gain.value = value;
        }
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];

            if (input.link == null || input.type == "audio") {
                continue;
            }

            var v = this.getInputData(i);
            if (v === undefined) {
                continue;
            }

            if (i == 1) {
                this.audionode1.gain.value = v;
            } else if (i == 3) {
                this.audionode2.gain.value = v;
            }
        }
    }
}
LGAudio.createAudioNodeWrapper(LGAudioMixer);
LiteGraph.registerNodeType("audio/mixer", LGAudioMixer);


class LGAudioADSR {

    static title = "ADSR";
    static desc = "Audio envelope";

    constructor() {
        // default
        this.properties = {
            A: 0.1,
            D: 0.1,
            S: 0.1,
            R: 0.1,
        };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.audionode.gain.value = 0;
        this.addInput("in", "audio");
        this.addInput("gate", "boolean");
        this.addOutput("out", "audio");
        this.gate = false;
    }

    onExecute() {
        var audioContext = LGAudio.getAudioContext();
        var now = audioContext.currentTime;
        var node = this.audionode;
        var gain = node.gain;
        var current_gate = this.getInputData(1);

        var A = this.getInputOrProperty("A");
        var D = this.getInputOrProperty("D");
        var S = this.getInputOrProperty("S");
        var R = this.getInputOrProperty("R");

        if (!this.gate && current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(0, now);
            gain.linearRampToValueAtTime(1, now + A);
            gain.linearRampToValueAtTime(S, now + A + D);
        } else if (this.gate && !current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(gain.value, now);
            gain.linearRampToValueAtTime(0, now + R);
        }

        this.gate = current_gate;
    }

    onGetInputs() {
        return [
            ["A", "number"],
            ["D", "number"],
            ["S", "number"],
            ["R", "number"],
        ];
    }
}
LGAudio.createAudioNodeWrapper(LGAudioADSR);
LiteGraph.registerNodeType("audio/adsr", LGAudioADSR);


class LGAudioDelay {

    static title = "Delay";
    static desc = "Audio delay";

    constructor() {
        // default
        this.properties = { delayTime: 0.5 };

        this.audionode = LGAudio.getAudioContext().createDelay(10);
        this.audionode.delayTime.value = this.properties.delayTime;
        this.addInput("in", "audio");
        this.addInput("time", "number");
        this.addOutput("out", "audio");
    }

    onExecute() {
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.audionode.delayTime.value = v;
        }
    }
}
LGAudio.createAudioNodeWrapper(LGAudioDelay);
LiteGraph.registerNodeType("audio/delay", LGAudioDelay);


class LGAudioBiquadFilter {

    static title = "BiquadFilter";
    static desc = "Audio filter";

    constructor() {
        // default
        this.properties = {
            frequency: 350,
            detune: 0,
            Q: 1,
        };
        this.addProperty("type", "lowpass", "enum", {
            values: [
                "lowpass",
                "highpass",
                "bandpass",
                "lowshelf",
                "highshelf",
                "peaking",
                "notch",
                "allpass",
            ],
        });

        // create node
        this.audionode = LGAudio.getAudioContext().createBiquadFilter();

        // slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    }

    onGetInputs() {
        return [
            ["frequency", "number"],
            ["detune", "number"],
            ["Q", "number"],
        ];
    }
}
LGAudio.createAudioNodeWrapper(LGAudioBiquadFilter);
LiteGraph.registerNodeType("audio/biquadfilter", LGAudioBiquadFilter);


class LGAudioOscillatorNode {

    static title = "Oscillator";
    static desc = "Oscillator";

    constructor() {
        // default
        this.properties = {
            frequency: 440,
            detune: 0,
            type: "sine",
        };
        this.addProperty(
            "type",
            "sine",
            "enum", {
                values: [
                    "sine",
                    "square",
                    "sawtooth",
                    "triangle",
                    "custom",
                ],
            },
        );

        // create node
        this.audionode = LGAudio.getAudioContext().createOscillator();

        // slots
        this.addOutput("out", "audio");
    }

    onStart() {
        if (!this.audionode.started) {
            this.audionode.started = true;
            try {
                this.audionode.start();
            } catch (error) {
                console.warn?.(error);
            }
        }
    }

    onStop() {
        if (this.audionode.started) {
            this.audionode.started = false;
            this.audionode.stop();
        }
    }

    onPause() {
        this.onStop();
    }

    onUnpause() {
        this.onStart();
    }

    onExecute() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 0; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    }

    onGetInputs() {
        return [
            ["frequency", "number"],
            ["detune", "number"],
            ["type", "string"],
        ];
    }
}
LGAudio.createAudioNodeWrapper(LGAudioOscillatorNode);
LiteGraph.registerNodeType("audio/oscillator", LGAudioOscillatorNode);


class LGAudioVisualization {

    static title = "Visualization";
    static desc = "Audio Visualization";

    constructor() {
        this.properties = {
            continuous: true,
            mark: -1,
        };

        this.addInput("data", "array");
        this.addInput("mark", "number");
        this.size = [300, 200];
        this._last_buffer = null;
    }

    onExecute() {
        this._last_buffer = this.getInputData(0);
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.properties.mark = v;
        }
        this.setDirtyCanvas(true, false);
    }

    onDrawForeground(ctx) {
        if (!this._last_buffer) {
            return;
        }

        var buffer = this._last_buffer;

        // delta represents how many samples we advance per pixel
        var delta = buffer.length / this.size[0];
        var h = this.size[1];

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, this.size[0], this.size[1]);
        ctx.strokeStyle = "white";
        ctx.beginPath();
        var x = 0;

        if (this.properties.continuous) {
            ctx.moveTo(x, h);
            for (let i = 0; i < buffer.length; i += delta) {
                ctx.lineTo(x, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        } else {
            for (let i = 0; i < buffer.length; i += delta) {
                ctx.moveTo(x + 0.5, h);
                ctx.lineTo(x + 0.5, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        }
        ctx.stroke();

        if (this.properties.mark >= 0) {
            var samplerate = LGAudio.getAudioContext().sampleRate;
            var binfreq = samplerate / buffer.length;
            x = (2 * (this.properties.mark / binfreq)) / delta;
            if (x >= this.size[0]) {
                x = this.size[0] - 1;
            }
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(x, h);
            ctx.lineTo(x, 0);
            ctx.stroke();
        }
    }
}
LiteGraph.registerNodeType("audio/visualization", LGAudioVisualization);


class LGAudioBandSignal {

    static title = "Signal";
    static desc = "extract the signal of some frequency";

    constructor() {
        // default
        this.properties = {
            band: 440,
            amplitude: 1,
        };

        this.addInput("freqs", "array");
        this.addOutput("signal", "number");
    }

    onExecute() {
        this._freqs = this.getInputData(0);
        if (!this._freqs) {
            return;
        }

        var band = this.properties.band;
        var v = this.getInputData(1);
        if (v !== undefined) {
            band = v;
        }

        var samplerate = LGAudio.getAudioContext().sampleRate;
        var binfreq = samplerate / this._freqs.length;
        var index = 2 * (band / binfreq);
        v = 0;
        if (index < 0) {
            v = this._freqs[0];
        }
        if (index >= this._freqs.length) {
            v = this._freqs[this._freqs.length - 1];
        } else {
            var pos = index | 0;
            var v0 = this._freqs[pos];
            var v1 = this._freqs[pos + 1];
            var f = index - pos;
            v = v0 * (1 - f) + v1 * f;
        }

        this.setOutputData(0, (v / 255) * this.properties.amplitude);
    }

    onGetInputs() {
        return [["band", "number"]];
    }
}
LiteGraph.registerNodeType("audio/signal", LGAudioBandSignal);


class LGAudioScript {

    static title = "Script";
    static desc = "apply script to signal";

    constructor() {
        if (!LGAudioScript.default_code) {
            var code = LGAudioScript.default_function.toString();
            var index = code.indexOf("{") + 1;
            var index2 = code.lastIndexOf("}");
            LGAudioScript.default_code = code.substr(index, index2 - index);
        }

        // default
        this.properties = { code: LGAudioScript.default_code };

        // create node
        var ctx = LGAudio.getAudioContext();
        if (ctx.createScriptProcessor) {
            this.audionode = ctx.createScriptProcessor(4096, 1, 1);
        } else { // buffer size, input channels, output channels
            console.warn?.("ScriptProcessorNode deprecated");
            this.audionode = ctx.createGain(); // bypass audio
        }

        this.processCode();
        if (!LGAudioScript._bypass_function) {
            LGAudioScript._bypass_function = this.audionode.onaudioprocess;
        }

        // slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    onAdded(graph) {
        if (graph.status == LiteGraph.LGraph.STATUS_RUNNING) {
            this.audionode.onaudioprocess = this._callback;
        }
    }

    onStart() {
        this.audionode.onaudioprocess = this._callback;
    }

    onStop() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    }

    onPause() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    }

    onUnpause() {
        this.audionode.onaudioprocess = this._callback;
    }

    onExecute() {
        // nothing! because we need an onExecute to receive onStart... fix that
    }

    onRemoved() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    }

    processCode() {
        try {
            var func = new Function("properties", this.properties.code);
            this._script = new func(this.properties);
            this._old_code = this.properties.code;
            this._callback = this._script.onaudioprocess;
        } catch (err) {
            console.error?.("Error in onaudioprocess code", err);
            this._callback = LGAudioScript._bypass_function;
            this.audionode.onaudioprocess = this._callback;
        }
    }

    onPropertyChanged(name, value) {
        if (name == "code") {
            this.properties.code = value;
            this.processCode();
            if (this.graph && this.graph.status == LiteGraph.LGraph.STATUS_RUNNING) {
                this.audionode.onaudioprocess = this._callback;
            }
        }
    }

    static default_function() {
        this.onaudioprocess = function (audioProcessingEvent) {
            // The input buffer is the song we loaded earlier
            var inputBuffer = audioProcessingEvent.inputBuffer;

            // The output buffer contains the samples that will be modified and played
            var outputBuffer = audioProcessingEvent.outputBuffer;

            // Loop through the output channels (in this case there is only one)
            for (
                var channel = 0;
                channel < outputBuffer.numberOfChannels;
                channel++
            ) {
                var inputData = inputBuffer.getChannelData(channel);
                var outputData = outputBuffer.getChannelData(channel);

                // Loop through the 4096 samples
                for (var sample = 0; sample < inputBuffer.length; sample++) {
                    // make output equal to the same as the input
                    outputData[sample] = inputData[sample];
                }
            }
        };
    }
    "@code" = { widget: "code", type: "code" };
}
LGAudio.createAudioNodeWrapper(LGAudioScript);
LiteGraph.registerNodeType("audio/script", LGAudioScript);


class LGAudioDestination {

    static title = "Destination";
    static desc = "Audio output";

    constructor() {
        this.audionode = LGAudio.getAudioContext().destination;
        this.addInput("in", "audio");
    }
}
LiteGraph.registerNodeType("audio/destination", LGAudioDestination);


class LGWebSocket {

    static title = "WS Client";
    static desc = "Connect to a WebSocket to send and receive data";

    constructor() {
        this.size = [60, 20];
        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            url: "ws://127.0.0.1:8080",
            room: false,
            only_send_changes: true,
            runOnServerToo: false
        };
        this._ws = null;
        this._last_sent_data = [];
        this._last_received_data = [];
        this._hasWarned = false; // To ensure warning is only logged once
    }

    onPropertyChanged(name, _value) {
        if (name === "url") {
            this.connectSocket();
        }
    }

    onExecute() {
        if (!this._ws && this.properties.url) {
            this.connectSocket();
        }

        if (!this._ws || this._ws.readyState !== WebSocket.OPEN) {
            return;
        }

        const room = this.properties.room;
        const only_changes = this.properties.only_send_changes;

        for (let i = 1; i < this.inputs.length; ++i) {
            const data = this.getInputData(i);
            if (data == null) {
                continue;
            }

            let json;
            try {
                json = JSON.stringify({
                    type: 0,
                    channel: i,
                    data: data,
                });
                if (room) json.room = room;
            } catch (err) {
                console.error("Error stringifying data:", err);
                continue;
            }

            if (only_changes && this._last_sent_data[i] === json) {
                continue;
            }

            this._last_sent_data[i] = json;
            try {
                this._ws.send(json);
                console.log("WS sent by execute:", i, json);
            } catch (err) {
                console.error("Error sending data:", err);
            }
        }

        for (let i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor === "#AFA") {
            this.boxcolor = "#6C6";
        }
    }

    connectSocket() {
        if (typeof process !== 'undefined' && process.versions && process.versions.node) {
            if (!this.properties.runOnServerToo) {
                if (!this._hasWarned) {
                    console.warn("WebSocket connection is not allowed to run on the server. Set 'runOnServerToo' to true to enable.");
                    this._hasWarned = true;
                }
                return;
            }
        }

        if (this._ws) {
            this._ws.close();
        }

        const url = this.properties.url.startsWith("ws") ? this.properties.url : "ws://" + this.properties.url;
        try {
            this._ws = new WebSocket(url);
        } catch (err) {
            console.error("Error creating WebSocket:", err);
            return;
        }

        this._ws.onopen = () => {
            console.log("WS ready");
            this.boxcolor = "#6C6";
        };

        this._ws.onmessage = (e) => {
            this.boxcolor = "#AFA";
            console.info("WS on message:", e.data);

            let data = e.data;

            if (typeof data === 'string') {
                try {
                    data = JSON.parse(data);
                } catch (err) {
                    console.warn("Received non-JSON data:", data);
                }
            } else if (data instanceof ArrayBuffer) {
                console.log("Received binary data");
                const byteArray = new Uint8Array(data);
                const binaryString = new TextDecoder('utf-8').decode(byteArray);
                console.log("Binary data as string:", binaryString);
                const binaryBase64 = btoa(String.fromCharCode.apply(null, byteArray));
                console.log("Binary data as base64:", binaryBase64);
                data = binaryString;
            }

            if (data.room && data.room !== this.properties.room) {
                console.debug("WS: received message for different room");
                return;
            }

            if (data.type === 1) {
                if (data.data.object_class && LiteGraph[data.data.object_class]) {
                    try {
                        const obj = new LiteGraph[data.data.object_class](data.data);
                        this.triggerSlot(0, obj);
                        console.debug("WS received object:", obj);
                    } catch (err) {
                        console.error("Error creating object:", err);
                    }
                } else if (data.data !== undefined) {
                    this.triggerSlot(0, data.data);
                    console.debug("WS received data:", data.data);
                }
            } else {
                if (data.data !== undefined) {
                    this._last_received_data[data.channel !== undefined ? data.channel : 0] = data.data;
                    console.debug("WS received channel data:", data.channel, data.data);
                }
            }
        };

        this._ws.onerror = (err) => {
            console.error("WS connection error:", err);
            this.boxcolor = "#E88";
        };

        this._ws.onclose = () => {
            console.log("WS connection closed");
            this.boxcolor = "#000";
        };
    }

    disconnectSocket() {
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
    }

    send(data) {
        if (!this._ws || this._ws.readyState !== WebSocket.OPEN) {
            return;
        }
        const msg = JSON.stringify({ type: 1, msg: data });
        try {
            this._ws.send(msg);
            console.log("WS sent:", msg);
        } catch (err) {
            console.error("Error sending data:", err);
        }
    }

    onAction(action, param) {
        if (!this._ws || this._ws.readyState !== WebSocket.OPEN) {
            return;
        }
        const oMsg = {
            type: 1,
            action: action,
            data: param,
        };
        if (this.properties.room) oMsg.room = this.properties.room;
        const msg = JSON.stringify(oMsg);
        try {
            this._ws.send(msg);
            console.log("WS sent by Action:", oMsg);
        } catch (err) {
            console.error("Error sending data by action:", err);
        }
    }

    onGetInputs() {
        return [["in", 0]];
    }

    onGetOutputs() {
        return [["out", 0]];
    }

    onRemove() {
        this.disconnectSocket();
    }
}
LiteGraph.registerNodeType("network/websocket", LGWebSocket);



// HTTP Request
class HTTPRequestNode {

    static title = "HTTP Request";
    static desc = "Fetch data through HTTP";

    constructor() {
        this.addInput("request", LiteGraph.ACTION);
        this.addInput("url", "string");
        this.addProperty("url", "");
        this.addOutput("ready", LiteGraph.EVENT);
        this.addOutput("data", "string");
        this.addWidget("button", "Fetch", null, this.fetch.bind(this));
        this._data = null;
        this._fetching = null;
    }

    fetch() {
        var url = this.getInputOrProperty("url");
        if (!url)
            return;

        this.boxcolor = "#FF0";
        var that = this;
        this._fetching = fetch(url)
            .then((resp) => {
                if (!resp.ok) {
                    this.boxcolor = "#F00";
                    that.trigger("error");
                } else {
                    this.boxcolor = "#0F0";
                    return resp.text();
                }
            })
            .then((data) => {
                that._data = data;
                that._fetching = null;
                that.trigger("ready");
            });
    }

    onAction(evt) {
        if (evt == "request")
            this.fetch();
    }

    onExecute() {
        this.setOutputData(1, this._data);
    }

    onGetOutputs() {
        return [["error", LiteGraph.EVENT]];
    }
}
LiteGraph.registerNodeType("network/httprequest", HTTPRequestNode);


// -------------- TODO TEST ---------------
class WebRTCNode {
    static title = "WebRTC";
    static desc = "Send and receive data through WebRTC";

    constructor() {
        this.size = [100, 60];
        this.addInput("send", LiteGraph.ACTION);
        this.addInput("data", 0);
        this.addInput("offer", "string");
        this.addInput("answer", "string");
        this.addOutput("offer", "string");
        this.addOutput("answer", "string");
        this.addOutput("received", LiteGraph.EVENT);
        this.addOutput("data", 0);
        this.properties = {
            signalingServer: "",
            stunServer: "", // stun:stun.l.google.com:19302
            turnServer: "",
            username: "",
            credential: ""
        };
        this.peerConnection = null;
        this.dataChannel = null;
        this._lastReceivedData = null;
    }

    onPropertyChanged(name, value) {
        if (["signalingServer", "stunServer", "turnServer", "username", "credential"].includes(name)) {
            this.createPeerConnection();
        }
    }

    createPeerConnection() {
        if (!this.properties.stunServer || (!this.properties.turnServer && (this.properties.username || this.properties.credential))) {
            console.warn("Incomplete WebRTC configuration. Ensure stunServer and (optionally) turnServer with username and credential are set.");
            return;
        }

        try {
            if (this.peerConnection) {
                this.peerConnection.close();
            }

            const iceServers = [
                { urls: this.properties.stunServer }
            ];

            if (this.properties.turnServer) {
                iceServers.push({
                    urls: this.properties.turnServer,
                    username: this.properties.username,
                    credential: this.properties.credential
                });
            }

            this.peerConnection = new RTCPeerConnection({ iceServers });

            this.peerConnection.ondatachannel = (event) => {
                this.dataChannel = event.channel;
                this.setupDataChannel();
            };

            this.peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.debug("ICE candidate:", event.candidate);
                } else {
                    if (this.peerConnection.localDescription.type === "offer") {
                        this.setOutputData(0, JSON.stringify(this.peerConnection.localDescription));
                    } else {
                        this.setOutputData(1, JSON.stringify(this.peerConnection.localDescription));
                    }
                }
            };

            this.dataChannel = this.peerConnection.createDataChannel("dataChannel");
            this.setupDataChannel();

            this.peerConnection.createOffer()
                .then(offer => this.peerConnection.setLocalDescription(offer))
                .catch(error => console.error("Error creating offer:", error));
        } catch (error) {
            console.error("Error creating peer connection:", error);
        }
    }

    setupDataChannel() {
        if (!this.dataChannel) return;

        this.dataChannel.onopen = () => {
            console.debug("Data channel open");
            this.boxcolor = "#00FF00";
        };

        this.dataChannel.onclose = () => {
            console.debug("Data channel closed");
            this.boxcolor = "#990000";
        };

        this.dataChannel.onmessage = (event) => {
            try {
                const receivedData = JSON.parse(event.data);
                this._lastReceivedData = receivedData;
                this.setOutputData(3, receivedData);
                this.triggerSlot(2, receivedData);
                console.debug("Data received:", event.data);
            } catch (error) {
                console.error("Error parsing received data:", error);
            }
        };

        this.dataChannel.onerror = (error) => {
            console.error("Data channel error:", error);
            this.boxcolor = "#FF0000";
        };
    }

    onExecute() {
        if (!this.peerConnection) {
            this.createPeerConnection();
        }

        if (this.dataChannel && this.dataChannel.readyState === "open") {
            const data = this.getInputData(1);
            if (data != null) {
                try {
                    this.dataChannel.send(JSON.stringify(data));
                    console.debug("Data sent:", data);
                } catch (error) {
                    console.error("Error sending data:", error);
                }
            }
        }

        this.setOutputData(3, this._lastReceivedData);
    }

    onAction(action, param) {
        if (!this.peerConnection) {
            this.createPeerConnection();
        }

        if (this.dataChannel && this.dataChannel.readyState === "open") {
            try {
                this.dataChannel.send(JSON.stringify(param));
                console.debug("Data sent by action:", param);
            } catch (error) {
                console.error("Error sending data by action:", error);
            }
        }
    }

    onConnectionsChange(input) {
        if (input && input.type === "string") {
            if (input.name === "offer") {
                this.handleOffer(input.data);
            } else if (input.name === "answer") {
                this.handleAnswer(input.data);
            }
        }
    }

    async handleOffer(offer) {
        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(offer)));
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            this.setOutputData(1, JSON.stringify(answer));
        } catch (error) {
            console.error("Error handling offer:", error);
        }
    }

    async handleAnswer(answer) {
        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));
        } catch (error) {
            console.error("Error handling answer:", error);
        }
    }

    onRemove() {
        if (this.peerConnection) {
            this.peerConnection.close();
        }
    }

    // onGetInputs() {
    //     return [["send", LiteGraph.ACTION], ["data", 0], ["offer", "string"], ["answer", "string"]];
    // }

    // onGetOutputs() {
    //     return [["offer", "string"], ["answer", "string"], ["received", LiteGraph.EVENT], ["data", 0]];
    // }
}
LiteGraph.registerNodeType("network/webrtc", WebRTCNode);



// Note: This node requires the 'osc' library to be integrate in both cases: running in browser or Node.js.
// To install, run: npm install osc
// there are two node libraries: osc and osc-js, using osc here because have browser counterpart

class OSCNode {
    static title = "OSC";
    static desc = "Send and receive data through OSC";

    constructor() {
        this.size = [100, 60];
        this.addInput("send", LiteGraph.ACTION);
        this.addInput("data", 0);
        this.addOutput("received", LiteGraph.EVENT);
        this.addOutput("data", 0);
        this.properties = {
            host: "127.0.0.1",
            port: 57121,
            localPort: 57120,
            address: "/osc/address",
            useWebSocket: true,
            webSocketURL: "ws://localhost:8080"
        };
        this._osc = null;
        this._lastReceivedData = null;
        this.isNode = (typeof process !== 'undefined' && process.versions && process.versions.node);
        this._connected = false;
        this._cant_connect = false;
    }

    onPropertyChanged(name, value) {
        if (["host", "port", "localPort", "address", "useWebSocket", "webSocketURL"].includes(name)) {
            this._cant_connect = false;
            this.initConnection();
        }
    }

    initConnection() {
        if (this._osc) {
            this._osc.close();
            this._osc = null;
        }
        if(typeof(this._title)=="undefined"){
            this._title = this.title;
        }
        if (this.isNode) {
            this.initNodeOSC();
            if(typeof(this._title)!=="undefined") this.title = this._title;
        } else if (this.properties.useWebSocket) {
            this.initBrowserOSC();
            if(typeof(this._title)!=="undefined") this.title = this._title;
        } else {
            console.warn("OSCNode can only run on Node.js server or WebSocket in the browser");
            this.boxcolor = "#FF0000";
            this.title = "OSC (useWebSocket disabled)";
            this._cant_connect = true;
        }
    }

    initNodeOSC() {
        const osc = require('osc');

        try {
            this._osc = new osc.UDPPort({
                localAddress: "0.0.0.0",
                localPort: this.properties.localPort,
                remoteAddress: this.properties.host,
                remotePort: this.properties.port
            });

            this._osc.on("ready", () => {
                console.debug(`OSC server is ready on ${this.properties.localPort}`);
                this._connected = true;
                this.boxcolor = "#00FF00";
            });

            this._osc.on("message", (oscMessage) => {
                this._lastReceivedData = oscMessage.args;
                this.setOutputData(1, this._lastReceivedData);
                this.triggerSlot(0, this._lastReceivedData);
                console.debug("OSC message received:", oscMessage);
            });

            this._osc.on("error", (err) => {
                console.error("OSC error:", err);
                this._connected = false;
                this.boxcolor = "#FF0000";
            });

            this._osc.open();
        } catch (error) {
            console.error("Error initializing Node.js OSC connection:", error);
            this.boxcolor = "#FF0000";
        }
    }

    initBrowserOSC() {
        try {
            this._osc = new WebSocket(this.properties.webSocketURL);

            this._osc.onopen = () => {
                console.debug("WebSocket connection opened");
                this._connected = true;
                this.boxcolor = "#00FF00";
            };

            this._osc.onmessage = (event) => {
                try {
                    const oscMessage = JSON.parse(event.data);
                    this._lastReceivedData = oscMessage.args;
                    this.setOutputData(1, this._lastReceivedData);
                    this.triggerSlot(0, this._lastReceivedData);
                    console.debug("OSC message received via WebSocket:", oscMessage);
                } catch (error) {
                    console.error("Error parsing OSC message via WebSocket:", error);
                }
            };

            this._osc.onerror = (err) => {
                console.error("WebSocket error:", err);
                this._connected = false;
                this.boxcolor = "#FF0000";
            };

            this._osc.onclose = () => {
                console.debug("WebSocket connection closed");
                this._connected = false;
                this.boxcolor = "#AA0000";
            };
        } catch (error) {
            console.error("Error initializing WebSocket OSC connection:", error);
            this.boxcolor = "#FF0000";
        }
    }

    onExecute() {
        if (!this._connected || !this._osc) {
            if (!this._cant_connect) this.initConnection();
            return;
        }

        const data = this.getInputData(1);
        if (data != null) {
            const message = {
                address: this.properties.address,
                args: Array.isArray(data) ? data : [data]
            };

            try {
                if (this.isNode) {
                    this._osc.send(message);
                } else {
                    this._osc.send(JSON.stringify(message));
                }
                console.debug("OSC message sent:", message);
            } catch (error) {
                console.error("Error sending OSC message:", error);
            }
        }

        this.setOutputData(1, this._lastReceivedData);
    }

    onAction(action, param) {
        if (!this._connected || !this._osc) {
            return;
        }

        const message = {
            address: this.properties.address,
            args: Array.isArray(param) ? param : [param]
        };

        try {
            if (this.isNode) {
                this._osc.send(message);
            } else {
                this._osc.send(JSON.stringify(message));
            }
            console.debug("OSC message sent by action:", message);
        } catch (error) {
            console.error("Error sending OSC message by action:", error);
        }
    }

    onRemove() {
        if (this._osc) {
            this._osc.close();
        }
    }

    // onGetInputs() {
    //     return [["send", LiteGraph.ACTION], ["data", 0]];
    // }

    // onGetOutputs() {
    //     return [["received", LiteGraph.EVENT], ["data", 0]];
    // }
}
LiteGraph.registerNodeType("network/osc", OSCNode);




// -------------- NODE JS ONLY ---------------


/**
 * To use this WebSocket server node, ensure you have the 'ws' package installed.
 * Install it using the following command:
 * 
 * npm install ws
 */
class LGWebSocketServer {
    static title = "WebSocket Server";
    static desc = "WebSocket server node";

    constructor() {
        this.size = [60, 20];
        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            port: 8080,
            room: false,
            only_send_changes: true,
            broadcast: true,
        };
        this._wsServer = null;
        this._clients = new Set();
        this._last_sent_data = [];
        this._last_received_data = [];

        if (typeof process === 'undefined' || process.browser) {
            console.warn("WebSocket Server node is designed to run in Node.js, not in a browser.");
            this.boxcolor = "#FF0000";
            this.title = "WSServer (run on server)";
        } else {
            this.startWebSocketServer();
        }
    }

    onPropertyChanged(name, _value) {
        if (name == "port" && this._wsServer) {
            this.restartWebSocketServer();
        }
    }

    onExecute() {
        if (!this._wsServer) {
            return;
        }

        // const room = this.properties.room;
        const only_changes = this.properties.only_send_changes;

        for (let i = 1; i < this.inputs.length; ++i) {
            const data = this.getInputData(i);
            if (data == null) {
                continue;
            }

            let json;
            try {
                json = JSON.stringify({
                    type: 0,
                    // room: room,
                    channel: i,
                    data: data,
                });
            } catch (err) {
                console.error("Error stringifying data:", err);
                continue;
            }

            if (only_changes && this._last_sent_data[i] == json) {
                continue;
            }

            this._last_sent_data[i] = json;
            for (const client of this._clients) {
                if (client.readyState === 1) { // WebSocket.OPEN
                    client.send(json);
                }
            }
            console.log?.("WS sent by execute:", i, json);
        }

        for (let i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    }

    startWebSocketServer() {
        const WebSocket = require('ws');
        const port = this.properties.port;

        this._wsServer = new WebSocket.Server({ port });
        this._wsServer.on('connection', (ws) => {
            this._clients.add(ws);
            ws.on('message', (message) => this.handleMessage(ws, message));
            ws.on('close', () => this._clients.delete(ws));
            console.log?.("New client connected");
        });

        this._wsServer.on('listening', () => {
            console.log(`WebSocket server is running on ws://localhost:${port}`);
            this.boxcolor = "#6C6";
        });

        this._wsServer.on('error', (error) => {
            console.error("WebSocket server error:", error);
            this.boxcolor = "#E88";
        });
    }

    restartWebSocketServer() {
        if (this._wsServer) {
            this._wsServer.close(() => {
                this.startWebSocketServer();
            });
        }
    }

    handleMessage(ws, message) {
        this.boxcolor = "#AFA";
        console.info("WS on message:", message);

        let data;
        try {
            data = JSON.parse(message);
        } catch (err) {
            console.error("Error parsing message:", err);
            return;
        }

        // if (data.room && data.room !== this.properties.room) {
        //     console.debug("Message room mismatch:", data.room);
        //     return;
        // }

        if (data.type === 1) {
            if (data.data.object_class && LiteGraph[data.data.object_class]) {
                try {
                    const obj = new LiteGraph[data.data.object_class](data.data);
                    this.triggerSlot(0, obj);
                    console.debug("WS received object:", obj);
                } catch (err) {
                    console.error("Error creating object:", err);
                }
            } else {
                this.triggerSlot(0, data.data);
                console.debug("WS received data:", data.data);
            }
        } else {
            this._last_received_data[data.channel ?? 0] = data.data;
            console.debug("WS received channel data:", data.channel, data.data);
        }

        // Broadcast message to other clients if broadcasting is enabled
        if (this.properties.broadcast) {
            const broadcastMessage = JSON.stringify(data);
            for (const client of this._clients) {
                if (client !== ws && client.readyState === 1) { // WebSocket.OPEN
                    client.send(broadcastMessage);
                }
            }
            console.debug("WS broadcasted message:", broadcastMessage);
        }
    }

    send(data) {
        if (!this._wsServer) {
            return;
        }
        const msg = JSON.stringify({ type: 1, msg: data });
        for (const client of this._clients) {
            if (client.readyState === 1) { // WebSocket.OPEN
                client.send(msg);
            }
        }
        console.log?.("WS sent:", msg);
    }

    onAction(action, param, options) {
        if (!this._wsServer) {
            return;
        }
        const data = this.getInputData("in");
        if (data == null) {
            return; // continue; // 
        }
        const msg = JSON.stringify({
            type: 1,
            // room: this.properties.room,
            action: action,
            msg: data, //param,
        });
        for (const client of this._clients) {
            if (client.readyState === 1) { // WebSocket.OPEN
                client.send(msg);
            }
        }
        console.debug?.("WS sent by Action:", msg, options);
    }

    onGetInputs() {
        return [["in", 0]];
    }

    onGetOutputs() {
        return [["out", 0]];
    }
}
LiteGraph.registerNodeType("network/websocketserver", LGWebSocketServer);


// Note: This node requires the 'dgram' module to be available in Node.js.
// To install, run: npm install dgram

class UDPNode {
    static title = "UDP";
    static desc = "Send and receive data through UDP";

    constructor() {
        this.size = [60, 20];
        this.addInput("send", LiteGraph.ACTION);
        this.addInput("data", 0);
        this.addOutput("received", LiteGraph.EVENT);
        this.addOutput("data", 0);
        this.properties = {
            host: "127.0.0.1",
            port: 41234,
            only_send_changes: true,
        };
        this._dgram = null;
        this._last_sent_data = null;
        this._last_received_data = null;
        this.isNode = (typeof process !== 'undefined' && process.versions && process.versions.node);

        if (this.isNode) {
            console.debug("UDPNode initialized in Node.js environment");
            this.connectSocket();
        } else {
            console.warn("UDPNode can only run on Node.js server");
            this.boxcolor = "#FF0000";
            this.title = "UDP (run on server)";
        }
    }

    onPropertyChanged(name, value) {
        if (name == "host" || name == "port") {
            if (this.isNode) {
                console.debug("Property changed:", name, value);
                this.connectSocket();
            }
        }
    }

    onExecute() {
        if (!this._dgram) {
            if (this.isNode) {
                this.connectSocket();
            } else {
                return;
            }
        }

        var only_changes = this.properties.only_send_changes;

        // Send data
        var data = this.getInputData(1);
        if (data != null) {
            var message = Buffer.from(JSON.stringify(data));

            if (only_changes && this._last_sent_data == message.toString()) {
                return;
            }

            this._last_sent_data = message.toString();

            this._dgram.send(message, 0, message.length, this.properties.port, this.properties.host, (err) => {
                if (err) {
                    console.error('UDP send error:', err);
                } else {
                    console.debug("UDP message sent", message.toString());
                }
            });
        }

        // Receive data
        this.setOutputData(1, this._last_received_data);

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    }

    connectSocket() {
        const dgram = require('dgram'); // Ensure 'dgram' module is available in Node.js
        if (this._dgram) {
            this._dgram.close();
        }

        this._dgram = dgram.createSocket('udp4');

        this._dgram.on('message', (msg, rinfo) => {
            this._last_received_data = JSON.parse(msg.toString());
            this.triggerSlot(0, this._last_received_data);
            console.debug('UDP message received', msg.toString());
        });

        this._dgram.on('error', (err) => {
            console.error('UDP error:', err);
            this._dgram.close();
        });

        this._dgram.on('listening', () => {
            const address = this._dgram.address();
            console.debug(`UDP server listening ${address.address}:${address.port}`);
        });

        this._dgram.bind(this.properties.port);
    }

    onAction(action, param) {
        this.send(param);
    }

    onGetInputs() {
        return [["data", 0]];
    }

    onGetOutputs() {
        return [["data", 0]];
    }

    onRemove() {
        if (this._dgram) {
            this._dgram.close();
        }
    }
}
LiteGraph.registerNodeType("network/udp", UDPNode);

// EG METHOD

// function mMETHOD(){
//     this.properties = { };
//     // this.addInput("onTrigger", LiteGraph.ACTION);
//     // this.addInput("condition", "boolean");
//     // this.addOutput("true", LiteGraph.EVENT);
//     // this.addOutput("false", LiteGraph.EVENT);
//     this.mode = LiteGraph.ON_TRIGGER;
// }
// mMETHOD.title = "Branch";
// mMETHOD.desc = "Branch execution on condition";
// mMETHOD.prototype.onExecute = function(param, options) {
//     // this.triggerSlot(0);
// };
// mMETHOD.prototype.onAction = function(action, param, options){
// };
// mMETHOD.prototype.onGetInputs = function() {
//     //return [["optional slot in", 0]];
// };
// mMETHOD.prototype.onGetOutputs = function() {
//     //return [["optional slot out", 0]];
// };
// LiteGraph.registerNodeType("objects/egnode", mMETHOD);

// --------------------------

class objProperties {

    static title = "OBJ props";
    static desc = "Properties for objects";

    constructor() {

        this.addInput("obj", "object");
        // this.addInput("condition", "boolean");

        this.addOutput("properties", "array");
        // this.addOutput("false", LiteGraph.EVENT);

        // this.mode = LiteGraph.ON_TRIGGER;
        // this.widget = this.addWidget("text","prop.","",this.setValue.bind(this) );
        // this.widgets_up = true;
        // this.size = [140, 30];
        this._value = null;
        this._properties = [];
    }

    onExecute() {
        var data = this.getInputData(0);
        if (data != null) {
            this._value = data;
            try{
                this._properties = Object.keys(this._value);
            }catch(e) {
                console.error?.(e);
            }
            this.setOutputData(0, this._properties);
        }
    }
    onAction() {
        // should probably execute on action
    }
    onGetInputs() {
        // return [["in", 0]];
    }
    onGetOutputs() {
        // return [["out", 0]];
    }
    getTitle() {
    //    if (this.flags.collapsed) {
    //    }
        return this.title;
    }
    onPropertyChanged() {
        // this.widget.value = value;
    }
}
LiteGraph.registerNodeType("objects/properties", objProperties);

// --------------------------

// node events
/*
onWidgetChanged
*/


// widgets
/*

this.widg_prop = this.addWidget("property","prop.","",this.setValue.bind(this) );
this.widg_prop = this.addWidget("combo","prop.",this.properties.prop,{ property: "prop", values: [] }); //,this.setValue.bind(this) );

// to put it before inputs
this.widgets_up = true;

// remove or update does not exists :: should save index to do it :: this.removeWidget();
// to clear
this.widgets = [];
// readd if needed
this.widg_prop = this.addWidget();

// can specify draw function
obWidget.draw = function(ctx, node, widget_width, y, H){

}
// can override sizing
obWidget.computeSize = function(width, height){
    return [newW,newH];
}

obWidget.mouse = function(){
    return b_isDirtyCanvas; // can specify if canvas should get dirty
}

obWidget.callback = function(value, canvas, node, pos, event){

}

*/

// --------------------------


class objPropertyWidget {

    static title = "Obj Prop widget";
    static desc = "Choose a property for an object";

    constructor() {

        this.addInput("obj", "object");
        // this.addInput("condition", "boolean");

        this.addOutput("value", "*");
        // this.addOutput("false", LiteGraph.EVENT);

        this.addProperty("prop", 0);

        // this.mode = LiteGraph.ON_REQUEST; // to be optimized, could run always
        // this.widg_prop = this.addWidget("property","prop.","",this.setValue.bind(this) );
        this.widg_prop = this.addWidget("combo","prop.",this.properties.prop,{ property: "prop", values: [] }); // ,this.setValue.bind(this) );
        // this.widgets_up = true;
        // this.size = [140, 30];

        this._obin = null;
        this._value = null;
        this._properties = [];
    }

    setValue(v) {
        this.properties.prop = v;
        this.widg_prop.value = v;
    }

    updateFromInput() {
        var data = this.getInputData(0);
        if (data != null) {
            this._obin = data;
            if(this._obin) { // } && typeof this._obin == "Object"){
                // TODO should detect change or rebuild use a widget/action to refresh properties list
                try{
                    this._properties = Object.keys(this._obin);
                    if(this._properties && this._properties.sort)
                        this._properties = this._properties.sort();
                }catch(e) {
                    console.error?.(e);
                }
                if(this._properties) {
                    // this.removeWidget();
                    this.widgets = [];
                    this.widg_prop = this.addWidget("combo","prop",this.properties.prop,{ property: "prop", values: this._properties });
                }
                if(typeof this._obin[this.properties.prop] !== "undefined") {
                    this._value = this._obin[this.properties.prop];
                }else{
                    this._value = null;
                }
            }else{
                this._value = null;
                this._properties = [];
            }
        }
        if(!this.widg_prop.options) this.widg_prop.options = {};
        this.widg_prop.options.values = this._properties;
        this.setOutputData(0, this._value);
    }

    onConnectionChanged(connection, slot, connected, link_info) {
        // only process the inputs
        if (connection != LiteGraph.INPUT) {
            return;
        }
        this.updateFromInput();
    }

    onExecute() {
        this.updateFromInput();
    }

    onAction() {
        // should probably execute on action
        this.updateFromInput();
    }

    onGetInputs() {
        // return [["in", 0]];
    }

    onGetOutputs() {
        // return [["out", 0]];
    }

    getTitle() {
        if (this.flags.collapsed) {
            return this.properties.prop;
        }
        return this.title;
    }

    onPropertyChanged(name, value) {
        if(name == "value") {
            this.widg_prop.value = value;
        }
    }

    getExtraMenuOptions() {
        return [{
            content: "Console DBG", // has_submenu: false,
            callback: function(menuitO,obX,ev,htmO,nodeX) {
                console.debug?.(nodeX.widg_prop);
                console.debug?.(nodeX);
            },
        }];
    }
}
LiteGraph.registerNodeType("objects/property_widget", objPropertyWidget);


class objMethodWidget {

    static title = "Obj Method widget";
    static desc = "Choose and execute a method from an object";

    constructor() {
        this.addInput("obj", "object");
        // this.addInput("onTrigger", LiteGraph.ACTION);
        this.addInput("refresh", LiteGraph.ACTION);
        this.addInput("execute", LiteGraph.ACTION);
        this.addOutput("executed", LiteGraph.EVENT);
        this.addOutput("method", "function");
        this.addOutput("return", "*");
        this.addProperty("method", null);
        // this.mode = LiteGraph.ON_REQUEST; // to be optimized, could run always
        this.widg_prop = this.addWidget("combo","method",this.properties.method,{ property: "method", values: [] }); // ,this.setValue.bind(this) );
        this._obin = null;
        this._function = null;
        this._methods = [];
    }

    setValue(v) {
        this.properties.method = v;
        this.widg_prop.value = v;
    }

    updateFromInput(v) {
        var that = this;
        var data = this.getInputData(0);
        if (data != null) {
            this._obin = data;
            if(this._obin) { // } && typeof this._obin == "Object"){
                // TODO should detect change or rebuild use a widget/action to refresh properties list
                try{
                    this._methods = [];
                    // method 1, simple
                    /* var allProps = Object.keys(this._obin);
                    console.debug("Props",allProps);
                    for(var iM in allProps){
                        // console.debug("dbg prop",allProps[iM],typeof(this._obin[allProps[iM]]));
                        if(typeof(this._obin[allProps[iM]]) == "function"){
                            this._methods.push(allProps[iM]);
                        }
                    } */
                    // method 2, better
                    /* for(var iM in this._obin){
                        // console.debug("dbg prop",allProps[iM],typeof(this._obin[allProps[iM]]));
                        if(typeof(this._obin[iM]) == "function"){
                            this._methods.push(iM);
                        }
                    } */
                    // method 3
                    this._properties = [];
                    currentObj = this._obin;
                    do {
                        Object.getOwnPropertyNames(currentObj).map(function(item){ if(!that._properties.includes(item)) that._properties.push(item) });
                    } while ((currentObj = Object.getPrototypeOf(currentObj)));
                    for(var iM in this._properties){
                        if(typeof(this._obin[this._properties[iM]]) == "function"){
                            this._methods.push(this._properties[iM]);
                        }
                    }
                    if(this._methods && this._methods.sort) this._methods = this._methods.sort();
                }catch(e) {
                    console.warn?.("Err on methods get",e);
                }
                if(this._methods) {
                    // this.removeWidget();
                    this.widgets = [];
                    this.widg_prop = this.addWidget("combo","method",this.properties.method,{ property: "method", values: this._methods });
                }

            }else{
                console.debug?.("Invalid obj",data);
                this._function = null;
                this._methods = [];
            }
        }
        if(!this.widg_prop.options) this.widg_prop.options = {}; // reset widget options
        this.widg_prop.options.values = this._methods; // set widget options

        this.updateInputsForMethod();
    }

    updateInputsForMethod() {
        // TODO fixthis :: property is not yet updated?
        var actVal = this.widg_prop.value; // this.properties.method
        if(actVal && this._obin && typeof this._obin[actVal] !== "undefined") {

            // if changed, reset inputs
            // if(this._function !== this._obin[actVal]){
            //     for (var i = 3; i < this.inputs; ++i) {
            //         this.removeSlot(i);
            //     }
            // }

            this._function = this._obin[actVal];
            
            // inheritance ?
            // using call or apply ?
            // prototype ¿
            // Uncaught (in promise) TypeError: can't access private field or method: object is not the right class
            /*
            BAD
            var actVal = this.widg_prop.value; // this.properties.method
            var r = this._obin.prototype[actVal].call(this._obin); */

            var params = Array(this._function.length);
            var names = LiteGraph.getParameterNames(this._function);
            for (var i = 0; i < names.length; ++i) {
                var exs = this.findInputSlot(names[i]);
                if(exs == -1) {
                    this.addInput(names[i],"",{auto: true, removable: false, nameLocked: true});
                }
            }
            this._params = names;

        }else{
            console.debug?.("Invalid method",actVal);
            this._function = null;
        }
        this.setOutputData(1, this._function); // update function output
    }

    onExecute() {
        // this.updateFromInput();
        // ?
    }

    // objMethodWidget.prototype.onPropertyChanged = function(name, value, prev_value){
    //     console.debug?.("Property changed", name, value, prev_value)
    //     this.updateInputsForMethod();
    // }

    onWidgetChanged(name, value, prev_value) {
        console.debug?.("Widget changed", name, value, prev_value);
        // if changed, reset inputs
        if(this.properties.method !== value) {
            for (var i = 3; i < this.inputs.length; ++i) {
                this.removeInput(i);
            }
        }
        this.updateInputsForMethod();
    }

    onAction(action) {
        // should probably execute on action
        // this.updateFromInput();
        if(action == "refresh") {
            this.updateFromInput();
        }else if(action == "execute") {
            if(this._function && typeof(this._function) == "function") {

                var parValues = [];
                for (var i = 3; i < this.inputs.length; i++) {
                    parValues.push(this.getInputData(i));
                }

                // call execute
                console.debug?.("NodeObjMethod Execute",parValues);
                var r = this._function(parValues); // this._function.apply(this, parValues);

                this.triggerSlot(0);
                this.setOutputData(2, r); // update method result
            }else{
                this.setOutputData(1, null);
                this.setOutputData(2, null);
            }
        }
    }

    onGetInputs() {
        // return [["in", 0]];
    }

    onGetOutputs() {
        // return [["out", 0]];
    }

    getTitle() {
        if (this.flags.collapsed) {
            return this.properties.method;
        }
        return this.title;
    }

    onPropertyChanged(name, value) {
        if(name == "value") {
            this.widg_prop.value = value;
        }
    }

    getExtraMenuOptions() {
        return [{
            content: "NodeObjMethod DBG", // has_submenu: false,
            callback: function(menuitO,obX,ev,htmO,nodeX) {
                console.debug?.(NodeObjMethod, nodeX.widg_prop, nodeX);
            },
        }];
    }
}
LiteGraph.registerNodeType("objects/method_widget", objMethodWidget);


// eval a Global object
class objEvalGlo {

    static title = "Eval Obj";
    static desc = "Evaluate an object";

    constructor() {
        this.size = [60, 30];
        this.addProperty("obj_eval", "window");
        this.addOutput("obj", "object");
        this._func = null;
        this.data = {};
    }

    // SINGLE object EVAL
    onConfigure = function(o) {
        if (o.properties.obj_eval)
            this.compileCode(o.properties.obj_eval);
    };

    static widgets_info = {obj_eval: { type: "code" }};

    onPropertyChanged = function(name, value) {
        if (name == "obj_eval")
            this.compileCode(value);
    };

    compileCode(code) {
        this._func = null;
        if (LiteGraph.allow_scripts){
            // ok
        }else{
            console.warn("Obj string not evaluated, LiteGraph.allow_scripts is false");
        }
        if (code.length > 256) {
            console.warn?.("Script too long, max 256 chars");
        } else {
            var code_eval = "return "+code;
            // var forbidden_words = [
            //     "script",
            //     "body",
            //     "document",
            //     "eval",
            //     "objEvalGlo",
            //     "function"
            // ]; //bad security solution
            // for (var i = 0; i < forbidden_words.length; ++i) {
            //     if (code_low.indexOf(forbidden_words[i]) != -1) {
            //         console.warn?.("invalid script");
            //         return;
            //     }
            // }
            try {
                this._func = new Function("DATA", "node", code_eval);
                console.debug("Evaluated",code,this._func);
            } catch (err) {
                console.error?.("Error parsing obj evaluation");
                console.error?.(err);
            }
        }
        return false;
    }

    onExecute() {
        if (this.properties.obj_eval)
            this.compileCode(this.properties.obj_eval);
        if (!this._func) {
            this.setOutputData(0, null);
            return;
        }
        try {
            this.setOutputData(0, this._func(this.data, this));
        } catch (err) {
            this.setOutputData(0, null);
            console.error?.("Error in code eval");
            console.error?.(err);
        }
    }

    // objEvalGlo.prototype.onGetOutputs = function() {
    //     return [["C", ""]];
    // };
}
LiteGraph.registerNodeType("objects/evaluate", objEvalGlo);


// eval a Global object
class EventAsFunction {

    static title = "Event Function";
    static desc = "Get a function binded to an event";

    constructor() {
        this.size = [60, 30];
        this.addOutput("fun", "function");
        this.addOutput("executed", LiteGraph.EVENT);
        var that = this;
        this._func = function(){
            that.triggerSlot(1);
            // add arguments on slot
        };
        this.setOutputData("fun",this._func);
        this.data = {};
    }

    onConfigure(o) {
        this.setOutputData("fun",this._func);
    }

    onExecute() {
        if (!this._func) {
            return;
        }
        this.setOutputData("fun",this._func);
    }

}
LiteGraph.registerNodeType("objects/event_function", EventAsFunction);


class ObjectProperty {

    static title = "Object property";
    static desc = "Outputs the property of an object";

    constructor() {
        this.addInput("obj", "object");
        this.addOutput("property", 0);
        this.addProperty("value", 0);
        this.widget = this.addWidget("text", "prop.", "", this.setValue.bind(this));
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    setValue(v) {
        this.properties.value = v;
        this.widget.value = v;
    }

    getTitle() {
        if (this.flags.collapsed) {
            return "in." + this.properties.value;
        }
        return this.title;
    }

    onPropertyChanged(name, value) {
        this.widget.value = value;
    }

    onExecute() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, data[this.properties.value]);
        }
    }
}
LiteGraph.registerNodeType("objects/get_property", ObjectProperty);


class ObjectKeys {
    static title = "Object keys";
    static desc = "Outputs an array with the keys of an object";
    constructor() {
        this.addInput("obj", "object");
        this.addOutput("keys", "array");
        this.size = [140, 30];
    }

    onExecute() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, Object.keys(data));
        }
    }
}
LiteGraph.registerNodeType("objects/object_keys", ObjectKeys);


class SetObject {

    static title = "Set property";
    static desc = "Set property of object";

    constructor() {
        this.addInput("obj", "object");
        this.addInput("value", "");
        this.addOutput("obj", "object");
        this.properties = { property: "" };
        this.name_widget = this.addWidget(
            "text",
            "prop.",
            this.properties.property,
            "property",
        );
    }
    onExecute() {
        var obj = this.getInputData(0);
        if (!obj) return;
        var v = this.getInputData(1);
        if (v === undefined) return;
        if (this.properties.property) obj[this.properties.property] = v;
        this.setOutputData(0, obj);
    }
}
LiteGraph.registerNodeType("objects/set_property", SetObject);


class MergeObjects {

    static title = "Merge Objects";
    static desc = "Creates an object copying properties from others";

    constructor() {
        this.addInput("A", "object");
        this.addInput("B", "object");
        this.addOutput("out", "object");
        this._result = {};
        var that = this;
        this.addWidget("button", "clear", "", function () {
            that._result = {};
        });
        this.size = this.computeSize();
    }

    onExecute() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        var C = this._result;
        if (A)
            for (let i in A)
                C[i] = A[i];
        if (B)
            for (let i in B)
                C[i] = B[i];
        this.setOutputData(0, C);
    }
}
LiteGraph.registerNodeType("objects/merge_objects", MergeObjects);



// WIP
// https://api.cdnjs.com/libraries
/*
LiteGraph.libraries_known = {
    // "jquery": {"obj":"jQuery","name":"jquery", "latest":"..URL.."}
};
LiteGraph.libraries_loaded = {
    // "vue":{},
};
*/


// CDN LIBRARY SEARCH

class CDNLibSearch {
    constructor() {
        this.addInput("search", LiteGraph.ACTION);
        // this.addInput("name", "string"); in optionals
        this.addProperty("name", "", "string");
        this.addOutput("ready", LiteGraph.EVENT);
        this.addOutput("results", "array");
        this.addOutput("first name", "object");
        this.addOutput("first object", "object");
        // this.addOutput("error", LiteGraph.EVENT); // in optionals
        this.addWidget("string", "name", this.properties.name, "name");
        // this.addWidget("button", "Fetch", null, this.fetch.bind(this));
        this._data = null;
        this._fetching = null;
        this.base_url = "https://api.cdnjs.com/libraries";
    }

    static title = "CDN Search";
    static desc = "Search and fetch CDN libraries";

    search() {
        var that = this;
        var url = this.base_url;
        var name = this.getInputOrProperty("name");
        if(name && name!=="") {
            url += "?search="+name;
        }
        this._fetching = fetch(url)
            .then((resp) => {
                if(!resp.ok) {
                    this.boxcolor = "#F00";
                    that.trigger("error");
                }else{
                    this.boxcolor = "#0F0";
                    return resp.text();
                }
            })
            .then((data) => {
                that._data = data;
                that._fetching = null;

                // var libsNames = [];
                // for(var iL in data.results){
                // libsNames.push(data.results[iL]["name"]);
                // }

                if(this._data && typeof(this._data)=="string") {
                    try{
                        this._data = JSON.parse(this._data);
                    }catch(e) {
                        console.warn?.("Not a JSON resp",this._data);
                    }
                }

                if(this._data && typeof(this._data)=="object") {
                    if(this._data.results && this._data.results.length && this._data.results[0]["name"]) {
                        this.setOutputData(1, this._data.results); // array of result libs
                        this.setOutputData(2, this._data.results[0]["name"]);
                        this.setOutputData(3, this._data.results[0]);
                    }else{
                    // no results?
                        this.setOutputData(2, null);
                        this.setOutputData(3, null);
                    }
                }else{
                    this.setOutputData(2, null);
                    this.setOutputData(3, null);
                }
                that.trigger("ready");
            });
    }

    onAction(evt) {
        if(evt == "search")
            this.search();
    }

    onExecute() {
        // this.setOutputData(1, this._data); // "data"
        // if(this._data && typeof(this._data)=="string"){
        //     try{
        //         this._data = JSON.parse(this._data);
        //     }catch(e){
        //         console.warn?.("Not a JSON resp",this._data);
        //     }
        // }
        // if(this._data && typeof(this._data)=="object"){
        //     if(this._data.results && this._data.results.length){
        //         this.setOutputData(2, this._data.results[0]);
        //     }
        // }else{
        //     this.setOutputData(2, null);
        // }
    }

    onGetInputs() {
        return [["name","string"]];
    }

    onGetOutputs() {
        return [["error",LiteGraph.EVENT]];
    }
}
LiteGraph.registerNodeType("libraries/search_CDN_lib", CDNLibSearch);


// CDN LIBRARY LOAD INCLUDE

class CDNLibInclude {

    static title = "CDN Load";
    static desc = "Load and include a CDN library";

    constructor() {
        this.addInput("load", LiteGraph.ACTION);
        this.addInput("lib_spec", "object");
        this.addOutput("ready", LiteGraph.EVENT);
        this.addOutput("error", LiteGraph.EVENT);
        // this.addOutput("error", LiteGraph.EVENT); // in optionals
        // this.addWidget("button", "load", null, this.load.bind(this));
    }

    load() {
        var that = this;
        var lib_spec = this.getInputOrProperty("lib_spec");
        if(lib_spec && typeof(lib_spec)=="object" && lib_spec.latest) {
            var url = lib_spec.latest;

            var script = document.createElement("script");
            script.type = "text/javascript";
            script.onload = function(a) {
                that.on_loaded(lib_spec, a);
            }
            script.onerror = function(e) {
                that.on_error(lib_spec, e);
            }
            script.src = url;
            document.head.appendChild(script);
            // wait for loas
        }
    }

    on_loaded(ob_lib, a) {
        console.debug?.("Loaded library",ob_lib,a);
        if(ob_lib && ob_lib.name) {
            this.trigger("ready");
            libraries_loaded[ob_lib.name] = ob_lib;
            this.boxcolor = "#0F0";
        }else{
            this.on_error(ob_lib);
        }
    }

    on_error(ob_lib, e) {
        this.trigger("error");
        this.boxcolor = "#F00";
        console.warn?.("Lib loading failed",ob_lib,e);
    }

    onAction(evt) {
        if(evt == "load") {
            this.load();
        }
    }

    onExecute() {
        // ?
    }

    onGetInputs() {
        // return [["name","string"]];
    }
    onGetOutputs() {
        // return [["error",LiteGraph.EVENT]];
    }
}
LiteGraph.registerNodeType("libraries/load", CDNLibInclude);



/**
 * will extend a node class creating an html element for it available in this._el_cont, use this._html to set his content
 * @param {object} nodeX
 */
function nodeEmpower_htmlElement(nodeX){
    nodeX.htmlCreateElement = (function(){
        if(this._added) return;
        if(typeof(graphcanvas)!=="undefined" && graphcanvas){
            const htEl = document.createElement("div");
            this._el = htEl;
            this._el.classList.add('lg-html-element');
            this._el.style.position = "absolute";
            // this._el.style.pointerEvents = "";
            graphcanvas.canvas?.parentNode?.appendChild(this._el);
            this._el_cont = document.createElement("div");
            this._el_cont.style.display = "flex";
            // this._el_cont.style.alignItems = "center";
            this._el_cont.style.justifyContent = "center";
            this._el_cont.style.overflow = "auto";
            this._el_cont.style.position = "relative";
            this._el_cont.style.width = "100%";
            this._el_cont.style.height = "100%";
            this._el_cont.style.margin = "0px";
            this._el_cont.style.padding = "0px";
            this._el.appendChild(this._el_cont);
            this._added = true;
            this.htmlRefreshElement();
            const htGraph = graphcanvas.graph;
            graphcanvas.registerCallbackHandler("onOpenSubgraph",function(info, graph, prev_graph){
               // should hide or remove?
                if(htGraph == graph){
                    console.debug("htmlEmpoweredNode","restore on onOpenSubgraph",this,graph);
                    htEl.style.display = htEl.style.display_prev ? htEl.style.display_prev : "block";
                }else{
                    console.debug("htmlEmpoweredNode","hide on onOpenSubgraph",this,graph);
                    htEl.style.display_prev = htEl.style.display;
                    htEl.style.display = "none";
                }
            });
            graphcanvas.registerCallbackHandler("onCloseSubgraph",function(info, graph, prev_graph, subgraph_node){
                // should restore hide or recreate? 
                if(htGraph == graph){
                    console.debug("htmlEmpoweredNode","restore on onCloseSubgraph",this,graph);
                    htEl.style.display = htEl.style.display_prev ? htEl.style.display_prev : "block";
                }else{
                    console.debug("htmlEmpoweredNode","hide on onCloseSubgraph",this,graph);
                    htEl.style.display_prev = htEl.style.display;
                    htEl.style.display = "none";
                }
             });
        }else{
            console.warn(this,"NO CANVAS");
        }
    }).bind(nodeX);
    nodeX.htmlRefreshElement = (function(){
        if(!this._added){
            this.htmlCreateElement();
        }
        if(!this.pos) return;
        if(!this.size) return;
        const absPos = graphcanvas.convertOffsetToCanvas(this.pos);
        this._el.style.left = absPos[0] +"px";
        this._el.style.top = (absPos[1]+this.getSlotsHeight()) +"px";
        this._el.style.width = Math.round(this.size[0]*graphcanvas.ds.scale) +"px";
        this._el.style.height = (Math.round(this.size[1]*graphcanvas.ds.scale)-this.getSlotsHeight()) +"px";
    }).bind(nodeX);
    nodeX.setHtml = function(html){
        this._html = html;
        if(!this._el||!this._el_cont) this.htmlRefreshElement();
        this._el_cont.innerHTML = this._html;
    }
    nodeX.registerCallbackHandler("onConfigure",function(info){
        console.info("empoweredHtmlNode",this,"onConfigure",...arguments);
        console.info(this, "configure", info);
        this.refreshSlots();
        this.htmlRefreshElement();
    });
    nodeX.registerCallbackHandler("onDrawForeground",function(){
        // console.info("empoweredHtmlNode",this,"onDrawForeground",...arguments);
        this.htmlRefreshElement();
    });
    nodeX.registerCallbackHandler("onSelected",function(){
        console.info("empoweredHtmlNode",this,"onSelected",...arguments);
        // if(this._el) this._el.style.pointerEvents = "none";
    });
    nodeX.registerCallbackHandler("onDeselected",function(){
        console.info("empoweredHtmlNode",this,"onDeselected",...arguments);
        // if(this._el) this._el.style.pointerEvents = "";
    });
    nodeX.registerCallbackHandler("onRemoved",function(){
        console.info("empoweredHtmlNode",this,"onRemoved",...arguments);
        this._el?.parentNode?.removeChild(this._el);
    });
}

class DOMSelector {

    static title = "DOMSelector";
    static desc = "Execute a selection query on the document returning the corresponging DOM element";

    constructor() {
        this.addInput("selector", "string");
        this.addOutput("result", "htmlelement");
        this.properties = { };
    }

    onExecute() {
        var sSel = this.getInputData(0);
        var res = null;
        if (sSel) {
            try{
                res = document.querySelector(sSel);
            }catch(e) {
                res = false;
            }
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/dom_selector", DOMSelector);

class HtmlNode {

    static title = "Html Node";
    static desc = "Have html inside a node";

    constructor() {
        this.addInput("html", "html");
        this.addOutput("element", "htmlelement");
        this.properties = { html: "" }; // scale_content: false
        this._added = false;
        this._html = "";
        this.size = [210, 210/1.618];
    }
    refreshSlots(){
        this.htmlRefreshElement?.();
        var sHtml = this.getInputData(0);
        if (sHtml) {
            try{
                this.setHtml?.(sHtml); // this._html = sHtml;
            }catch(e) {
                console.log(this, "failed setting html content");
                this.setHtml?.(""); // this._html = "";
            }
        }else{
            this.setHtml?.(""); // this._html = "";
        }
        this.setOutputData(0,this._el_cont?this._el_cont:false);
    }
    onPropertyChanged(){
        this.refreshSlots();
    }
    onExecute() {
        this.refreshSlots();
    }
    onPostConstruct(){
        nodeEmpower_htmlElement(this);
    }
}
LiteGraph.registerNodeType("html/node_html", HtmlNode);

class JsonViewerNode{
    static title = "Json View";
    static desc = "Show and navigate a value structure";
    constructor() {
        this.addInput("value", 0);
        this.properties = { html: "" }; // scale_content: false
        this._added = false;
        this._html = "";
        this.size = [210, 210/1.618];
    }
    onPostConstruct(){
        nodeEmpower_htmlElement(this);
    }
    refreshSlots(){
        this.htmlRefreshElement?.();
        var sHtml = htmlJsonViewerHelper(this.getInputData(0));
        if (sHtml) {
            try{
                this.setHtml?.(sHtml); // this._html = sHtml;
                // this._el_cont.innerHTML = sHtml;
            }catch(e) {
                this.setHtml?.("");
                console.log(this, "failed setting html content");
            }
        }else{
            this.setHtml?.("");
        }
        this.setOutputData(0,this._el_cont?this._el_cont:false);
    }
    onPropertyChanged(){
        this.refreshSlots();
    }
    onExecute() {
        this.refreshSlots();
    }
}
LiteGraph.registerNodeType("html/json_viewer", JsonViewerNode);
// helper function 
function htmlJsonViewerHelper(json, collapsible=false) {
    var TEMPLATES = {
        item:   '<div class="json__item">'
                    +'<div class="json__key">%KEY%</div>'
                    +'<div class="json__value json__value--%TYPE%">%VALUE%</div>'
                +'</div>',
        itemCollapsible:    '<label class="json__item json__item--collapsible">'
                                +'<input type="checkbox" class="json__toggle"/><div class="json__key">%KEY%</div>'
                                +'<div class="json__value json__value--type-%TYPE%">%VALUE%</div>'
                                +'%CHILDREN%'
                            +'</label>',
        itemCollapsibleOpen:    '<label class="json__item json__item--collapsible">'
                                    +'<input type="checkbox" checked class="json__toggle"/><div class="json__key">%KEY%</div>'
                                    +'<div class="json__value json__value--type-%TYPE%">%VALUE%</div>'
                                    +'%CHILDREN%'
                                +'</label>'
    };
    function createItem(key, value, type){
        var element = TEMPLATES.item.replace('%KEY%', key);
        if(type == 'string') {
            element = element.replace('%VALUE%', '"' + value + '"');
        } else {
            element = element.replace('%VALUE%', value);
        }
        element = element.replace('%TYPE%', type);
        return element;
    }
    function createCollapsibleItem(key, value, type, children){
        var tpl = 'itemCollapsible';   
        if(collapsible) {
            tpl = 'itemCollapsibleOpen';
        }
        var element = TEMPLATES[tpl].replace('%KEY%', key);
        element = element.replace('%VALUE%', type);
        element = element.replace('%TYPE%', type);
        element = element.replace('%CHILDREN%', children);
        return element;
    }
    function handleChildren(key, value, type) {
        var html = '';
        for(var item in value) { 
            var _key = item,
                _val = value[item];
            html += handleItem(_key, _val);
        }
        return createCollapsibleItem(key, value, type, html);
    }

    function handleItem(key, value) {
        var type = typeof value;
        if(typeof value === 'object') {        
            return handleChildren(key, value, type);
        }
        return createItem(key, value, type);
    }

    function parseObject(obj) {
        var _result = '<div class="html__json">';
        for(var item in obj) { 
            var key = item,
                value = obj[item];

            _result += handleItem(key, value);
        }
        _result += '</div>';
        return _result;
    }
    return parseObject(json);
}



class DOMSelectorAll {

    static title = "DOMSelectorAll";
    static desc = "Execute a querySelectorAll() on the document returning the corresponding Elements";

    constructor() {
        this.addInput("selector", "string");
        this.addOutput("result", "array");
        this.properties = { };
    }

    onExecute() {
        var sSel = this.getInputData(0);
        var res = null;
        if (sSel) {
            res = document.querySelectorAll(sSel);
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/dom_selector_all", DOMSelectorAll);


class HtmlEventListener {

    static title = "HTML Listener";
    static desc = "Add an event listener on an html element";

    constructor() {
        this.addInput("element", "htmlelement");
        this.addInput("add_listener", LiteGraph.ACTION);
        this.addOutput("listener", "htmlelement_listener");
        this.addOutput("on_event", LiteGraph.EVENT);
        this.addOutput("last_event", "");
        this.addOutput("current_event", "");
        this.addProperty("eventType", "");
        this.addWidget("combo","eventType",this.properties["eventType"],"eventType",{values: ["click","dblclick", "mouseover","mousedown","mouseup","mousemove","mouseout","keydown","keyup","keypress","load","unload","mousewheel","contextmenu", "focus","change","blur","pointerdown","pointerup","pointermove","pointerover","pointerout","pointerenter","pointerleave","pointercancel","gotpointercapture","lostpointercapture", "touchstart","touchmove","touchend","touchcancel","submit","scroll","resize","hashchange"]});
        // this.properties = {eventType: "" };
        this.mode = LiteGraph.ON_ACTION;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        } else this.setOutputData(3,null);
    }

    onAction(action) {
        var sSel = this.getInputData(0);
        var eventType = this.getInputOrProperty("eventType");
        var res = null;
        if (sSel && eventType && sSel.addEventListener) {
            switch(action) {
                case "add_listener":
                default:
                    var fEv;
                    if ( ! sSel.attributes["data-listener-"+eventType] ) {
                        var that = this;
                        fEv = function(e) {
                            that.setOutputData(2,e);
                            that.setOutputData(3,e);
                            that.triggerSlot(1);
                        }
                        sSel.addEventListener(eventType, fEv);
                        sSel.attributes["data-listener-"+eventType] = fEv;
                    }else{
                        fEv = sSel.attributes["data-listener-"+eventType];
                    }
                    res = {element: sSel, function: fEv, event: eventType};
                    break;
            }
        }else{
            console.log?.("no el to add event");
            // this.setOutputData(2,null); // clean ?
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/event_listener", HtmlEventListener);


class HtmlEventListenerRemove {

    static title = "HTML Remove Listener";
    static desc = "Remove an event listener by passing his reference";

    constructor() {
        this.addInput("listener", "htmlelement_listener");
        this.addInput("remove_listener", LiteGraph.ACTION);
        this.addOutput("result","boolean");
        this.mode = LiteGraph.ON_ACTION;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        }
    }

    onAction() {
        var oLis = this.getInputData(0);
        var res = false;
        if (oLis && oLis.element && oLis.function && oLis.event && oLis.element.removeEventListener) {
            oLis.element.attributes["data-listener-"+oLis.event] = false;
            oLis.element.removeEventListener(oLis.event, oLis.function);
            res = true;
        }else{
            console.log?.("bad element to remove listener");
        }
        this.setOutputData(0,res);
    }
    // HtmlEventListenerRemove.prototype.onAction = function(action, param, options){}
}
LiteGraph.registerNodeType("html/event_listener_remove", HtmlEventListenerRemove);


class HtmlValue {

    static title = "HTML GET Value";
    static desc = "Get the value (or the text content) of an HTML element";

    constructor() {
        this.addInput("element", "htmlelement");
        // this.addInput("get", LiteGraph.ACTION);
        this.addOutput("result","string");
        // this.mode = LiteGraph.ON_ACTION;
    }

    onExecute() {
        var el = this.getInputData(0);
        var res = false;
        if (el) {
            if(typeof el == "object") {
                if (typeof el.value != "undefined") {
                    res = el.value;
                }else if(typeof el.checked != "undefined") { // el.constructor.name == "HTMLInputElement" && ..
                    res = el.checked?true:false;
                }else if(typeof el.textContent != "undefined") {
                    res = el.textContent;
                }else{
                    res = "";
                }
                /* switch(el.constructor.name){
                }*/
            }
        }else{
            // console.log?.("no element to get value");
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/element_value", HtmlValue);


class HtmlValueSet {

    static title = "HTML SET Value";
    static desc = "Set the value (or the text content) of an HTML element";

    constructor() {
        this.addInput("element", "htmlelement");
        // this.addInput("set", LiteGraph.ACTION);
        this.addInput("value", "string");
        this.addOutput("result","boolean");
        this.addProperty("value","");
        // this.mode = LiteGraph.ON_ACTION;
    }

    onExecute() {
        // if (this.mode == LiteGraph.ON_TRIGGER) this.onAction(action, param, options);
        var el = this.getInputData(0);
        var sVal = this.getInputOrProperty("value"); // getInputData(1);
        var res = false;
        if (el) {
            if(typeof el == "object") {
                if (typeof el.value != "undefined") {
                    el.value = sVal+"";
                    res = true;
                }else if(typeof el.checked != "undefined") {
                    el.checked = sVal?true:false;
                    res = true;
                }else if(typeof el.textContent != "undefined") {
                    el.textContent = sVal+"";
                    res = true;
                }else{
                    console.log?.("unkonwn element to set value");
                }
                /* switch(el.constructor.name){
                }*/
            }
        }else{
            // console.log?.("no element to set value");
        }
        this.setOutputData(0,res);
    }
}
// HtmlValueSet.prototype.onAction = function(action, param, options){
LiteGraph.registerNodeType("html/element_value_set", HtmlValueSet);


class HtmlCreateElement {

    static title = "HTML Create El";
    static desc = "Create an HTML element";

    constructor() {
        this.addInput("create", LiteGraph.ACTION);
        this.addInput("type", "string");
        this.addInput("content", "html");
        this.addInput("id", "string");
        this.addInput("class", "string");
        this.addOutput("element","htmlelement");
        this.addProperty("type", "");
        this.addProperty("content", "");
        this.addProperty("id", "");
        this.addProperty("class", "");
        this.addWidget("combo","type",this.properties["type"],"type",{values: ["div","a","span","input","form","br","hr","table","th","tr","td","h1","h2","h3","h4","h5","h6"]});
        this.mode = LiteGraph.ON_ACTION;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        }
    }

    onAction() {
        var sType = this.getInputOrProperty("type"); // this.getInputData(1);
        var sId = this.getInputOrProperty("id"); // getInputData(2);
        var sClass = this.getInputOrProperty("class"); // getInputData(3);
        var sContent = this.getInputOrProperty("class"); // getInputData(3);
        var res = null;
        if (sType) {
            var el = document.createElement(sType);
            if (el) {
                if (sId) el.id = sId+"";
                if (sClass) el.className = sClass+"";
                if (sContent) el.innerHTML = sContent+"";
                res = el;
            }
        }else{
            // console.log?.("no type to create");
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/create_element", HtmlCreateElement);


class HtmlAppendChild {

    static title = "HTML Append Child";
    static desc = "Append an HTML element to another";

    constructor() {
        this.addInput("parent", "htmlelement");
        this.addInput("child", "htmlelement");
        this.addInput("add", LiteGraph.ACTION);
        this.addOutput("result","");
        this.mode = LiteGraph.ON_ACTION;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        }
    }

    onAction() {
        var parent = this.getInputData(0);
        var child = this.getInputData(1);
        var res = null;
        if (parent && child && parent.appendChild) {
            res = parent.appendChild(child)?true:false;
        }else{
            // console.log?.("no type to create");
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/append_child", HtmlAppendChild);


class HtmlRemoveElement {

    static title = "HTML Remove element";
    static desc = "Remove an HTML element";

    constructor() {
        this.addInput("element", "htmlelement");
        this.addInput("remove", LiteGraph.ACTION);
        this.addOutput("result","");
        this.mode = LiteGraph.ON_ACTION;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        }
    }

    onAction() {
        var element = this.getInputData(0);
        var res = null;
        if (element && element.remove) {
            res = element.remove()?true:false;
        }else{
            // console.log?.("no type to create");
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/remove_element", HtmlRemoveElement);


class HtmlElementStyle {

    static title = "HTML Css";
    static desc = "HTML Element apply Css Style";

    constructor() {
        this.addInput("element", "htmlelement");
        this.addInput("apply", LiteGraph.ACTION);
        this.addProperty("cssProperty", "");
        this.addProperty("cssValue", "");
        this.addOutput("result","");
        this.mode = LiteGraph.ON_ACTION;
    }

    static commonProperties = [{"property": "box-decoration-break","values": null},{"property": "hyphens","values": null},{"property": "line-break","values": null},{"property": "overflow-wrap","values": null},{"property": "text-combine-upright","values": null},{"property": "text-underline-position","values": null},{"property": "@font-feature-values","values": null},{"property": "font-feature-settings","values": null},{"property": "font-kerning","values": null},{"property": "font-language-override","values": null},{"property": "font-synthesis","values": null},{"property": "font-variant-alternates","values": null},{"property": "font-variant-caps","values": null},{"property": "font-variant-east-asian","values": null},{"property": "font-variant-ligatures","values": null},{"property": "font-variant-numeric","values": null},{"property": "font-variant-position","values": null},{"property": "text-orientation","values": null},{"property": "text-combine-upright","values": null},{"property": "writing-mode","values": null},{"property": "ime-mode","values": null},{"property": "break-after","values": null},{"property": "break-before","values": null},{"property": "break-inside","values": null},{"property": "widows","values": null},{"property": "orphans","values": null},{"property": "marks","values": null},{"property": "image-orientation","values": null},{"property": "image-rendering","values": null},{"property": "image-resolution","values": null},{"property": "object-fit","values": null},{"property": "object-position","values": null},{"property": "mask","values": null},{"property": "mask-type","values": null},{"property": "mark","values": null},{"property": "mark-after","values": null},{"property": "mark-before","values": null},{"property": "phonemes","values": null},{"property": "rest","values": null},{"property": "rest-after","values": null},{"property": "rest-before","values": null},{"property": "voice-balance","values": null},{"property": "voice-duration","values": null},{"property": "voice-pitch","values": null},{"property": "voice-pitch-range","values": null},{"property": "voice-rate","values": null},{"property": "voice-stress","values": null},{"property": "voice-volume","values": null},{"property": "marquee-direction","values": null},{"property": "marquee-play-count","values": null},{"property": "marquee-speed","values": null},{"property": "marquee-style","values": null},{"property": "color","values": ["color","initial","inherit"]},{"property": "opacity","values": ["number","initial","inherit"]},{"property": "background-position","values": ["left top\r\n      left center\r\n      left bottom\r\n      right top\r\n      right center\r\n      right bottom\r\n      center top\r\n      center center\r\n      center bottom","x% y%","xpos ypos","initial","inherit"]},{"property": "background-image","values": ["url('URL')","none","initial","inherit"]},{"property": "background-color","values": ["color","transparent","initial","inherit"]},{"property": "border","values": ["border-width","border-style","border-color","initial","inherit"]},{"property": "word-wrap","values": ["normal","break-word","initial","inherit"]},{"property": "direction","values": ["ltr","rtl","initial","inherit"]},{"property": "unicode-bidi","values": ["normal","embed","bidi-override","initial","inherit"]},{"property": "font-size","values": ["medium","xx-small","x-small","small","large","x-large","xx-large","smaller","larger","length","%","initial","inherit"]},{"property": "text-decoration-line","values": ["none","underline","overline","line-through","initial","inherit"]},{"property": "border-collapse","values": ["separate","collapse","initial","inherit"]},{"property": "background-size","values": ["auto","length","percentage"," cover"," contain","initial","inherit"]},{"property": "list-style-type","values": ["disc","armenian","circle","cjk-ideographic","decimal","decimal-leading-zero","georgian","hebrew","hiragana","hiragana-iroha","katakana","katakana-iroha","lower-alpha","lower-greek","lower-latin","lower-roman","none","square","upper-alpha","upper-latin","upper-roman","initial","inherit"]},{"property": "@keyframes","values": ["animationname","keyframes-selector","css-styles"]},{"property": "border-top-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "background-blend-mode","values": ["normal","multiply","screen","overlay","darken","lighten","color-dodge","saturation","color","luminosity"]},{"property": "background-repeat","values": ["repeat","repeat-x","repeat-y","no-repeat","initial","inherit"]},{"property": "background-clip","values": ["border-box","padding-box","content-box","initial","inherit"]},{"property": "animation-direction","values": ["normal","reverse","alternate","alternate-reverse","initial","inherit"]},{"property": "animation-duration","values": ["time","initial","inherit"]},{"property": "counter-reset","values": ["none","name","number","initial","inherit"]},{"property": "padding-left","values": ["length","%","initial","inherit"]},{"property": "border-bottom-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "list-style","values": ["list-style-type","list-style-position","list-style-image","initial","inherit"]},{"property": "counter-increment","values": ["none","id number","initial","inherit"]},{"property": "align-self","values": ["auto","stretch","center","flex-start","flex-end","baseline","initial","inherit"]},{"property": "min-height","values": ["length","%","initial","inherit"]},{"property": "visibility","values": ["visible","hidden","collapse","initial","inherit"]},{"property": "max-height","values": ["none","length","%","initial","inherit"]},{"property": "position","values": ["static","absolute","fixed","relative","initial","inherit"]},{"property": "border-left-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-image-outset","values": ["length"," number","initial","inherit"]},{"property": "overflow-x","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "border-left-color","values": ["color","transparent","initial","inherit"]},{"property": "quotes","values": ["none","string string string string","initial","inherit","","\"","'","","","«","»","","","","",""]},{"property": "perspective-origin","values": ["x-axis","y-axis","initial","inherit"]},{"property": "flex","values": ["flex-grow","flex-shrink","flex-basis","auto","initial","none","inherit"]},{"property": "border-image","values": [" border-image-source"," border-image-slice"," border-image-width"," border-image-outset"," border-image-repeat","initial","inherit"]},{"property": "animation-delay","values": ["time","initial","inherit"]},{"property": "border-color","values": ["color","transparent","initial","inherit"]},{"property": "clear","values": ["none","left","right","both","initial","inherit"]},{"property": "border-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "overflow\r\n    ","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "column-rule-color","values": [" color","initial","inherit"]},{"property": "border-right-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-image-source","values": [" none"," image","initial","inherit"]},{"property": "background-attachment","values": ["scroll","fixed","local","initial","inherit"]},{"property": "border-right","values": ["border-right-width","border-right-style","border-right-color","initial","inherit"]},{"property": "margin-right","values": ["length","%","auto","initial","inherit"]},{"property": "border-bottom","values": ["border-bottom-width","border-bottom-style","border-bottom-color","initial","inherit"]},{"property": "border-right-color","values": ["color","transparent","initial","inherit"]},{"property": "margin-top","values": ["length","%","auto","initial","inherit"]},{"property": "border-radius","values": ["length","%","initial","inherit"]},{"property": "max-width","values": ["none","length","%","initial","inherit"]},{"property": "min-width","values": ["length","%","initial","inherit"]},{"property": "z-index","values": ["auto","number","initial","inherit"]},{"property": "border-bottom-left-radius","values": ["length","%","initial","inherit"]},{"property": "text-transform","values": ["none","capitalize","uppercase","lowercase","initial","inherit"]},{"property": "text-indent","values": ["length","%","initial","inherit"]},{"property": "text-justify","values": ["auto","inter-word","inter-ideograph","inter-cluster","distribute","kashida","trim","none","initial","inherit"]},{"property": "text-align","values": ["left","right","center","justify","initial","inherit"]},{"property": "border-bottom-color","values": ["color","transparent","initial","inherit"]},{"property": "background","values": ["background-color","background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","initial","inherit"]},{"property": "letter-spacing","values": ["normal","length","initial","inherit"]},{"property": "align-items","values": ["stretch","center","flex-start","flex-end","baseline","initial","inherit"]},{"property": "tab-size","values": ["number","length","initial","inherit"]},{"property": "flex-wrap","values": ["nowrap","wrap","wrap-reverse","initial","inherit"]},{"property": "flex-direction","values": ["row","row-reverse","column","column-reverse","initial","inherit"]},{"property": "flex-basis","values": ["number","auto","initial","inherit"]},{"property": "flex-shrink","values": ["number","initial","inherit"]},{"property": "bottom","values": ["auto","length","%","initial","inherit"]},{"property": "clip","values": ["auto","shape","initial","inherit"]},{"property": "flex-grow","values": ["number","initial","inherit"]},{"property": "font","values": ["font-style","font-variant","font-weight","font-size/line-height","font-family","caption","icon","menu","message-box","small-caption","status-bar","initial","inherit"]},{"property": "margin-left","values": ["length","%","auto","initial","inherit"]},{"property": "text-decoration-color","values": ["color","initial","inherit"]},{"property": "border-bottom-right-radius","values": ["length","%","initial","inherit"]},{"property": "list-style-position","values": ["inside","outside","initial","inherit"]},{"property": "top","values": ["auto","length","%","initial","inherit"]},{"property": "right","values": ["auto","length","%","initial","inherit"]},{"property": "background-origin","values": ["padding-box","border-box","content-box","initial","inherit"]},{"property": "table-layout","values": ["auto","fixed","initial","inherit"]},{"property": "margin-bottom","values": ["length","%","auto","initial","inherit"]},{"property": "padding-bottom","values": ["length","%","initial","inherit"]},{"property": "border-image-slice","values": [" number"," %"," fill","initial","inherit"]},{"property": "flex-flow","values": ["flex-direction","flex-wrap","initial","inherit"]},{"property": "float","values": ["none","left","right","initial","inherit"]},{"property": "vertical-align","values": ["baseline","length","%","sub","super","top","text-top","middle","bottom","text-bottom","initial","inherit"]},{"property": "padding-right","values": ["length","%","initial","inherit"]},{"property": "width","values": ["auto","length","%","initial","inherit"]},{"property": "align-content","values": ["stretch","center","flex-start","flex-end","space-between","space-around","initial","inherit"]},{"property": "padding","values": ["length","%","initial","inherit"]},{"property": "hanging-punctuation","values": ["none","first","last","allow-end","force-end","initial","inherit"]},{"property": "border-bottom-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-left-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "text-align-last","values": ["auto","left","right","center","justify","start","end","initial","inherit"]},{"property": "order","values": ["number","initial","inherit"]},{"property": "border-top-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-top-color","values": ["color","transparent","initial","inherit"]},{"property": "display","values": ["inline","block","flex","inline-block","inline-flex","inline-table","list-item","run-in","table","table-caption","\r\n      table-column-group","table-header-group","table-footer-group","table-row-group","table-cell","table-column","table-row","none","initial","inherit"]},{"property": "left","values": ["auto","length","%","initial","inherit"]},{"property": "border-top-left-radius","values": ["length","%","initial","inherit"]},{"property": "margin","values": ["length","%","auto","initial","inherit"]},{"property": "border-image-repeat","values": [" stretch"," repeat"," round","space","initial","inherit"]},{"property": "box-shadow","values": ["none","h-shadow","v-shadow","blur","spread","color","inset","initial","inherit"]},{"property": "border-top-right-radius","values": ["length","%","initial","inherit"]},{"property": "text-decoration-style","values": ["solid","double","dotted","dashed","wavy","initial","inherit"]},{"property": "height","values": ["auto","length","%","initial","inherit"]},{"property": "border-right-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-left","values": ["border-left-width","border-left-style","border-left-color","initial","inherit"]},{"property": "border-image-width","values": ["length","number","%","auto","initial","inherit"]},{"property": "font-family","values": ["family-name\r\n      generic-family","initial","inherit"]},{"property": "border-top","values": ["border-top-width","border-top-style","border-top-color","initial","inherit"]},{"property": "empty-cells","values": ["show","hide","initial","inherit"]},{"property": "justify-content","values": ["flex-start","flex-end","center","space-between","space-around","initial","inherit"]},{"property": "text-shadow","values": ["h-shadow","v-shadow","blur-radius","color","none","initial","inherit"]},{"property": "overflow-y","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "padding-top","values": ["length","%","initial","inherit"]},{"property": "border-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-spacing","values": ["length length","initial","inherit"]},{"property": "word-break","values": ["normal","break-all","keep-all ","initial","inherit"]},{"property": "@font-face","values": ["font-family","src","font-stretch","font-style","font-weight","unicode-range"]},{"property": "text-decoration","values": ["none","underline","overline","line-through","initial","inherit"]},{"property": "white-space","values": ["normal","nowrap","pre","pre-line","pre-wrap","initial","inherit"]},{"property": "font-size-adjust","values": ["number","none","initial","inherit"]},{"property": "font-style","values": ["normal","italic","oblique","initial","inherit"]},{"property": "line-height","values": ["normal","number","length","%","initial","inherit"]},{"property": "font-weight","values": ["normal","bold","bolder","lighter","100\r\n      200\r\n      300\r\n      400\r\n      500\r\n      600\r\n      700\r\n      800\r\n      900","initial","inherit"]},{"property": "word-spacing","values": ["normal","length","initial","inherit"]},{"property": "page-break-after","values": ["auto","always","avoid","left","right","initial","inherit"]},{"property": "outline-color","values": ["invert","color","initial","inherit"]},{"property": "column-gap","values": ["length","normal","initial","inherit"]},{"property": "column-rule","values": [" column-rule-width"," column-rule-style"," column-rule-color","initial","inherit"]},{"property": "columns","values": ["auto","column-width","column-count","initial","inherit"]},{"property": "column-rule-style","values": [" none"," hidden"," dotted"," dashed"," solid"," double"," groove"," ridge"," inset"," outset","initial","inherit"]},{"property": "font-variant","values": ["normal","small-caps","initial","inherit"]},{"property": "column-rule-width","values": [" medium"," thin"," thick"," length","initial","inherit"]},{"property": "cursor","values": ["alias","all-scroll","auto","cell","context-menu","col-resize","copy","crosshair","default","e-resize","ew-resize","grab","grabbing","help","move","n-resize","ne-resize","nesw-resize","ns-resize","nw-resize","nwse-resize","no-drop","none","not-allowed","pointer","progress","row-resize","s-resize","se-resize","sw-resize","text","URL","vertical-text","w-resize","wait","zoom-in","zoom-out","initial","inherit"]},{"property": "column-fill","values": ["balance","auto","initial","inherit"]},{"property": "animation-fill-mode","values": ["none","forwards","backwards","both","initial","inherit"]},{"property": "nav-left","values": ["auto","id","target-name","initial","inherit"]},{"property": "outline-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "nav-right","values": ["auto","id","target-name","initial","inherit"]},{"property": "nav-up","values": ["auto","id","target-name","initial","inherit"]},{"property": "nav-down","values": ["auto","id","target-name","initial","inherit"]},{"property": "outline","values": ["outline-color","outline-style","outline-width","initial","inherit"]},{"property": "animation","values": ["animation-name","animation-duration","\r\n\tanimation-timing-function","animation-delay","\r\n\tanimation-iteration-count","animation-direction","animation-fill-mode","animation-play-state","initial","inherit"]},{"property": "nav-index","values": ["auto","number","initial","inherit"]},{"property": "font-stretch","values": ["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded","initial","inherit"]},{"property": "list-style-image","values": ["none","url","initial","inherit"]},{"property": "transition-duration","values": ["time","initial","inherit"]},{"property": "perspective","values": ["length","none","initial","inherit"]},{"property": "animation-play-state","values": ["paused","running","initial","inherit"]},{"property": "backface-visibility","values": ["visible","hidden","initial","inherit"]},{"property": "column-count","values": ["number","auto","initial","inherit"]},{"property": "transition-delay","values": ["time","initial","inherit"]},{"property": "transform","values": ["none","matrix(n,n,n,n,n,n)","matrix3d\r\n\t(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)","translate(x,y)","translate3d(x,y,z)","translateX(x)","translateY(y)","translateZ(z)","scale(x,y)","scale3d(x,y,z)","scaleX(x)","scaleY(y)","scaleZ(z)","rotate(angle)","rotate3d(x,y,z,angle)","rotateX(angle)","rotateY(angle)","rotateZ(angle)","skew(x-angle,y-angle)","skewX(angle)","skewY(angle)","perspective(n)","initial","inherit"]},{"property": "resize","values": [" none"," both"," horizontal"," vertical","initial","inherit"]},{"property": "text-overflow","values": ["clip","ellipsis","string","initial","inherit"]},{"property": "caption-side","values": ["top","bottom","initial","inherit"]},{"property": "filter","values": ["none","blur(px)","brightness(%)","contrast(%)","drop-shadow(h-shadow v-shadow blur spread color)","grayscale(%)","hue-rotate(deg)","invert(%)","opacity(%)","saturate(%)","sepia(%)","url()","initial","inherit"]},{"property": "content","values": ["normal","none","counter","attr(attribute)","string","open-quote","close-quote","no-open-quote","no-close-quote","url(url)","initial","inherit"]},{"property": "transition-timing-function","values": ["ease","linear","ease-in","ease-out","ease-in-out","cubic-bezier(n,n,n,n)","initial","inherit"]},{"property": "box-sizing","values": [" content-box"," border-box","initial","inherit"]},{"property": "page-break-before","values": ["auto","always","avoid","left","right","initial","inherit"]},{"property": "animation-timing-function","values": ["linear","ease","ease-in","ease-out","ease-in-out","cubic-bezier(n,n,n,n)","initial","inherit"]},{"property": "outline-offset","values": [" length","initial","inherit"]},{"property": "column-width","values": ["auto","length","initial","inherit"]},{"property": "outline-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "transform-origin","values": ["x-axis","y-axis","z-axis","initial","inherit"]},{"property": "transform-style","values": ["flat","preserve-3d","initial","inherit"]},{"property": "transition","values": ["transition-property","transition-duration","transition-timing-function","transition-delay","initial","inherit"]},{"property": "page-break-inside","values": ["auto","avoid","initial","inherit"]},{"property": "column-span","values": ["1","all","initial","inherit"]},{"property": "transition-property","values": ["none","all","property","initial","inherit"]},{"property": "animation-iteration-count","values": ["number","infinite","initial","inherit"]},{"property": "animation-name","values": ["keyframename","none","initial","inherit"]}][{"property": "box-decoration-break","values": null},{"property": "hyphens","values": null},{"property": "line-break","values": null},{"property": "overflow-wrap","values": null},{"property": "text-combine-upright","values": null},{"property": "text-underline-position","values": null},{"property": "@font-feature-values","values": null},{"property": "font-feature-settings","values": null},{"property": "font-kerning","values": null},{"property": "font-language-override","values": null},{"property": "font-synthesis","values": null},{"property": "font-variant-alternates","values": null},{"property": "font-variant-caps","values": null},{"property": "font-variant-east-asian","values": null},{"property": "font-variant-ligatures","values": null},{"property": "font-variant-numeric","values": null},{"property": "font-variant-position","values": null},{"property": "text-orientation","values": null},{"property": "text-combine-upright","values": null},{"property": "writing-mode","values": null},{"property": "ime-mode","values": null},{"property": "break-after","values": null},{"property": "break-before","values": null},{"property": "break-inside","values": null},{"property": "widows","values": null},{"property": "orphans","values": null},{"property": "marks","values": null},{"property": "image-orientation","values": null},{"property": "image-rendering","values": null},{"property": "image-resolution","values": null},{"property": "object-fit","values": null},{"property": "object-position","values": null},{"property": "mask","values": null},{"property": "mask-type","values": null},{"property": "mark","values": null},{"property": "mark-after","values": null},{"property": "mark-before","values": null},{"property": "phonemes","values": null},{"property": "rest","values": null},{"property": "rest-after","values": null},{"property": "rest-before","values": null},{"property": "voice-balance","values": null},{"property": "voice-duration","values": null},{"property": "voice-pitch","values": null},{"property": "voice-pitch-range","values": null},{"property": "voice-rate","values": null},{"property": "voice-stress","values": null},{"property": "voice-volume","values": null},{"property": "marquee-direction","values": null},{"property": "marquee-play-count","values": null},{"property": "marquee-speed","values": null},{"property": "marquee-style","values": null},{"property": "color","values": ["color","initial","inherit"]},{"property": "opacity","values": ["number","initial","inherit"]},{"property": "background-position","values": ["left top\r\n      left center\r\n      left bottom\r\n      right top\r\n      right center\r\n      right bottom\r\n      center top\r\n      center center\r\n      center bottom","x% y%","xpos ypos","initial","inherit"]},{"property": "background-image","values": ["url('URL')","none","initial","inherit"]},{"property": "background-color","values": ["color","transparent","initial","inherit"]},{"property": "border","values": ["border-width","border-style","border-color","initial","inherit"]},{"property": "word-wrap","values": ["normal","break-word","initial","inherit"]},{"property": "direction","values": ["ltr","rtl","initial","inherit"]},{"property": "unicode-bidi","values": ["normal","embed","bidi-override","initial","inherit"]},{"property": "font-size","values": ["medium","xx-small","x-small","small","large","x-large","xx-large","smaller","larger","length","%","initial","inherit"]},{"property": "text-decoration-line","values": ["none","underline","overline","line-through","initial","inherit"]},{"property": "border-collapse","values": ["separate","collapse","initial","inherit"]},{"property": "background-size","values": ["auto","length","percentage"," cover"," contain","initial","inherit"]},{"property": "list-style-type","values": ["disc","armenian","circle","cjk-ideographic","decimal","decimal-leading-zero","georgian","hebrew","hiragana","hiragana-iroha","katakana","katakana-iroha","lower-alpha","lower-greek","lower-latin","lower-roman","none","square","upper-alpha","upper-latin","upper-roman","initial","inherit"]},{"property": "@keyframes","values": ["animationname","keyframes-selector","css-styles"]},{"property": "border-top-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "background-blend-mode","values": ["normal","multiply","screen","overlay","darken","lighten","color-dodge","saturation","color","luminosity"]},{"property": "background-repeat","values": ["repeat","repeat-x","repeat-y","no-repeat","initial","inherit"]},{"property": "background-clip","values": ["border-box","padding-box","content-box","initial","inherit"]},{"property": "animation-direction","values": ["normal","reverse","alternate","alternate-reverse","initial","inherit"]},{"property": "animation-duration","values": ["time","initial","inherit"]},{"property": "counter-reset","values": ["none","name","number","initial","inherit"]},{"property": "padding-left","values": ["length","%","initial","inherit"]},{"property": "border-bottom-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "list-style","values": ["list-style-type","list-style-position","list-style-image","initial","inherit"]},{"property": "counter-increment","values": ["none","id number","initial","inherit"]},{"property": "align-self","values": ["auto","stretch","center","flex-start","flex-end","baseline","initial","inherit"]},{"property": "min-height","values": ["length","%","initial","inherit"]},{"property": "visibility","values": ["visible","hidden","collapse","initial","inherit"]},{"property": "max-height","values": ["none","length","%","initial","inherit"]},{"property": "position","values": ["static","absolute","fixed","relative","initial","inherit"]},{"property": "border-left-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-image-outset","values": ["length"," number","initial","inherit"]},{"property": "overflow-x","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "border-left-color","values": ["color","transparent","initial","inherit"]},{"property": "quotes","values": ["none","string string string string","initial","inherit","","\"","'","","","«","»","","","","",""]},{"property": "perspective-origin","values": ["x-axis","y-axis","initial","inherit"]},{"property": "flex","values": ["flex-grow","flex-shrink","flex-basis","auto","initial","none","inherit"]},{"property": "border-image","values": [" border-image-source"," border-image-slice"," border-image-width"," border-image-outset"," border-image-repeat","initial","inherit"]},{"property": "animation-delay","values": ["time","initial","inherit"]},{"property": "border-color","values": ["color","transparent","initial","inherit"]},{"property": "clear","values": ["none","left","right","both","initial","inherit"]},{"property": "border-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "overflow\r\n    ","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "column-rule-color","values": [" color","initial","inherit"]},{"property": "border-right-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-image-source","values": [" none"," image","initial","inherit"]},{"property": "background-attachment","values": ["scroll","fixed","local","initial","inherit"]},{"property": "border-right","values": ["border-right-width","border-right-style","border-right-color","initial","inherit"]},{"property": "margin-right","values": ["length","%","auto","initial","inherit"]},{"property": "border-bottom","values": ["border-bottom-width","border-bottom-style","border-bottom-color","initial","inherit"]},{"property": "border-right-color","values": ["color","transparent","initial","inherit"]},{"property": "margin-top","values": ["length","%","auto","initial","inherit"]},{"property": "border-radius","values": ["length","%","initial","inherit"]},{"property": "max-width","values": ["none","length","%","initial","inherit"]},{"property": "min-width","values": ["length","%","initial","inherit"]},{"property": "z-index","values": ["auto","number","initial","inherit"]},{"property": "border-bottom-left-radius","values": ["length","%","initial","inherit"]},{"property": "text-transform","values": ["none","capitalize","uppercase","lowercase","initial","inherit"]},{"property": "text-indent","values": ["length","%","initial","inherit"]},{"property": "text-justify","values": ["auto","inter-word","inter-ideograph","inter-cluster","distribute","kashida","trim","none","initial","inherit"]},{"property": "text-align","values": ["left","right","center","justify","initial","inherit"]},{"property": "border-bottom-color","values": ["color","transparent","initial","inherit"]},{"property": "background","values": ["background-color","background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","initial","inherit"]},{"property": "letter-spacing","values": ["normal","length","initial","inherit"]},{"property": "align-items","values": ["stretch","center","flex-start","flex-end","baseline","initial","inherit"]},{"property": "tab-size","values": ["number","length","initial","inherit"]},{"property": "flex-wrap","values": ["nowrap","wrap","wrap-reverse","initial","inherit"]},{"property": "flex-direction","values": ["row","row-reverse","column","column-reverse","initial","inherit"]},{"property": "flex-basis","values": ["number","auto","initial","inherit"]},{"property": "flex-shrink","values": ["number","initial","inherit"]},{"property": "bottom","values": ["auto","length","%","initial","inherit"]},{"property": "clip","values": ["auto","shape","initial","inherit"]},{"property": "flex-grow","values": ["number","initial","inherit"]},{"property": "font","values": ["font-style","font-variant","font-weight","font-size/line-height","font-family","caption","icon","menu","message-box","small-caption","status-bar","initial","inherit"]},{"property": "margin-left","values": ["length","%","auto","initial","inherit"]},{"property": "text-decoration-color","values": ["color","initial","inherit"]},{"property": "border-bottom-right-radius","values": ["length","%","initial","inherit"]},{"property": "list-style-position","values": ["inside","outside","initial","inherit"]},{"property": "top","values": ["auto","length","%","initial","inherit"]},{"property": "right","values": ["auto","length","%","initial","inherit"]},{"property": "background-origin","values": ["padding-box","border-box","content-box","initial","inherit"]},{"property": "table-layout","values": ["auto","fixed","initial","inherit"]},{"property": "margin-bottom","values": ["length","%","auto","initial","inherit"]},{"property": "padding-bottom","values": ["length","%","initial","inherit"]},{"property": "border-image-slice","values": [" number"," %"," fill","initial","inherit"]},{"property": "flex-flow","values": ["flex-direction","flex-wrap","initial","inherit"]},{"property": "float","values": ["none","left","right","initial","inherit"]},{"property": "vertical-align","values": ["baseline","length","%","sub","super","top","text-top","middle","bottom","text-bottom","initial","inherit"]},{"property": "padding-right","values": ["length","%","initial","inherit"]},{"property": "width","values": ["auto","length","%","initial","inherit"]},{"property": "align-content","values": ["stretch","center","flex-start","flex-end","space-between","space-around","initial","inherit"]},{"property": "padding","values": ["length","%","initial","inherit"]},{"property": "hanging-punctuation","values": ["none","first","last","allow-end","force-end","initial","inherit"]},{"property": "border-bottom-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "border-left-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "text-align-last","values": ["auto","left","right","center","justify","start","end","initial","inherit"]},{"property": "order","values": ["number","initial","inherit"]},{"property": "border-top-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-top-color","values": ["color","transparent","initial","inherit"]},{"property": "display","values": ["inline","block","flex","inline-block","inline-flex","inline-table","list-item","run-in","table","table-caption","\r\n      table-column-group","table-header-group","table-footer-group","table-row-group","table-cell","table-column","table-row","none","initial","inherit"]},{"property": "left","values": ["auto","length","%","initial","inherit"]},{"property": "border-top-left-radius","values": ["length","%","initial","inherit"]},{"property": "margin","values": ["length","%","auto","initial","inherit"]},{"property": "border-image-repeat","values": [" stretch"," repeat"," round","space","initial","inherit"]},{"property": "box-shadow","values": ["none","h-shadow","v-shadow","blur","spread","color","inset","initial","inherit"]},{"property": "border-top-right-radius","values": ["length","%","initial","inherit"]},{"property": "text-decoration-style","values": ["solid","double","dotted","dashed","wavy","initial","inherit"]},{"property": "height","values": ["auto","length","%","initial","inherit"]},{"property": "border-right-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-left","values": ["border-left-width","border-left-style","border-left-color","initial","inherit"]},{"property": "border-image-width","values": ["length","number","%","auto","initial","inherit"]},{"property": "font-family","values": ["family-name\r\n      generic-family","initial","inherit"]},{"property": "border-top","values": ["border-top-width","border-top-style","border-top-color","initial","inherit"]},{"property": "empty-cells","values": ["show","hide","initial","inherit"]},{"property": "justify-content","values": ["flex-start","flex-end","center","space-between","space-around","initial","inherit"]},{"property": "text-shadow","values": ["h-shadow","v-shadow","blur-radius","color","none","initial","inherit"]},{"property": "overflow-y","values": ["visible","hidden","scroll","auto","initial","inherit"]},{"property": "padding-top","values": ["length","%","initial","inherit"]},{"property": "border-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "border-spacing","values": ["length length","initial","inherit"]},{"property": "word-break","values": ["normal","break-all","keep-all ","initial","inherit"]},{"property": "@font-face","values": ["font-family","src","font-stretch","font-style","font-weight","unicode-range"]},{"property": "text-decoration","values": ["none","underline","overline","line-through","initial","inherit"]},{"property": "white-space","values": ["normal","nowrap","pre","pre-line","pre-wrap","initial","inherit"]},{"property": "font-size-adjust","values": ["number","none","initial","inherit"]},{"property": "font-style","values": ["normal","italic","oblique","initial","inherit"]},{"property": "line-height","values": ["normal","number","length","%","initial","inherit"]},{"property": "font-weight","values": ["normal","bold","bolder","lighter","100\r\n      200\r\n      300\r\n      400\r\n      500\r\n      600\r\n      700\r\n      800\r\n      900","initial","inherit"]},{"property": "word-spacing","values": ["normal","length","initial","inherit"]},{"property": "page-break-after","values": ["auto","always","avoid","left","right","initial","inherit"]},{"property": "outline-color","values": ["invert","color","initial","inherit"]},{"property": "column-gap","values": ["length","normal","initial","inherit"]},{"property": "column-rule","values": [" column-rule-width"," column-rule-style"," column-rule-color","initial","inherit"]},{"property": "columns","values": ["auto","column-width","column-count","initial","inherit"]},{"property": "column-rule-style","values": [" none"," hidden"," dotted"," dashed"," solid"," double"," groove"," ridge"," inset"," outset","initial","inherit"]},{"property": "font-variant","values": ["normal","small-caps","initial","inherit"]},{"property": "column-rule-width","values": [" medium"," thin"," thick"," length","initial","inherit"]},{"property": "cursor","values": ["alias","all-scroll","auto","cell","context-menu","col-resize","copy","crosshair","default","e-resize","ew-resize","grab","grabbing","help","move","n-resize","ne-resize","nesw-resize","ns-resize","nw-resize","nwse-resize","no-drop","none","not-allowed","pointer","progress","row-resize","s-resize","se-resize","sw-resize","text","URL","vertical-text","w-resize","wait","zoom-in","zoom-out","initial","inherit"]},{"property": "column-fill","values": ["balance","auto","initial","inherit"]},{"property": "animation-fill-mode","values": ["none","forwards","backwards","both","initial","inherit"]},{"property": "nav-left","values": ["auto","id","target-name","initial","inherit"]},{"property": "outline-width","values": ["medium","thin","thick","length","initial","inherit"]},{"property": "nav-right","values": ["auto","id","target-name","initial","inherit"]},{"property": "nav-up","values": ["auto","id","target-name","initial","inherit"]},{"property": "nav-down","values": ["auto","id","target-name","initial","inherit"]},{"property": "outline","values": ["outline-color","outline-style","outline-width","initial","inherit"]},{"property": "animation","values": ["animation-name","animation-duration","\r\n\tanimation-timing-function","animation-delay","\r\n\tanimation-iteration-count","animation-direction","animation-fill-mode","animation-play-state","initial","inherit"]},{"property": "nav-index","values": ["auto","number","initial","inherit"]},{"property": "font-stretch","values": ["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded","initial","inherit"]},{"property": "list-style-image","values": ["none","url","initial","inherit"]},{"property": "transition-duration","values": ["time","initial","inherit"]},{"property": "perspective","values": ["length","none","initial","inherit"]},{"property": "animation-play-state","values": ["paused","running","initial","inherit"]},{"property": "backface-visibility","values": ["visible","hidden","initial","inherit"]},{"property": "column-count","values": ["number","auto","initial","inherit"]},{"property": "transition-delay","values": ["time","initial","inherit"]},{"property": "transform","values": ["none","matrix(n,n,n,n,n,n)","matrix3d\r\n\t(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)","translate(x,y)","translate3d(x,y,z)","translateX(x)","translateY(y)","translateZ(z)","scale(x,y)","scale3d(x,y,z)","scaleX(x)","scaleY(y)","scaleZ(z)","rotate(angle)","rotate3d(x,y,z,angle)","rotateX(angle)","rotateY(angle)","rotateZ(angle)","skew(x-angle,y-angle)","skewX(angle)","skewY(angle)","perspective(n)","initial","inherit"]},{"property": "resize","values": [" none"," both"," horizontal"," vertical","initial","inherit"]},{"property": "text-overflow","values": ["clip","ellipsis","string","initial","inherit"]},{"property": "caption-side","values": ["top","bottom","initial","inherit"]},{"property": "filter","values": ["none","blur(px)","brightness(%)","contrast(%)","drop-shadow(h-shadow v-shadow blur spread color)","grayscale(%)","hue-rotate(deg)","invert(%)","opacity(%)","saturate(%)","sepia(%)","url()","initial","inherit"]},{"property": "content","values": ["normal","none","counter","attr(attribute)","string","open-quote","close-quote","no-open-quote","no-close-quote","url(url)","initial","inherit"]},{"property": "transition-timing-function","values": ["ease","linear","ease-in","ease-out","ease-in-out","cubic-bezier(n,n,n,n)","initial","inherit"]},{"property": "box-sizing","values": [" content-box"," border-box","initial","inherit"]},{"property": "page-break-before","values": ["auto","always","avoid","left","right","initial","inherit"]},{"property": "animation-timing-function","values": ["linear","ease","ease-in","ease-out","ease-in-out","cubic-bezier(n,n,n,n)","initial","inherit"]},{"property": "outline-offset","values": [" length","initial","inherit"]},{"property": "column-width","values": ["auto","length","initial","inherit"]},{"property": "outline-style","values": ["none","hidden","dotted","dashed","solid","double","groove","ridge","inset","outset","initial","inherit"]},{"property": "transform-origin","values": ["x-axis","y-axis","z-axis","initial","inherit"]},{"property": "transform-style","values": ["flat","preserve-3d","initial","inherit"]},{"property": "transition","values": ["transition-property","transition-duration","transition-timing-function","transition-delay","initial","inherit"]},{"property": "page-break-inside","values": ["auto","avoid","initial","inherit"]},{"property": "column-span","values": ["1","all","initial","inherit"]},{"property": "transition-property","values": ["none","all","property","initial","inherit"]},{"property": "animation-iteration-count","values": ["number","infinite","initial","inherit"]},{"property": "animation-name","values": ["keyframename","none","initial","inherit"]}];

    onGetInputs() {
        var entries = [];
        entries.push(["cssProperty", "string", {nameLocked: true, removable: true}]);
        entries.push(["cssValue", "", {nameLocked: true, removable: true}]);
        return entries;
    }

    onGetOutputs() {
        var entries = [];
        entries.push(["some output"]);
        return entries;
    }

    onExecute(param, options) {
        // no code?
        if (this.mode == LiteGraph.ON_TRIGGER) {
            action = this.id+"_"+(action?action:"action")+"_exectoact_"+LiteGraph.uuidv4();
            this.onAction(action, param, options);
        }
    }

    onAction() {
        var element = this.getInputData(0);
        var res = null;
        var cssProperty = this.getInputOrProperty("cssProperty");
        var cssValue = this.getInputOrProperty("cssValue");
        if (element && element.style) {
            res = element.style[cssProperty] = cssValue;
            console.log?.("applied",cssProperty,cssValue,"to",element);
        }else{
            console.log?.("no el to apply css");
        }
        this.setOutputData(0,res);
    }
}
LiteGraph.registerNodeType("html/apply_element_css", HtmlElementStyle);


// Creates an interface to access extra features from a graph (like play, stop, live, etc)
export class Editor {

    constructor(container_id, options = {}) {

        const root = this.root = document.createElement("div");
        root.className = "litegraph litegraph-editor";
        root.innerHTML = `
        <div class="header">
            <div class="tools tools-left"></div>
            <div class="tools tools-right"></div>
        </div>
        <div class="content">
            <div class="editor-area">
                <canvas class="graphcanvas" width="1000" height="500" tabindex="10"></canvas>
            </div>
        </div>
        <div class="footer">
            <div class="tools tools-left"></div>
            <div class="tools tools-right"></div>
        </div>`;

        this.tools = root.querySelector(".tools");
        this.content = root.querySelector(".content");
        this.footer = root.querySelector(".footer");

        const canvas = this.canvas = root.querySelector(".graphcanvas");
        const graph = this.graph = new LGraph();
        const graphcanvas = this.graphcanvas = new LGraphCanvas(canvas, graph);

        graphcanvas.background_image = "imgs/grid.png";
        graph.onAfterExecute = () => {
            graphcanvas.draw(true);
        };

        graphcanvas.onDropItem = this.onDropItem.bind(this);

        // add stuff
        // this.addToolsButton("loadsession_button","Load","imgs/icon-load.png", this.onLoadButton.bind(this), ".tools-left" );
        // this.addToolsButton("savesession_button","Save","imgs/icon-save.png", this.onSaveButton.bind(this), ".tools-left" );
        this.addLoadCounter();
        this.addToolsButton(
            "playnode_button",
            "Play",
            "imgs/icon-play.png",
            this.onPlayButton.bind(this),
            ".tools-right",
        );
        this.addToolsButton(
            "playstepnode_button",
            "Step",
            "imgs/icon-playstep.png",
            this.onPlayStepButton.bind(this),
            ".tools-right",
        );

        if (!options.skip_livemode) {
            this.addToolsButton(
                "livemode_button",
                "Live",
                "imgs/icon-record.png",
                this.onLiveButton.bind(this),
                ".tools-right",
            );
        }
        if (!options.skip_maximize) {
            this.addToolsButton(
                "maximize_button",
                "",
                "imgs/icon-maximize.png",
                this.onFullscreenButton.bind(this),
                ".tools-right",
            );
        }
        if (options.miniwindow) {
            this.addMiniWindow(300, 200);
        }

        // append to DOM
        const parent = document.getElementById(container_id);
        if (parent) {
            parent?.appendChild(root);
        } else {
            throw new Error("Editor has no parentElement to bind to");
        }

        graph.onPlayEvent = () => {
            const button = this.root.querySelector("#playnode_button");
            button.innerHTML = `<img src="imgs/icon-stop.png"/> Stop`;
        };

        graph.onStopEvent = () => {
            const button = this.root.querySelector("#playnode_button");
            button.innerHTML = `<img src="imgs/icon-play.png"/> Play`;
        };

        graphcanvas.resize();
    }

    addLoadCounter() {
        const meter = document.createElement("div");
        meter.className = "headerpanel loadmeter toolbar-widget";
        meter.innerHTML = `
            <div class="cpuload">
                <strong>CPU</strong> 
                <div class="bgload">
                    <div class="fgload"></div>
                </div>
            </div>
            <div class="gpuload">
                <strong>GFX</strong> 
                <div class="bgload">
                    <div class="fgload"></div>
                </div>
            </div>`;

        this.root.querySelector(".header .tools-left").appendChild(meter);
        var self = this;

        setInterval(() => {
            meter.querySelector(".cpuload .fgload").style.width =
                `${2 * self.graph.execution_time * 90}px`;
            if (self.graph.status == LGraph.STATUS_RUNNING) {
                meter.querySelector(".gpuload .fgload").style.width =
                    `${self.graphcanvas.render_time * 10 * 90}px`;
            } else {
                meter.querySelector(".gpuload .fgload").style.width = `${4}px`;
            }
        }, 200);
    }

    addToolsButton(id, name, icon_url, callback, container = ".tools") {
        const button = this.createButton(name, icon_url, callback);
        button.id = id;
        this.root.querySelector(container).appendChild(button);
    }

    createButton(name, icon_url, callback) {
        const button = document.createElement("button");
        if (icon_url) {
            button.innerHTML = `<img src="${icon_url}"/> `;
        }
        button.classList.add("btn");
        button.innerHTML += name;
        if(callback)
            button.addEventListener("click", callback );
        return button;
    }

    onLoadButton() {
        var panel = this.graphcanvas.createPanel("Load session",{closable: true});

        // @TODO

        this.root.appendChild(panel);
    }

    onSaveButton() {}

    onPlayButton() {
        var graph = this.graph;
        if (graph.status == LGraph.STATUS_STOPPED) {
            graph.start();
        } else {
            graph.stop();
        }
    }

    onPlayStepButton() {
        var graph = this.graph;
        graph.runStep(1);
        this.graphcanvas.draw(true, true);
    }

    onLiveButton() {
        var is_live_mode = !this.graphcanvas.live_mode;
        this.graphcanvas.switchLiveMode(true);
        this.graphcanvas.draw();
        var button = this.root.querySelector("#livemode_button");
        button.innerHTML = !is_live_mode
            ? `<img src="imgs/icon-record.png"/> Live`
            : `<img src="imgs/icon-gear.png"/> Edit`;
    }

    onDropItem(e) {
        var that = this;
        if(!e.dataTransfer){
            LiteGraph.log_warn("LGEditor","onDropItem","no dataTransfer on event",e,this);
            return;
        }
        LiteGraph.log_info("LGEditor","onDropItem","processing dataTransfer",e.dataTransfer);
        for(var i = 0; i < e.dataTransfer.files.length; ++i) {
            var file = e.dataTransfer.files[i];
            var ext = LGraphCanvas.getFileExtension(file.name);
            var reader = new FileReader();
            if(ext == "json") {
                reader.onload = (event) => {
                    var data = JSON.parse( event.target.result );
                    that.graph.configure(data);
                };
                reader.readAsText(file);
            }
        }
    }

    goFullscreen() {
        if (this.root.requestFullscreen) {
            this.root.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (this.root.mozRequestFullscreen) {
            this.root.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (this.root.webkitRequestFullscreen) {
            this.root.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else {
            throw new Error("Fullscreen not supported");
        }

        var self = this;
        setTimeout(() => {
            self.graphcanvas.resize();
        }, 100);
    }

    onFullscreenButton() {
        if(this.isFullscreen()) {
            this.exitFullscreen();
        } else {
            this.goFullscreen();
        }
    }

    addMiniWindow(w, h) {
        var miniwindow = document.createElement("div");
        miniwindow.className = "litegraph miniwindow";
        miniwindow.innerHTML =
            `<canvas class="graphcanvas" width="${w}" height="${h}" tabindex="10"></canvas>`;
        var canvas = miniwindow.querySelector("canvas");
        var that = this;

        var graphcanvas = new LGraphCanvas( canvas, this.graph );
        graphcanvas.show_info = false;
        graphcanvas.background_image = "imgs/grid.png";
        graphcanvas.scale = 0.25;
        graphcanvas.allow_dragnodes = false;
        graphcanvas.allow_interaction = false;
        graphcanvas.render_shadows = false;
        graphcanvas.max_zoom = 0.25;
        this.miniwindow_graphcanvas = graphcanvas;
        graphcanvas.onClear = () => {
            graphcanvas.scale = 0.25;
            graphcanvas.allow_dragnodes = false;
            graphcanvas.allow_interaction = false;
        };
        graphcanvas.onRenderBackground = function(canvas, ctx) {
            ctx.strokeStyle = "#567";
            var tl = that.graphcanvas.convertOffsetToCanvas([0, 0]);
            var br = that.graphcanvas.convertOffsetToCanvas([
                that.graphcanvas.canvas.width,
                that.graphcanvas.canvas.height,
            ]);
            tl = this.convertCanvasToOffset(tl);
            br = this.convertCanvasToOffset(br);
            ctx.lineWidth = 1;
            ctx.strokeRect(
                Math.floor(tl[0]) + 0.5,
                Math.floor(tl[1]) + 0.5,
                Math.floor(br[0] - tl[0]),
                Math.floor(br[1] - tl[1]),
            );
        };

        miniwindow.style.position = "absolute";
        miniwindow.style.top = "4px";
        miniwindow.style.right = "4px";

        var close_button = document.createElement("div");
        close_button.className = "corner-button";
        close_button.innerHTML = "&#10060;";
        close_button.addEventListener("click", (_event) => {
            graphcanvas.setGraph(null);
            miniwindow.parentNode.removeChild(miniwindow);
        });
        miniwindow.appendChild(close_button);

        this.root.querySelector(".content").appendChild(miniwindow);
    }

    // removeMultiView() {
    //     if (this.graphcanvas2) {
    //         this.graphcanvas2.setGraph(null, true);
    //         this.graphcanvas2.viewport = null;
    //         this.graphcanvas2 = null;

    //         this.graphcanvas.viewport = [0,0,canvas.width,canvas.height];
    //         this.graphcanvas.resize();
    //     }
    // }

    toggleMultiview() {
        var canvas = this.canvas;
        let graphcanvas;

        // toggle test
        if (this.graphcanvas2) {
            this.graphcanvas2.unbindEvents();
            this.graphcanvas2.setGraph(null, true);
            this.graphcanvas2.viewport = null;
            this.graphcanvas2 = null;

            // this.graphcanvas.unbindEvents();
            // this.graphcanvas.setGraph(null, false);
            // this.graphcanvas.viewport = null;
            // this.graphcanvas = null;
            // graphcanvas = new LGraphCanvas( canvas, this.graph );
            // graphcanvas.background_image = "imgs/grid.png";
            // this.graphcanvas = graphcanvas;
            // window.graphcanvas = this.graphcanvas;

            this.graphcanvas.viewport = [0,0,canvas.width,canvas.height];
            this.graphcanvas.setDirty(true,true);

            return;
        }

        this.graphcanvas.ctx.fillStyle = "black";
        this.graphcanvas.ctx.fillRect(0,0,canvas.width,canvas.height);
        this.graphcanvas.viewport = [0,0,canvas.width*0.5-2,canvas.height];
        // this.graphcanvas.resize();
        this.graphcanvas.setDirty(true,true);

        graphcanvas = new LGraphCanvas( canvas, this.graph );
        graphcanvas.background_image = "imgs/grid.png";
        this.graphcanvas2 = graphcanvas;
        this.graphcanvas2.viewport = [canvas.width*0.5,0,canvas.width*0.5,canvas.height];
        // this.graphcanvas2.resize();
        this.graphcanvas2.setDirty(true,true);
    }

    isFullscreen() {
        return(
            document.fullscreenElement ||
            document.mozRequestFullscreen ||
            document.webkitRequestFullscreen ||
            false
        );
    }

    exitFullscreen() {
        if(document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.mozCancelFullscreen) {
            document.mozCancelFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    }
}


LiteGraph.debug = true; // enable logging
LiteGraph.logging_set_level(4); // -1 is none, 0 is error level, 5 is all up to debug, more is for verbose : will set LiteGraph.debug_level

LiteGraph.catch_exceptions = true;
LiteGraph.throw_errors = true;
LiteGraph.allow_scripts = true; //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration); which could lead to exploits

LiteGraph.searchbox_extras = {}; //used to add extra features to the search box
LiteGraph.auto_sort_node_types = true; // [true!] If set to true; will automatically sort node types / categories in the context menus
LiteGraph.node_box_coloured_when_on = true; // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action); visual feedback
LiteGraph.node_box_coloured_by_mode = true; // [true!] nodebox based on node mode; visual feedback
LiteGraph.dialog_close_on_mouse_leave = true; // [false on mobile] better true if not touch device;
LiteGraph.dialog_close_on_mouse_leave_delay = 500;
LiteGraph.shift_click_do_break_link_from = false; // [false!] prefer false if results too easy to break links
LiteGraph.click_do_break_link_to = false; // [false!]prefer false; way too easy to break links
LiteGraph.search_hide_on_mouse_leave = true; // [false on mobile] better true if not touch device;
LiteGraph.search_filter_enabled = true; // [true!] enable filtering slots type in the search widget; !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
LiteGraph.search_show_all_on_open = true; // [true!] opens the results list when opening the search widget

LiteGraph.show_node_tooltip = true; // [true!] show a tooltip with node property "tooltip" over the selected node
LiteGraph.show_node_tooltip_use_descr_property = true; // enabled tooltip from desc when property tooltip not set

LiteGraph.auto_load_slot_types = true; // [if want false; use true; run; get vars values to be statically set; than disable] nodes types and nodeclass association with node types need to be calculated; if dont want this; calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
/*// set these values if not using auto_load_slot_types
LiteGraph.registered_slot_in_types = {}; // slot types for nodeclass
LiteGraph.registered_slot_out_types = {}; // slot types for nodeclass
LiteGraph.slot_types_in = []; // slot types IN
LiteGraph.slot_types_out = []; // slot types OUT*/

LiteGraph.alt_drag_do_clone_nodes = true; // [true!] very handy; ALT click to clone and drag the new node
LiteGraph.do_add_triggers_slots = true; // [true!] will create and connect event slots when using action/events connections; !WILL CHANGE node mode when using onTrigger (enable mode colors); onExecuted does not need this
LiteGraph.allow_multi_output_for_events = false; // [false!] being events; it is strongly reccomended to use them sequentially; one by one
LiteGraph.middle_click_slot_add_default_node = true;  //[true!] allows to create and connect a ndoe clicking with the third button (wheel)
LiteGraph.release_link_on_empty_shows_menu = true; //[true!] dragging a link to empty space will open a menu, add from list, search or defaults
// OLD setting: this is always pointer on this version :: LiteGraph.pointerevents_method = "pointer"; // "mouse"|"pointer" use mouse for compatibility issues, touch will work only with pointer 
LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs = true; //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes
LiteGraph.backspace_delete = false;  // [false!] delete key is enough, don't mess with text edit and custom

LiteGraph.actionHistory_enabled = true; // [true!] cntrlZ, cntrlY :: WIP testing
LiteGraph.actionHistoryMaxSave = 40;

LiteGraph.showCanvasOptions = true; // enable canvas options panel, customize in LiteGrpah.availableCanvasOptions

LiteGraph.use_uuids = true; // [testing] why not? maybe not good for comparison?

/* -- EVENTS PROCESSING METHODS -- */

/* METHOD 1 ANCESTORS : EXECUTING ACTIONS BEFORE THE NEXT FRAME, AFFECTING INPUT NODES WILL BE REPROCESSED */
LiteGraph.refreshAncestorsOnTriggers = true; //[true!]
LiteGraph.refreshAncestorsOnActions = true; //[true!]
LiteGraph.ensureUniqueExecutionAndActionCall = true; //[true!]

/* METHOD 2 DEFERRED ACTIONS */
LiteGraph.use_deferred_actions = false; // disabling deferred


// CONTEXT MENU FILTERING
// ---- WIP ----
// i) ComfyUI has his own
LiteGraph.context_menu_filter_enabled = true; // [WIP!]

// !! TESTING node configure FIX SLOTS !!
LiteGraph.reprocess_slot_while_node_configure = true;

LiteGraph.properties_allow_input_binding = true; // [true!] allow create and bind inputs, will update binded property value on node execute 
/**
 * EXAMPLE EXTENSION TO AUTOCONNECT SELECTED NODES TO ANOTHER (SINGLE) NODE
 * press a than click on a node
 */


export let registerExtension_autoconnect = function(graphcanvas){
    // enable only if debugging CallbackHandler itself
    // graphcanvas.cb_handler.debug = true;

    let ext = "autoconnect";
    let debug = false;
    
    graphcanvas.registerCallbackHandler("onKeyDown",function(oCbInfo, keyEvent){
        // oCbInfo is first passed parameter and contains infos about the event execution chain 
        
        // skip from second event on
        if(keyEvent.repeat){
            return;
        }

        if(debug) console.info(ext, "*** onKeyDown handler ***", ...arguments);
        switch(keyEvent.keyCode){
            case 65: // a
            
                // skip if shift o ctrl
                if(keyEvent.shiftKey || keyEvent.ctrlKey){
                    if(debug) console.verbose(ext, "skip shift or ctlr", ...arguments);
                    break;
                }

                // check selected nodes
                let nSel = Object.keys(graphcanvas.selected_nodes).length;
                var aNodesFrom = [];
                if(nSel){
                    for(let iO in graphcanvas.selected_nodes){
                        // graphcanvas.graph.autoConnectNodes(node_from, node_to);
                        aNodesFrom.push(graphcanvas.selected_nodes[iO]);
                    }
                }
                
                graphcanvas.registerCallbackHandler("onMouseDown",function(md_oCbInfo, e){
                    if(debug) console.info(ext, "*** onMouseDown handler ***", ...arguments);

                    let node_to = graphcanvas.graph.getNodeOnPos( e.canvasX, e.canvasY, graphcanvas.visible_nodes, 5 );

                    if(node_to){
                        if(debug) console.info(ext, "### dbg: clicked on DEST node, autoconnect", node_to, aNodesFrom);
                        for(let node_from of aNodesFrom){
                            if(debug) console.info(ext, "### dbg: AUTOCONNECT", node_from, node_to);
                            graphcanvas.graph.autoConnectNodes(node_from, node_to);
                        }
                    }else{
                        if(debug) console.info(ext, "### dbg: not clicked on a node", node_to);
                    }

                },{ call_once: true }); // register to call only once

            break;
            default:
                if(debug) console.debug(ext, "### dbg: ignore key", keyEvent.keyCode);
            break;
        }
    });

}

if(typeof(graphcanvas)!=="undefined"){
    registerExtension_autoconnect(graphcanvas);
}

LiteGraph.registerCallbackHandler("on_lgraphcanvas_construct",function(oCbInfo, graphcanvas){
    registerExtension_autoconnect(graphcanvas);
});

export let registerExtension_keyhelper = function(graphcanvas){

    // enable only if debugging CallbackHandler itself
    // graphcanvas.cb_handler.debug = true;

    // oCbInfo is first passed parameter and contains infos about the event execution chain 

    let ext = "key_helper";
    let debug = false;

    // onKeyDown
    graphcanvas.registerCallbackHandler("onKeyDown",function(oCbInfo, keyEvent){
        if(debug) console.info(ext, "*** onKeyDown handler ***",...arguments);

        let nSel = Object.keys(graphcanvas.selected_nodes).length;
        var aNodesFrom = [];
        var nodeX = false;
        var return_value = null;
        if(nSel){
            for(let iO in graphcanvas.selected_nodes){
                aNodesFrom.push(graphcanvas.selected_nodes[iO]);
            }
            nodeX = aNodesFrom[0];
        }

        switch(keyEvent.keyCode){
            case 39: //ArrowLeft
                if(nSel){

                    // ---- ADD NEW NODE CONNECTED TO SELECTED ONE  ----
                    if(keyEvent.shiftKey || keyEvent.ctrlKey){

                        // skip from second event on
                        if(keyEvent.repeat){
                            return;
                        }

                        // simulate position via event (little hack, should implement that on prompt itself)
                        /* const mouseCoord = graphcanvas.getMouseCoordinates();
                        const gloCoord = graphcanvas.convertOffsetToEditorArea(mouseCoord);
                        // need prompt to be absolute positioned relative to editor-area that needs relative positioning
                        keyEvent.clientX = gloCoord[0];
                        keyEvent.clientY = gloCoord[1]; */
                        const gloCoord = graphcanvas.convertOffsetToEditorArea(nodeX.pos);
                        keyEvent.clientX = gloCoord[0] + nodeX.size[0] + 33;
                        keyEvent.clientY = gloCoord[1];
                        keyEvent.canvasX = nodeX.pos[0] + nodeX.size[0] + 33;
                        keyEvent.canvasY = nodeX.pos[1];

                        if(nodeX.outputs && nodeX.outputs[0]){
                            if(keyEvent.shiftKey){
                                if(debug) console.debug(ext, "dbg: show search (using first slot)", nodeX, keyEvent);
                                graphcanvas.showSearchBox(keyEvent, {node_from: nodeX, slot_from: nodeX.outputs[0], type_filter_in: nodeX.outputs[0].type});
                            }else if(keyEvent.ctrlKey){
                                if(debug) console.debug(ext, "dbg: show connection menu (using first slot)", nodeX, keyEvent);
                                graphcanvas.showConnectionMenu({nodeFrom: nodeX, slotFrom: nodeX.outputs[0], e: keyEvent, isCustomEvent: true});
                            }
                        }else{
                            if(debug) console.debug(ext, "dbg: no output for node");
                        }
                        
                    }else{

                        // move nodes right
                        for(let iN=0;iN<aNodesFrom.length;iN++){
                            aNodesFrom[iN].alignToGrid();
                            aNodesFrom[iN].pos[0] += LiteGraph.CANVAS_GRID_SIZE;
                            aNodesFrom[iN].processCallbackHandlers("onMoved",{
                                def_cb: aNodesFrom[iN].onMoved
                            });
                        }

                    }

                }
            break;
            case 37: // ArrowLeft
                // move nodes left
                if(nSel){
                    for(let iN=0;iN<aNodesFrom.length;iN++){
                        aNodesFrom[iN].alignToGrid();
                        aNodesFrom[iN].pos[0] -= LiteGraph.CANVAS_GRID_SIZE;
                        aNodesFrom[iN].processCallbackHandlers("onMoved",{
                            def_cb: aNodesFrom[iN].onMoved
                        });
                    }
                }
            break;
            case 38: // ArrowUp
                if(nSel){
                    // move nodes up
                    // check if ctrlKey
                    if(keyEvent.ctrlKey){
                        // ---- select sibiling node, adding if shift ----
                        // skip from second event on
                        if(keyEvent.repeat){
                            return;
                        }
                        if(nodeX.inputs && nodeX.inputs.length){
                            const parentNode = nodeX.getInputNode(0);
                            if(!parentNode) return;
                            let found = false;
                            let foundNode = false;
                            for(let iO=parentNode.outputs.length-1; iO>=0; iO--){
                                let outNodes = parentNode.getOutputNodes(iO);
                                if(!outNodes) continue;
                                for(let ioN=outNodes.length-1; ioN>=0; ioN--){
                                    if(found){
                                        // found prev cycle
                                        foundNode = outNodes[ioN];
                                        break;
                                    }
                                    if(nodeX.id === outNodes[ioN].id){
                                        found = true;
                                        // will get next in cycle
                                    }
                                }
                                if(found){
                                    break;
                                }
                            }
                            if(foundNode){
                                if(keyEvent.shiftKey){
                                    graphcanvas.selectNode(foundNode, true);
                                }else{
                                    graphcanvas.selectNodes([foundNode]);
                                }
                            }
                        }
                    }else{
                        for(let iN=0;iN<aNodesFrom.length;iN++){
                            aNodesFrom[iN].alignToGrid();
                            aNodesFrom[iN].pos[1] -= LiteGraph.CANVAS_GRID_SIZE;
                            aNodesFrom[iN].processCallbackHandlers("onMoved",{
                                def_cb: aNodesFrom[iN].onMoved
                            });
                        }
                    }
                }
            break;
            case 40: // ArrowDown
                if(nSel){
                    // check if ctrlKey
                    if(keyEvent.ctrlKey){
                        // ---- select sibiling node, adding if shift ----
                        // skip from second event on
                        if(keyEvent.repeat){
                            return;
                        }
                        if(nodeX.inputs && nodeX.inputs.length){
                            const parentNode = nodeX.getInputNode(0);
                            if(!parentNode) return;
                            let found = false;
                            let foundNode = false;
                            for(let iO in parentNode.outputs){
                                let outNodes = parentNode.getOutputNodes(iO);
                                if(!outNodes) continue;
                                for(let ioN in outNodes){
                                    if(found){
                                        // found prev cycle
                                        foundNode = outNodes[ioN];
                                        break;
                                    }
                                    if(nodeX.id === outNodes[ioN].id){
                                        found = true;
                                        // will get next in cycle
                                    }
                                }
                                if(found){
                                    break;
                                }
                            }
                            if(foundNode){
                                if(keyEvent.shiftKey){
                                    graphcanvas.selectNode(foundNode, true);
                                }else{
                                    graphcanvas.selectNodes([foundNode]);
                                }
                            }
                        }
                    }else{
                        // move nodes down
                        for(let iN=0;iN<aNodesFrom.length;iN++){
                            aNodesFrom[iN].alignToGrid();
                            aNodesFrom[iN].pos[1] += LiteGraph.CANVAS_GRID_SIZE;
                            aNodesFrom[iN].processCallbackHandlers("onMoved",{
                                def_cb: aNodesFrom[iN].onMoved
                            });
                        }
                    }
                }
            break;
            case 9: // TAB
                // next node (connected to selected, or previous w shift)
                if(nSel){
                    let nextNode = false;
                    if(keyEvent.shiftKey){
                        if(nodeX.inputs && nodeX.inputs.length && nodeX.inputs[0].link && nodeX.inputs[0].link!==null){
                            nextNode = nodeX.getInputNode(0);
                            graphcanvas.selectNodes([nextNode]);
                        }
                    }else{
                        if(nodeX.outputs && nodeX.outputs.length && nodeX.outputs[0].links && nodeX.outputs[0].links.length){
                            nextNode = nodeX.getOutputNodes(0)[0];
                            graphcanvas.selectNodes([nextNode]);
                        }
                    }
                    return_value = true;
                }
            break;
            case 70: // F
                // focus on node
                if(nSel){
                    graphcanvas.centerOnNode(nodeX);
                    // TODO graphcanvas.centerOnSelection();
                }else{
                    graphcanvas.recenter();
                }
            break;
            default:
                if(debug) console.debug(ext, "dbg: ignore",keyEvent.keyCode);
            break;
        }

        return {
            return_value: return_value,
            //prevent_default: true,
            //stop_replication: true
        };
    });

}

if(typeof(graphcanvas)!=="undefined"){
    registerExtension_keyhelper(graphcanvas);
}

LiteGraph.registerCallbackHandler("on_lgraphcanvas_construct",function(oCbInfo, graphcanvas){
    registerExtension_keyhelper(graphcanvas);
});

export let registerExtension_renamer = function(graphcanvas){

    // enable only if debugging CallbackHandler itself
    // graphcanvas.cb_handler.debug = true;

    // oCbInfo is first passed parameter and contains infos about the event execution chain 

    let ext = "renamer";
    let debug = false;

    // onKeyDown
    graphcanvas.registerCallbackHandler("onKeyDown",function(oCbInfo, keyEvent){
        if(debug) console.info(ext, "*** renamer onKeyDown handler ***",...arguments);
        switch(keyEvent.keyCode){
            case 113: // F2
                
                // skip from second event on
                if(keyEvent.repeat){
                    return;
                }

                // check selected nodes
                let nSel = Object.keys(graphcanvas.selected_nodes).length;
                
                // simulate position via event (little hack, should implement that on prompt itself)
                const mouseCoord = graphcanvas.getMouseCoordinates();
                const gloCoord = graphcanvas.convertOffsetToEditorArea(mouseCoord);
                // need prompt to be absolute positioned relative to editor-area that needs relative positioning
                keyEvent.clientX = gloCoord[0];
                keyEvent.clientY = gloCoord[1];

                if(nSel){

                    // get actual title
                    let actT = nSel == 1
                                ? graphcanvas.selected_nodes[Object.keys(graphcanvas.selected_nodes)[0]].title
                                : "titleForMany";
                    
                    // set update function
                    var fCB = function(tIn){
                        for(let iN in graphcanvas.selected_nodes){
                            graphcanvas.selected_nodes[iN].title = tIn;
                        }
                    }
                    
                    // open prompt
                    graphcanvas.prompt(
                        "Title",actT,fCB,keyEvent //,w.options ? w.options.multiline : false,
                    );

                }else{
                    
                    // check is over Group (Note)
                    const groupOver = graphcanvas.graph.getGroupOnPos( mouseCoord[0], mouseCoord[1] );
                    if(groupOver){
                        if(debug) console.warn(ext, "dbg: group to rename",groupOver);
                        // set update function
                        var fCB = function(tIn){
                            groupOver.title = tIn;
                        }
                        // open prompt
                        graphcanvas.prompt(
                            "Title",groupOver.title,fCB,keyEvent //,w.options ? w.options.multiline : false,
                        );
                    }else{

                        if(debug) console.warn(ext, "dbg: nothing to rename");

                    }
                }
            break;
            default:
                if(debug) console.debug("dbg: ignore key",keyEvent.keyCode);
            break;
        }
    });

}

if(typeof(graphcanvas)!=="undefined"){
    registerExtension_renamer(graphcanvas);
}

LiteGraph.registerCallbackHandler("on_lgraphcanvas_construct",function(oCbInfo, graphcanvas){
    registerExtension_renamer(graphcanvas);
});
